<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balƒ±k Kƒ±l√ßƒ±ƒüƒ± - K√∂k Neden Analizi</title>
    <style>
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-card: #1e293b;
            --bg-hover: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --accent-light: rgba(59, 130, 246, 0.15);
            --danger: #ef4444;
            --danger-hover: #dc2626;
            --success: #22c55e;
            --warning: #f59e0b;
            --border: #334155;
            --bone-color: #64748b;
            --spine-color: #334155;
            --shadow: 0 4px 6px -1px rgba(0,0,0,0.3);
            --radius: 10px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        /* ===== HEADER ===== */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 10px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 56px;
            z-index: 100;
            position: relative;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 700;
            font-size: 18px;
        }

        .logo svg {
            width: 28px;
            height: 28px;
            fill: var(--accent);
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.15s;
        }

        .btn:hover {
            background: var(--bg-hover);
        }

        .btn-primary {
            background: var(--accent);
            border-color: var(--accent);
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .btn-secondary {
            background: #0ea5e9;
            border-color: #0ea5e9;
            color: #fff;
        }
        .btn-secondary:hover {
            background: #0284c7;
        }

        .btn-danger {
            color: var(--danger);
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        .btn-icon {
            padding: 8px;
            min-width: 36px;
            justify-content: center;
        }

        /* ===== LAYOUT ===== */
        .app-layout {
            display: flex;
            height: calc(100vh - 56px);
        }

        /* ===== SIDEBAR ===== */
        .sidebar {
            width: 340px;
            min-width: 340px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 16px;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-header h3 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .problem-input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .problem-input {
            width: 100%;
            padding: 10px 14px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }

        .problem-input:focus {
            border-color: var(--accent);
        }

        .cause-tree {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .cause-tree::-webkit-scrollbar {
            width: 6px;
        }

        .cause-tree::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        .tree-node {
            margin-bottom: 2px;
        }

        .tree-node-header {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
            position: relative;
        }

        .tree-node-header:hover {
            background: var(--bg-hover);
        }

        .tree-node-header.selected {
            background: var(--accent-light);
            outline: 1px solid var(--accent);
        }

        .tree-toggle {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 10px;
            flex-shrink: 0;
            transition: transform 0.2s;
        }

        .tree-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .tree-toggle.empty {
            visibility: hidden;
        }

        .tree-color-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .tree-node-label {
            flex: 1;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .tree-node-actions {
            display: none;
            gap: 2px;
        }

        .tree-node-header:hover .tree-node-actions {
            display: flex;
        }

        .tree-action-btn {
            width: 22px;
            height: 22px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.15s;
        }

        .tree-action-btn:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .tree-action-btn.delete:hover {
            color: var(--danger);
        }

        .tree-children {
            margin-left: 20px;
            border-left: 1px dashed var(--border);
            padding-left: 4px;
        }

        .sidebar-footer {
            padding: 12px 16px;
            border-top: 1px solid var(--border);
        }

        .add-main-btn {
            width: 100%;
            padding: 10px;
            border: 2px dashed var(--border);
            border-radius: 8px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .add-main-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: var(--accent-light);
        }

        /* ===== CANVAS ===== */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: var(--bg-primary);
            background-image: 
                radial-gradient(circle, var(--border) 1px, transparent 1px);
            background-size: 24px 24px;
        }

        .canvas-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
        }

        .canvas-wrapper.dragging {
            cursor: grabbing;
        }

        .canvas-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: all;
            user-select: none;
            -webkit-user-select: none;
        }

        .canvas-svg * {
            pointer-events: auto;
        }

        /* Drag handles: invisible by default, appear on hover */
        .canvas-svg .drag-handle-base {
            opacity: 0;
            transition: opacity 0.15s;
            cursor: grab;
        }
        .canvas-svg .drag-handle-base:hover {
            opacity: 0.85;
        }

        .zoom-controls {
            position: absolute;
            bottom: 24px;
            right: 24px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 10;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .zoom-btn:hover {
            background: var(--bg-hover);
        }

        .zoom-level {
            text-align: center;
            font-size: 11px;
            color: var(--text-secondary);
            padding: 4px;
        }

        /* ===== MODAL ===== */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 28px;
            min-width: 400px;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            transform: scale(0.95);
            transition: transform 0.2s;
        }

        .modal-overlay.active .modal {
            transform: scale(1);
        }

        .modal h3 {
            font-size: 18px;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .form-input {
            width: 100%;
            padding: 10px 14px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }

        .form-input:focus {
            border-color: var(--accent);
        }

        .form-textarea {
            resize: vertical;
            min-height: 80px;
            font-family: inherit;
        }

        .color-picker-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .color-option {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.15s;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.selected {
            border-color: var(--text-primary);
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 24px;
        }

        /* ===== TOOLTIP ===== */
        .tooltip {
            position: fixed;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 13px;
            max-width: 280px;
            box-shadow: var(--shadow);
            z-index: 500;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .tooltip-desc {
            color: var(--text-secondary);
            font-size: 12px;
            line-height: 1.4;
        }

        /* ===== CONTEXT MENU ===== */
        .context-menu {
            position: fixed;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 6px;
            min-width: 180px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            z-index: 800;
            display: none;
        }

        .context-menu.visible {
            display: block;
        }

        .context-menu-item {
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.1s;
        }

        .context-menu-item:hover {
            background: var(--bg-hover);
        }

        .context-menu-item.danger {
            color: var(--danger);
        }

        .context-menu-separator {
            height: 1px;
            background: var(--border);
            margin: 4px 8px;
        }

        /* ===== NOTIFICATION ===== */
        .notification {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 12px 20px;
            font-size: 13px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            z-index: 1100;
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .notification.visible {
            transform: translateX(-50%) translateY(0);
        }

        .notification.success {
            border-color: var(--success);
        }

        .notification.error {
            border-color: var(--danger);
        }

        .notification.info {
            border-color: #38bdf8;
            color: #38bdf8;
        }

        /* ===== TEMPLATES MODAL ===== */
        .tmpl-overlay {
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .tmpl-overlay.active { display: flex; }
        .tmpl-modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 14px;
            width: min(820px, 96vw);
            max-height: 88vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 24px 64px rgba(0,0,0,0.5);
            overflow: hidden;
        }
        .tmpl-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 18px 22px 14px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }
        .tmpl-header h2 { font-size: 17px; font-weight: 700; margin: 0; }
        .tmpl-tabs {
            display: flex; gap: 6px;
            padding: 12px 22px 0;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }
        .tmpl-tab {
            padding: 7px 16px; border-radius: 8px 8px 0 0;
            border: 1px solid transparent; border-bottom: none;
            background: transparent; color: var(--text-secondary);
            cursor: pointer; font-size: 13px; font-weight: 500;
            transition: all 0.15s;
        }
        .tmpl-tab.active {
            background: var(--bg-primary);
            border-color: var(--border);
            color: var(--text-primary);
        }
        .tmpl-body {
            padding: 18px 22px;
            overflow-y: auto;
            flex: 1;
        }
        .tmpl-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 14px;
        }
        .tmpl-card {
            border: 1.5px solid var(--border);
            border-radius: 10px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.15s;
            background: var(--bg-primary);
            position: relative;
        }
        .tmpl-card:hover {
            border-color: var(--accent);
            background: rgba(59,130,246,0.06);
            transform: translateY(-1px);
        }
        .tmpl-card-icon {
            font-size: 28px; margin-bottom: 8px;
        }
        .tmpl-card-title {
            font-size: 14px; font-weight: 700; margin-bottom: 4px;
        }
        .tmpl-card-desc {
            font-size: 11px; color: var(--text-secondary); line-height: 1.5;
        }
        .tmpl-card-tags {
            display: flex; flex-wrap: wrap; gap: 4px; margin-top: 8px;
        }
        .tmpl-tag {
            font-size: 10px; padding: 2px 7px;
            border-radius: 20px; border: 1px solid var(--border);
            color: var(--text-secondary);
        }
        .tmpl-card-delete {
            position: absolute; top: 8px; right: 8px;
            background: rgba(239,68,68,0.15); border: none;
            border-radius: 6px; width: 24px; height: 24px;
            color: #ef4444; cursor: pointer; font-size: 13px;
            display: none; align-items: center; justify-content: center;
        }
        .tmpl-card:hover .tmpl-card-delete { display: flex; }
        .tmpl-footer {
            padding: 14px 22px;
            border-top: 1px solid var(--border);
            display: flex; gap: 10px; justify-content: flex-end;
            flex-shrink: 0;
        }
        .tmpl-save-row {
            display: flex; gap: 8px; align-items: center;
            padding: 12px 0 0;
        }
        .tmpl-save-row input {
            flex: 1;
            background: var(--bg-primary); border: 1px solid var(--border);
            border-radius: 8px; padding: 8px 12px;
            color: var(--text-primary); font-size: 13px;
        }
        .tmpl-empty {
            text-align: center; color: var(--text-secondary);
            padding: 40px 20px; font-size: 14px;
        }

        /* ===== QUICK SAVE TEMPLATE MINI MODAL ===== */
        .qsave-overlay {
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.55);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .qsave-overlay.active { display: flex; }
        .qsave-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 26px 28px 22px;
            width: min(400px, 92vw);
            box-shadow: 0 24px 64px rgba(0,0,0,0.5);
        }
        .qsave-box h3 {
            font-size: 15px; font-weight: 700;
            margin: 0 0 14px;
            display: flex; align-items: center; gap: 8px;
            color: var(--accent);
        }
        .qsave-box label {
            font-size: 12px; color: var(--text-secondary);
            display: block; margin-bottom: 6px;
        }
        .qsave-box input {
            width: 100%; box-sizing: border-box;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px 14px;
            color: var(--text-primary);
            font-size: 14px;
            margin-bottom: 16px;
        }
        .qsave-box input:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(99,102,241,.15); }
        .qsave-actions { display: flex; gap: 8px; justify-content: flex-end; }

        /* ===== MINIMAP ===== */
        .minimap {
            position: absolute;
            bottom: 24px;
            left: 24px;
            width: 180px;
            height: 120px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 10px;
            overflow: hidden;
            z-index: 10;
        }

        .minimap-viewport {
            border: 1.5px solid var(--accent);
            background: rgba(59, 130, 246, 0.1);
            position: absolute;
        }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 768px) {
            .sidebar {
                width: 280px;
                min-width: 280px;
            }
        }

        /* ===== ANIMATIONS ===== */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .tree-node {
            animation: slideIn 0.2s ease;
        }

        /* ===== DRAG & DROP ===== */
        .tree-node-header.drag-over-top {
            border-top: 2px solid var(--accent);
        }

        .tree-node-header.drag-over-bottom {
            border-bottom: 2px solid var(--accent);
        }

        .tree-node-header.drag-over-center {
            background: var(--accent-light);
            outline: 2px dashed var(--accent);
        }

        .tree-node-header.dragging {
            opacity: 0.4;
        }

        .drag-ghost {
            position: fixed;
            background: var(--bg-secondary);
            border: 1px solid var(--accent);
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 13px;
            color: var(--text-primary);
            pointer-events: none;
            z-index: 9999;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
            white-space: nowrap;
        }

        /* ===== CONTEXT MENU DISABLED ===== */
        .context-menu-item.disabled {
            opacity: 0.35;
            pointer-events: none;
        }

        /* ===== SNAP GUIDE ===== */
        .snap-guide {
            stroke: var(--accent);
            stroke-width: 1;
            stroke-dasharray: 4,4;
            opacity: 0.6;
            pointer-events: none;
        }

        /* ===== GRAB HANDLES ===== */
        .grab-handle {
            cursor: grab;
            pointer-events: fill;
        }

        /* ===== AUTO LAYOUT TOOLBAR ===== */
        .canvas-toolbar {
            position: absolute;
            top: 12px;
            right: 12px;
            display: flex;
            gap: 6px;
            z-index: 10;
        }

        .toolbar-btn {
            padding: 7px 14px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.15s;
            white-space: nowrap;
        }

        .toolbar-btn:hover {
            background: var(--bg-hover);
        }

        .toolbar-btn.active {
            background: var(--accent);
            border-color: var(--accent);
        }

        .toolbar-btn:disabled {
            opacity: 0.35;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Print styles */
        @media print {
            .sidebar, .header, .zoom-controls, .minimap {
                display: none !important;
            }
            .canvas-container {
                position: static;
                overflow: visible;
            }
        }

        /* ===== VIEW TABS (header nav) ===== */
        .header-nav {
            display: flex;
            gap: 4px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 3px;
        }
        .nav-tab {
            padding: 6px 18px;
            border: none;
            border-radius: 7px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            display: flex; align-items: center; gap: 6px;
            transition: all 0.15s;
            white-space: nowrap;
        }
        .nav-tab:hover { color: var(--text-primary); background: var(--bg-hover); }
        .nav-tab.active { background: var(--accent); color: #fff; }

        /* ===== ACTION PLAN VIEW ===== */
        .action-plan-view {
            flex: 1; display: none; flex-direction: column;
            overflow: hidden; background: var(--bg-primary);
            height: calc(100vh - 56px);
        }
        .ap-toolbar {
            display: flex; align-items: center; justify-content: space-between;
            padding: 14px 24px; border-bottom: 1px solid var(--border);
            background: var(--bg-secondary); flex-shrink: 0; gap: 12px; flex-wrap: wrap;
        }
        .ap-toolbar-left { display: flex; align-items: center; gap: 12px; }
        .ap-toolbar-left h2 { font-size: 16px; font-weight: 700; margin: 0; }
        .ap-problem-badge {
            background: var(--accent); color: #fff;
            border-radius: 20px; padding: 3px 12px; font-size: 12px; font-weight: 600;
            max-width: 260px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        .ap-toolbar-right { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
        .ap-contrib-total {
            font-size: 13px; font-weight: 700; color: var(--text-secondary);
            padding: 6px 14px; border: 1px solid var(--border);
            border-radius: 8px; background: var(--bg-primary);
        }
        /* Table wrapper */
        .ap-body { flex: 1; min-height: 0; overflow-y: auto; padding: 20px 24px; display: block; }
        .ap-table-card { margin-bottom: 24px; }
        .ap-table-card {
            background: var(--bg-secondary); border: 1px solid var(--border);
            border-radius: 12px; overflow: hidden;
        }
        .ap-table-wrap { overflow-x: auto; }
        .ap-table {
            width: 100%; border-collapse: collapse; font-size: 13px;
        }
        .ap-table thead th {
            background: var(--bg-primary); color: var(--text-secondary);
            font-size: 11px; font-weight: 600; text-transform: uppercase;
            letter-spacing: 0.06em; padding: 10px 12px; text-align: left;
            border-bottom: 1px solid var(--border); white-space: nowrap;
        }
        .ap-table tbody tr { border-bottom: 1px solid var(--border); transition: background 0.1s; }
        .ap-table tbody tr:last-child { border-bottom: none; }
        .ap-table tbody tr:hover { background: var(--bg-hover); }
        .ap-table tbody tr.ap-row-done { opacity: 0.6; }
        .ap-table td { padding: 8px 10px; vertical-align: middle; }
        .ap-cause-name { font-weight: 600; color: var(--text-primary); font-size: 13px; }
        .ap-cause-parent { color: var(--text-secondary); font-size: 11px; margin-top: 2px; }
        .ap-input {
            width: 100%; box-sizing: border-box;
            background: var(--bg-primary); border: 1px solid transparent;
            border-radius: 6px; padding: 5px 8px;
            color: var(--text-primary); font-size: 12px;
            transition: border-color 0.15s;
            font-family: inherit;
        }
        .ap-input:focus { outline: none; border-color: var(--accent); }
        .ap-textarea { resize: vertical; min-height: 38px; }
        .ap-select {
            width: 100%; background: var(--bg-primary); border: 1px solid transparent;
            border-radius: 6px; padding: 5px 6px; color: var(--text-primary);
            font-size: 12px; cursor: pointer; font-family: inherit;
        }
        .ap-select:focus { outline: none; border-color: var(--accent); }
        .ap-contrib-wrap { display: flex; flex-direction: column; gap: 4px; }
        .ap-contrib-input { text-align: center; }
        .ap-contrib-bar-wrap {
            height: 4px; background: var(--border); border-radius: 2px; overflow: hidden;
        }
        .ap-contrib-bar {
            height: 100%; background: var(--accent); border-radius: 2px; transition: width 0.2s;
        }
        .ap-del-btn {
            background: none; border: none; color: var(--text-secondary);
            cursor: pointer; font-size: 14px; padding: 4px 8px; border-radius: 6px;
            transition: all 0.15s;
        }
        .ap-del-btn:hover { background: rgba(239,68,68,0.15); color: var(--danger); }
        .btn-8d-ap { background:none; border:1px solid #6366f1; color:#6366f1; border-radius:5px; padding:3px 7px; cursor:pointer; font-size:0.85em; transition:all 0.15s; }
        .btn-8d-ap:hover { background:#6366f1; color:#fff; }
        .ap-empty {
            padding: 48px 24px; text-align: center;
            color: var(--text-secondary); font-size: 14px;
            display: none; flex-direction: column; align-items: center; gap: 16px;
        }
        /* Status color helpers */
        option[value="tamamlandi"] { color: #4ade80; }
        option[value="devam"]      { color: #f59e0b; }
        /* Methods reference panel */
        .ap-methods-card {
            background: var(--bg-secondary); border: 1px solid var(--border);
            border-radius: 12px; overflow: hidden;
        }
        .ap-methods-header {
            padding: 12px 16px; border-bottom: 1px solid var(--border);
            font-size: 13px; font-weight: 600; color: var(--text-secondary);
            display: flex; align-items: center; gap: 8px; cursor: pointer;
            user-select: none;
        }
        .ap-methods-header:hover { color: var(--text-primary); }
        .ap-methods-body { padding: 16px; }
        .ap-methods-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 10px;
        }
        .ap-method-card {
            background: var(--bg-primary); border: 1px solid var(--border);
            border-radius: 8px; padding: 10px 12px;
        }
        .ap-method-title { font-size: 12px; font-weight: 700; color: var(--accent); margin-bottom: 4px; }
        .ap-method-desc { font-size: 11px; color: var(--text-secondary); line-height: 1.5; }
        /* ===== AI ASSƒ∞STAN VIEW ===== */
        .ai-assist-view {
            display: none; flex-direction: row;
            height: calc(100vh - 56px); overflow: hidden;
            background: var(--bg-primary);
        }
        .ai-chat-panel {
            display: flex; flex-direction: column;
            width: 440px; min-width: 340px;
            border-right: 1px solid var(--border);
            background: var(--bg-secondary);
        }
        .ai-chat-header {
            padding: 16px 20px; border-bottom: 1px solid var(--border);
            font-size: 14px; font-weight: 700; display: flex; align-items: center; gap: 10px;
            flex-shrink: 0;
        }
        .ai-chat-header .ai-badge {
            background: linear-gradient(135deg,#6366f1,#3b82f6);
            color:#fff; border-radius:20px; padding:2px 10px; font-size:11px; font-weight:600;
        }
        .ai-messages {
            flex: 1; min-height: 0; overflow-y: auto;
            padding: 16px; display: flex; flex-direction: column; gap: 12px;
        }
        .ai-msg { display: flex; gap: 10px; align-items: flex-start; }
        .ai-msg.user { flex-direction: row-reverse; }
        .ai-msg-avatar {
            width: 30px; height: 30px; border-radius: 50%; flex-shrink: 0;
            display: flex; align-items: center; justify-content: center; font-size: 14px;
            background: linear-gradient(135deg,#6366f1,#3b82f6);
        }
        .ai-msg.user .ai-msg-avatar { background: var(--accent); }
        .ai-msg-bubble {
            max-width: 82%; padding: 10px 14px; border-radius: 14px;
            font-size: 13px; line-height: 1.55; background: var(--bg-primary);
        }
        .ai-msg.user .ai-msg-bubble { background: var(--accent); color: #fff; border-radius: 14px 14px 4px 14px; }
        .ai-msg.bot .ai-msg-bubble { border-radius: 4px 14px 14px 14px; }
        .ai-input-area {
            padding: 12px 16px; border-top: 1px solid var(--border); flex-shrink: 0;
            display: flex; flex-direction: column; gap: 8px;
        }
        .ai-input-area textarea {
            width: 100%; box-sizing: border-box; resize: none; height: 110px;
            padding: 9px 12px;
            background: var(--bg-primary); border: 1px solid var(--border);
            border-radius: 10px; color: var(--text-primary); font-size: 13px;
            font-family: inherit; line-height: 1.6;
        }
        .ai-input-area textarea:focus { outline: none; border-color: var(--accent); }
        .ai-input-footer {
            display: flex; align-items: center; justify-content: space-between; gap: 8px;
        }
        .ai-input-hint {
            font-size: 11px; color: var(--text-secondary);
        }
        .ai-input-hint kbd {
            background: var(--bg-secondary); border: 1px solid var(--border);
            border-radius: 4px; padding: 1px 5px; font-size: 10px; font-family: inherit;
        }
        .ai-template-bar {
            display: none; flex-wrap: wrap; gap: 5px; padding: 0 0 6px 0;
        }
        .ai-template-bar-label {
            font-size: 11px; color: var(--text-secondary); width: 100%;
            margin-bottom: 2px; user-select: none;
        }
        .ai-chip {
            background: var(--bg-secondary); border: 1px solid var(--border);
            border-radius: 20px; padding: 3px 10px; font-size: 11.5px;
            color: var(--text-secondary); cursor: pointer; font-family: monospace;
            transition: border-color 0.15s, color 0.15s, background 0.15s;
            user-select: none;
        }
        .ai-chip:hover {
            border-color: var(--accent); color: var(--accent);
            background: var(--accent-light);
        }
        .ai-send-btn {
            background: var(--accent); border: none; border-radius: 10px;
            color: #fff; cursor: pointer; padding: 8px 20px; font-size: 13px;
            font-weight: 600; font-family: inherit; transition: background 0.15s;
            white-space: nowrap; flex-shrink: 0;
        }
        .ai-send-btn:hover { background: var(--accent-hover); }
        .ai-send-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        /* Right panel - preview */
        .ai-preview-panel {
            flex: 1; min-width: 0; display: flex; flex-direction: column; overflow: hidden;
        }
        .ai-preview-header {
            padding: 16px 20px; border-bottom: 1px solid var(--border);
            font-size: 14px; font-weight: 700; flex-shrink: 0;
            display: flex; align-items: center; justify-content: space-between;
        }
        .ai-preview-body { flex: 1; min-height: 0; overflow-y: auto; padding: 20px; }
        .ai-step-indicator {
            display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 20px;
        }
        .ai-step-dot {
            width: 28px; height: 6px; border-radius: 3px;
            background: var(--border); transition: background 0.2s;
        }
        .ai-step-dot.active { background: var(--accent); }
        .ai-step-dot.done { background: #22c55e; }
        .ai-category-card {
            background: var(--bg-secondary); border: 1px solid var(--border);
            border-radius: 10px; padding: 14px 16px; margin-bottom: 12px;
        }
        .ai-category-title {
            font-size: 12px; font-weight: 700; color: var(--text-secondary);
            text-transform: uppercase; letter-spacing: 0.06em; margin-bottom: 8px;
        }
        .ai-tag-list { display: flex; flex-wrap: wrap; gap: 6px; }
        .ai-tag {
            background: var(--accent-light); border: 1px solid var(--accent);
            color: var(--accent); border-radius: 20px; padding: 3px 10px;
            font-size: 12px; display: flex; align-items: center; gap: 5px;
        }
        .ai-tag-del {
            cursor: pointer; opacity: 0.7; font-size: 14px; line-height: 1;
        }
        .ai-tag-del:hover { opacity: 1; color: var(--danger); }
        .ai-tag-tree { flex-direction: column; align-items: flex-start; border-radius: 10px; padding: 5px 10px; gap: 2px; }
        .ai-tag-tree > span.ai-tag-del { align-self: flex-end; margin-top: -18px; }
        .ai-tag-badge {
            background: var(--accent); color: #fff; border-radius: 10px;
            font-size: 10px; padding: 1px 5px; margin-left: 2px; font-weight: 700;
        }
        .ai-tag-subs {
            font-size: 11px; color: var(--text-secondary); margin-top: 2px;
            padding-left: 4px; border-left: 2px solid var(--accent);
            line-height: 1.5;
        }
        .ai-tag-empty { color: var(--text-secondary); font-size: 12px; font-style: italic; }
        .ai-generate-btn {
            width: 100%; padding: 14px; border-radius: 12px; border: none;
            background: linear-gradient(135deg,#6366f1,#3b82f6);
            color: #fff; font-size: 14px; font-weight: 700;
            cursor: pointer; font-family: inherit; margin-top: 8px;
            transition: opacity 0.15s;
        }
        .ai-generate-btn:hover { opacity: 0.88; }
        .ai-generate-btn:disabled { opacity: 0.35; cursor: not-allowed; }
        .ai-reset-btn {
            background: none; border: 1px solid var(--border); border-radius: 8px;
            color: var(--text-secondary); font-size: 12px; padding: 5px 12px;
            cursor: pointer; font-family: inherit;
        }
        .ai-reset-btn:hover { border-color: var(--danger); color: var(--danger); }
        /* Cause‚Äëname cell editable */
        .ap-td-cause { min-width: 140px; }
        .ap-cause-edit {
            width: 100%; background: var(--bg-primary); border: 1px solid transparent;
            border-radius: 6px; padding: 4px 7px; color: var(--text-primary);
            font-size: 13px; font-weight: 600; font-family: inherit;
        }
        .ap-cause-edit:focus { outline: none; border-color: var(--accent); }
        /* Parent cause sub-label */
        .ap-parent-label { font-size: 10px; color: var(--text-secondary); margin-top: 2px; font-weight: 400; }
        .ap-cat-select {
            width: 100%; margin-top: 4px; padding: 3px 6px; font-size: 11px;
            background: var(--bg-secondary); border: 1px solid var(--border);
            border-radius: 6px; color: var(--text-secondary); font-family: inherit;
            cursor: pointer;
        }
        .ap-cat-select:focus { outline: none; border-color: var(--accent); }
        /* Contribution cell layout */
        .ap-contrib-cell { display: flex; flex-direction: column; gap: 4px; }
        .ap-contrib-input { text-align: center; }
        /* Status row tints */
        .ap-row.done td { opacity: 0.55; }
        .ap-row.done { background: rgba(74,222,128,0.04); }
        .ap-row.cancelled td { opacity: 0.4; text-decoration: line-through; }
        .ap-row.wip { background: rgba(245,158,11,0.05); }
        /* Contribution total badge colors */
        .ap-contrib-total.perfect { color: #22c55e; border-color: #22c55e; }
        .ap-contrib-total.over { color: #ef4444; border-color: #ef4444; }
        /* Action textarea */
        .ap-action-ta { resize: vertical; min-height: 40px; }
    </style>
</head>
<body>

<!-- HEADER -->
<div class="header">
    <div class="header-left">
        <div class="logo">
            <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>
            K√∂k Neden Analizi
        </div>
        <div class="header-nav">
            <button class="nav-tab active" id="tabFishbone" onclick="switchView('fishbone')">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 12h16M4 12l4-4M4 12l4 4M20 12l-4-4M20 12l-4 4M4 12c2-4 8-6 8-6s6 2 8 6"/></svg>
                Balƒ±k Kƒ±l√ßƒ±ƒüƒ±
            </button>
            <button class="nav-tab" id="tabAction" onclick="switchView('action')">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg>
                Aksiyon Planƒ±
            </button>
            <button class="nav-tab" id="tabAI" onclick="switchView('ai')">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="5"/><path d="M9 8h.01M15 8h.01M12 11v1"/><path d="M5 20a7 7 0 0 1 14 0"/><path d="M12 13c-2 2-4 2-5 4"/><path d="M12 13c2 2 4 2 5 4"/></svg>
                AI Asistan
            </button>
        </div>
    </div>
    <div class="header-actions">
        <a id="backBtn" href="index.html" class="btn" title="Geri D√∂n" style="text-decoration:none;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg>
            Ana Sayfa
        </a>
        <a href="coa-arsiv.html" class="btn" title="COA" style="text-decoration:none;">üìÑ COA</a>
        <a href="uygunsuzluk-analizi.html" class="btn" title="Uygunsuzluk Analizi" style="text-decoration:none;">‚ö†Ô∏è Uygunsuzluk</a>
        <a href="8d-rapor.html" class="btn" title="8D Raporu" style="text-decoration:none;">üìã 8D</a>
        <button class="btn" onclick="openTemplates()" title="≈ûablonlar">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7" rx="1"/><rect x="14" y="3" width="7" height="7" rx="1"/><rect x="14" y="14" width="7" height="7" rx="1"/><rect x="3" y="14" width="7" height="7" rx="1"/></svg>
            ≈ûablonlar
        </button>
        <button class="btn" onclick="openQuickSaveTemplate()" title="Diyagramƒ± ≈üablon olarak kaydet" style="color:var(--accent)">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
            ≈ûablon Kaydet
        </button>
        <button class="btn" onclick="resetDiagram()" title="Yeni Diyagram">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
            Yeni
        </button>
        <button class="btn" onclick="saveDiagram()" title="Kaydet">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>
            Kaydet
        </button>
        <button class="btn" onclick="loadDiagram()" title="Y√ºkle">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
            Y√ºkle
        </button>
        <button class="btn btn-primary" onclick="exportAsPNG()" title="PNG olarak dƒ±≈üa aktar">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
            PNG
        </button>
    </div>
</div>

<!-- LAYOUT -->
<div class="app-layout" id="fishboneView">
    <!-- SIDEBAR -->
    <div class="sidebar">
        <div class="sidebar-header">
            <h3>Problem Tanƒ±mƒ±</h3>
            <div class="problem-input-group">
                <input type="text" class="problem-input" id="problemTitle" placeholder="Problem ba≈ülƒ±ƒüƒ±..." value="Ana Problem">
                <textarea class="problem-input form-textarea" id="problemDesc" placeholder="Problem a√ßƒ±klamasƒ± (isteƒüe baƒülƒ±)..." rows="2" style="min-height:50px"></textarea>
            </div>
        </div>

        <div class="cause-tree" id="causeTree">
            <!-- Tree nodes rendered here -->
        </div>

        <div class="sidebar-footer">
            <button class="add-main-btn" onclick="addMainCause()">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
                Ana Neden Ekle
            </button>
        </div>
    </div>

    <!-- CANVAS -->
    <div class="canvas-container" id="canvasContainer">
        <div class="canvas-wrapper" id="canvasWrapper">
            <svg class="canvas-svg" id="canvasSvg"></svg>
        </div>

        <div class="canvas-toolbar">
            <button class="toolbar-btn" id="undoBtn" onclick="undo()" title="Geri Al (Ctrl+Z)" disabled>
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 14 4 9 9 4"/><path d="M20 20v-7a4 4 0 0 0-4-4H4"/></svg>
                Geri Al
            </button>
            <button class="toolbar-btn" id="redoBtn" onclick="redo()" title="Yeniden Yap (Ctrl+Y)" disabled>
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 14 20 9 15 4"/><path d="M4 20v-7a4 4 0 0 1 4-4h12"/></svg>
                Yeniden Yap
            </button>
            <button class="toolbar-btn" onclick="autoLayout()" title="Otomatik Yerle≈ütir (yazƒ± boyutu, aralƒ±k, hizalama)">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg>
                Otomatik Yerle≈ütir
            </button>
            <button class="toolbar-btn active" id="snapToggle" onclick="toggleSnap()" title="√áizgiye Yapƒ±≈üma (Snap)">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10H7"/><path d="M21 6H3"/><path d="M21 14H3"/><path d="M21 18H7"/></svg>
                Snap
            </button>
            <button class="toolbar-btn active" id="subBoxToggle" onclick="toggleSubBoxes()" title="Alt neden kutularƒ±nƒ± g√∂ster/gizle">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="8" width="8" height="6" rx="1.5"/><rect x="13" y="8" width="8" height="6" rx="1.5"/><line x1="3" y1="5" x2="21" y2="5" stroke-dasharray="2,2"/></svg>
                Alt Kutular
            </button>
        </div>

        <div class="zoom-controls">
            <button class="zoom-btn" onclick="zoomIn()">+</button>
            <div class="zoom-level" id="zoomLevel">100%</div>
            <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
            <button class="zoom-btn" onclick="resetView()" title="Sƒ±fƒ±rla" style="font-size:13px;">‚ü≥</button>
        </div>
    </div>
</div>

<!-- AI ASSISTANT VIEW -->
<div class="ai-assist-view" id="aiAssistView">
    <div class="ai-chat-panel">
        <div class="ai-chat-header">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="5"/><path d="M5 20a7 7 0 0 1 14 0"/></svg>
            AI Asistan
            <span class="ai-badge">Beta</span>
        </div>
        <div class="ai-messages" id="aiMessages"></div>
        <div class="ai-input-area">
            <div class="ai-template-bar">
                <span class="ai-template-bar-label">üìå ≈ûablon ekle:</span>
                <span class="ai-chip" onclick="aiInsertChip('D√ºz')" title="D√ºz liste">Neden1, Neden2</span>
                <span class="ai-chip" onclick="aiInsertChip('Alt')" title="Alt neden">Neden &gt; Alt1, Alt2</span>
                <span class="ai-chip" onclick="aiInsertChip('AltAlt')" title="3. seviye">Neden &gt; Alt &gt; Alt-alt</span>
            </div>
            <textarea id="aiUserInput"
                placeholder="Neden1, Neden2&#10;Neden > Alt1, Alt2&#10;Neden > Alt > Alt-alt"
                onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();aiSend();}"></textarea>
            <div class="ai-input-footer">
                <span class="ai-input-hint"><kbd>Enter</kbd> g√∂nder &nbsp;&middot;&nbsp; <kbd>Shift+Enter</kbd> yeni satƒ±r</span>
                <button class="ai-send-btn" id="aiSendBtn" onclick="aiSend()">G√∂nder</button>
            </div>
        </div>
    </div>
    <div class="ai-preview-panel">
        <div class="ai-preview-header">
            <span>Olu≈üturulan Nedenler</span>
            <button class="ai-reset-btn" onclick="aiReset()">Sƒ±fƒ±rla</button>
        </div>
        <div class="ai-preview-body">
            <div class="ai-step-indicator" id="aiStepIndicator"></div>
            <div id="aiCategoryCards"></div>
            <button class="ai-generate-btn" id="aiGenerateBtn" onclick="aiGenerateFishbone()" disabled>
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align:middle;margin-right:6px"><path d="M4 12h16M4 12l4-4M4 12l4 4"/></svg>
                Balƒ±k Kƒ±l√ßƒ±ƒüƒ±nƒ± Olu≈ütur
            </button>
        </div>
    </div>
</div>

<!-- ACTION PLAN VIEW -->
<div class="action-plan-view" id="actionPlanView">
    <div class="ap-toolbar">
        <div class="ap-toolbar-left">
            <h2>Aksiyon Planƒ±</h2>
            <span class="ap-problem-badge" id="apProblemBadge">Ana Problem</span>
        </div>
        <div class="ap-toolbar-right">
            <button class="btn" onclick="syncCausesToActionPlan()" title="Balƒ±k kƒ±l√ßƒ±ƒüƒ±ndaki nedenleri aksiyon planƒ±na ekle">
                <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6.7L21 8"/><path d="M3 22v-6h6"/><path d="M21 12a9 9 0 0 1-15 6.7L3 16"/></svg>
                Kƒ±l√ßƒ±ktan Senkronize Et
            </button>
            <button class="btn" onclick="addActionRow()">
                <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
                Aksiyon Ekle
            </button>
            <button class="btn" onclick="exportActionPlanXLSX()" title="Excel olarak indir">
                <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                Excel ƒ∞ndir
            </button>
            <button class="btn btn-secondary" onclick="downloadFishbonePng()" title="Diyagramƒ± PNG olarak indir">
                <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
                Diyagram PNG
            </button>
            <div class="ap-contrib-total" id="apContribTotal">Toplam Katkƒ±: 0%</div>
        </div>
    </div>
    <div class="ap-body">
        <div class="ap-table-card">
            <div class="ap-table-wrap">
                <table class="ap-table" id="apTable">
                    <thead>
                        <tr>
                            <th style="width:18%">K√∂k Neden</th>
                            <th style="width:22%">Aksiyon</th>
                            <th style="width:10%">Sorumlu</th>
                            <th style="width:9%">Hedef Tarih</th>
                            <th style="width:7%">Katkƒ± %</th>
                            <th style="width:16%">√á√∂z√ºm Y√∂ntemi</th>
                            <th style="width:9%">Durum</th>
                            <th style="width:5%">8D</th>
                            <th style="width:3%"></th>
                        </tr>
                    </thead>
                    <tbody id="apTableBody"></tbody>
                </table>
                <div class="ap-empty" id="apEmpty">
                    <div>Hen√ºz aksiyon satƒ±rƒ± yok.</div>
                    <button class="btn btn-primary" onclick="syncCausesToActionPlan()">
                        <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6.7L21 8"/></svg>
                        Balƒ±k Kƒ±l√ßƒ±ƒüƒ±ndan Otomatik Olu≈ütur
                    </button>
                </div>
            </div>
        </div>
        <div class="ap-methods-card">
            <div class="ap-methods-header" onclick="var b=this.nextElementSibling;b.style.display=b.style.display==='none'?'block':'none'">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>
                √á√∂z√ºm Y√∂ntemleri Rehberi ‚Äî tƒ±klayarak a√ß/kapat
            </div>
            <div class="ap-methods-body" id="apMethodsBody" style="display:none">
                <div class="ap-methods-grid" id="apMethodsGrid"></div>
            </div>
        </div>
    </div>
</div>

<!-- QUICK SAVE TEMPLATE MINI MODAL -->
<div class="qsave-overlay" id="qsaveOverlay" onclick="if(event.target===this)closeQuickSaveTemplate()">
  <div class="qsave-box">
    <h3>
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
      ≈ûablon Olarak Kaydet
    </h3>
    <label>≈ûablon adƒ±</label>
    <input type="text" id="qsaveNameInput" autocomplete="off"
           placeholder="√ñrn: √úretim Hattƒ± Analizi"
           onkeydown="if(event.key==='Enter')confirmQuickSave();if(event.key==='Escape')closeQuickSaveTemplate()" />
    <div class="qsave-actions">
      <button class="btn" onclick="closeQuickSaveTemplate()">ƒ∞ptal</button>
      <button class="btn btn-primary" onclick="confirmQuickSave()">
        <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>
        Kaydet
      </button>
    </div>
  </div>
</div>

<!-- TEMPLATES MODAL -->
<div class="tmpl-overlay" id="tmplOverlay" onclick="if(event.target===this)closeTemplates()">
  <div class="tmpl-modal">
    <div class="tmpl-header">
      <h2>üìê ≈ûablonlar</h2>
      <button onclick="closeTemplates()" style="background:none;border:none;color:var(--text-secondary);font-size:20px;cursor:pointer">‚úï</button>
    </div>
    <div class="tmpl-tabs">
      <button class="tmpl-tab active" id="tabBuiltin" onclick="switchTmplTab('builtin')">Hazƒ±r ≈ûablonlar</button>
      <button class="tmpl-tab" id="tabSaved" onclick="switchTmplTab('saved')">Kaydedilen ≈ûablonlar</button>
    </div>
    <div class="tmpl-body">
      <div id="tmplBuiltinPanel"><div class="tmpl-grid" id="tmplBuiltinGrid"></div></div>
      <div id="tmplSavedPanel" style="display:none">
        <div class="tmpl-grid" id="tmplSavedGrid"></div>
        <div class="tmpl-save-row">
          <input type="text" id="tmplSaveName" placeholder="≈ûablon adƒ± girin..." />
          <button class="btn btn-primary" onclick="saveCurrentAsTemplate()">üíæ Mevcut Diyagramƒ± Kaydet</button>
        </div>
      </div>
    </div>
    <div class="tmpl-footer">
      <button class="btn" onclick="closeTemplates()">Kapat</button>
    </div>
  </div>
</div>

<!-- MODAL -->
<div class="modal-overlay" id="modalOverlay">
    <div class="modal">
        <h3 id="modalTitle">Neden Ekle</h3>
        <div class="form-group">
            <label>Neden Ba≈ülƒ±ƒüƒ± *</label>
            <input type="text" class="form-input" id="causeNameInput" placeholder="Neden adƒ±nƒ± girin...">
        </div>
        <div class="form-group">
            <label>A√ßƒ±klama</label>
            <textarea class="form-input form-textarea" id="causeDescInput" placeholder="Detaylƒ± a√ßƒ±klama (isteƒüe baƒülƒ±)..."></textarea>
        </div>
        <div class="form-group" id="colorPickerGroup">
            <label>Renk</label>
            <div class="color-picker-group" id="colorPicker"></div>
        </div>
        <div class="modal-actions">
            <button class="btn" onclick="closeModal()">ƒ∞ptal</button>
            <button class="btn btn-primary" id="modalSaveBtn" onclick="saveModal()">Ekle</button>
        </div>
    </div>
</div>

<!-- CONTEXT MENU -->
<div class="context-menu" id="contextMenu">
    <div class="context-menu-item" onclick="contextAction('addChild')">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
        Alt Neden Ekle
    </div>
    <div class="context-menu-item" onclick="contextAction('edit')">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
        D√ºzenle
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" id="ctxMoveUp" onclick="contextAction('moveUp')">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="18 15 12 9 6 15"/></svg>
        Yukarƒ± Ta≈üƒ±
    </div>
    <div class="context-menu-item" id="ctxMoveDown" onclick="contextAction('moveDown')">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
        A≈üaƒüƒ± Ta≈üƒ±
    </div>
    <div class="context-menu-item" id="ctxNudgeLeft" onclick="contextAction('nudgeLeft')">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/><line x1="9" y1="12" x2="20" y2="12"/></svg>
        Sola Ta≈üƒ±
    </div>
    <div class="context-menu-item" id="ctxNudgeRight" onclick="contextAction('nudgeRight')">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/><line x1="4" y1="12" x2="15" y2="12"/></svg>
        Saƒüa Ta≈üƒ±
    </div>
    <div class="context-menu-item" id="ctxMoveLeft" onclick="contextAction('flipTop')">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="19" x2="12" y2="5"/><polyline points="5 12 12 5 19 12"/></svg>
        √úste Ta≈üƒ±
    </div>
    <div class="context-menu-item" id="ctxMoveRight" onclick="contextAction('flipBottom')">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><polyline points="19 12 12 19 5 12"/></svg>
        Alta Ta≈üƒ±
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" id="ctxPromote" onclick="contextAction('promote')">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/></svg>
        Bir √úste Y√ºkselt
    </div>
    <div class="context-menu-item" id="ctxDemote" onclick="contextAction('demote')">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>
        Bir Alta ƒ∞ndir
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" id="ctxResetPos" onclick="contextAction('resetPosition')">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
        Konumu Sƒ±fƒ±rla
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item danger" onclick="contextAction('delete')">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
        Sil
    </div>
</div>

<!-- TOOLTIP -->
<div class="tooltip" id="tooltip">
    <div class="tooltip-title" id="tooltipTitle"></div>
    <div class="tooltip-desc" id="tooltipDesc"></div>
</div>

<!-- NOTIFICATION -->
<div class="notification" id="notification"></div>

<!-- Hidden file input for loading -->
<input type="file" id="fileInput" accept=".json" style="display:none" onchange="handleFileLoad(event)">

<script>
// =====================================================================
// FISHBONE DIAGRAM - ROOT CAUSE ANALYSIS SOFTWARE
// =====================================================================

const COLORS = [
    '#3b82f6', '#8b5cf6', '#ec4899', '#ef4444', '#f59e0b',
    '#22c55e', '#06b6d4', '#f97316', '#6366f1', '#14b8a6'
];

let state = {
    problem: 'Ana Problem',
    problemDesc: '',
    causes: [],
    selectedCauseId: null,
    nextId: 1,
    zoom: 1,
    panX: 0,
    panY: 0,
    isPanning: false,
    panStartX: 0,
    panStartY: 0,
};

let modalMode = null; // 'add', 'addChild', 'edit'
let modalTargetId = null;
let contextTargetId = null;

// ===== UNDO / REDO =====
const _undoStack = [];
const _redoStack = [];
let _preDragSnapshot = null;

function _snapshot() {
    return {
        causes:      JSON.parse(JSON.stringify(state.causes)),
        problem:     state.problem,
        problemDesc: state.problemDesc || '',
        nextId:      state.nextId,
    };
}

function pushHistory() {
    _undoStack.push(_snapshot());
    if (_undoStack.length > 60) _undoStack.shift();
    _redoStack.length = 0;
    _updateUndoRedoBtns();
}

function _commitDragHistory() {
    if (!_preDragSnapshot) return;
    _undoStack.push(_preDragSnapshot);
    if (_undoStack.length > 60) _undoStack.shift();
    _redoStack.length = 0;
    _preDragSnapshot = null;
    _updateUndoRedoBtns();
}

function undo() {
    if (!_undoStack.length) return;
    _redoStack.push(_snapshot());
    const snap = _undoStack.pop();
    _restoreSnapshot(snap);
    _updateUndoRedoBtns();
    showNotification('Geri alƒ±ndƒ±', 'info');
}

function redo() {
    if (!_redoStack.length) return;
    _undoStack.push(_snapshot());
    const snap = _redoStack.pop();
    _restoreSnapshot(snap);
    _updateUndoRedoBtns();
    showNotification('Yeniden yapƒ±ldƒ±', 'info');
}

function _restoreSnapshot(snap) {
    state.causes      = JSON.parse(JSON.stringify(snap.causes));
    state.problem     = snap.problem;
    state.problemDesc = snap.problemDesc || '';
    state.nextId      = snap.nextId;
    document.getElementById('problemTitle').value = state.problem;
    document.getElementById('problemDesc').value  = state.problemDesc;
    render();
    autoSave();
}

function _updateUndoRedoBtns() {
    const u = document.getElementById('undoBtn');
    const r = document.getElementById('redoBtn');
    if (u) u.disabled = _undoStack.length === 0;
    if (r) r.disabled = _redoStack.length === 0;
}

// ===== INIT =====
document.addEventListener('DOMContentLoaded', () => {
    // Uygunsuzluk Analizi'nden gelen veri var mƒ±?
    let _fromUygunsuzluk = false;
    let _incomingCauses = null;
    const _rawIncoming = localStorage.getItem('fishbone_incoming');
    if (_rawIncoming) {
        localStorage.removeItem('fishbone_incoming');
        try {
            const inData = JSON.parse(_rawIncoming);
            state.problem     = inData.problem     || 'Ana Problem';
            state.problemDesc = inData.problemDesc || '';
            state.nextId      = (inData.nextId > 1) ? inData.nextId : 1;
            state.selectedCauseId = null;
            // Cause'larƒ± ge√ß uygula (render sonrasƒ± g√ºvenli)
            if (Array.isArray(inData.causes) && inData.causes.length > 0) {
                state.causes     = inData.causes;
                _incomingCauses  = inData.causes;
            } else {
                state.causes = [];
            }
            _fromUygunsuzluk = true;
        } catch(e) { console.error('fishbone_incoming parse hatasƒ±:', e); }
    }

    // Kayƒ±tlƒ± durumu y√ºkle (gelen veri yoksa)
    if (!_fromUygunsuzluk) {
        const saved = localStorage.getItem('fishbone_state');
        if (saved) {
            try {
                const parsed = JSON.parse(saved);
                Object.assign(state, parsed);
            } catch(e) {}
        }
    }
    document.getElementById('problemTitle').value = state.problem;
    document.getElementById('problemDesc').value  = state.problemDesc || '';

    setupColorPicker();
    setupCanvasInteractions();
    setupKeyboardShortcuts();
    initActionPlan();
    render();

    // G√ºvenlik: gelen cause'lar render sonrasƒ± da state'de olduƒüunu garantile
    if (_incomingCauses && _incomingCauses.length > 0) {
        if (!state.causes || state.causes.length === 0) {
            state.causes = _incomingCauses;
            render();
        }
    }

    // Geri butonunu d√ºzenle
    const _src = localStorage.getItem('fishbone_source');
    localStorage.removeItem('fishbone_source'); // tek seferlik
    if (_fromUygunsuzluk || _src === 'uygunsuzluk-analizi') {
        const backBtn = document.getElementById('backBtn');
        if (backBtn) {
            backBtn.href = 'uygunsuzluk-analizi.html';
            backBtn.title = 'Uygunsuzluk Analizi\'ne D√∂n';
            backBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg> Uygunsuzluk Analizi';
        }
    }

    // Uygunsuzluk analizinden gelindiyse bildirim g√∂ster
    if (_fromUygunsuzluk) {
        setTimeout(() => showNotification('Uygunsuzluk Analizi\'nden problem aktarƒ±ldƒ± üêü', 'success'), 600);
    }

    // Problem input listener
    document.getElementById('problemTitle').addEventListener('input', (e) => {
        state.problem = e.target.value || 'Ana Problem';
        render();
        autoSave();
    });
    document.getElementById('problemDesc').addEventListener('input', (e) => {
        state.problemDesc = e.target.value;
        autoSave();
    });
});

// ===== COLOR PICKER =====
function setupColorPicker() {
    const picker = document.getElementById('colorPicker');
    COLORS.forEach((color, i) => {
        const div = document.createElement('div');
        div.className = 'color-option' + (i === 0 ? ' selected' : '');
        div.style.background = color;
        div.dataset.color = color;
        div.onclick = () => {
            picker.querySelectorAll('.color-option').forEach(c => c.classList.remove('selected'));
            div.classList.add('selected');
        };
        picker.appendChild(div);
    });
}

function getSelectedColor() {
    const sel = document.querySelector('.color-option.selected');
    return sel ? sel.dataset.color : COLORS[0];
}

function setSelectedColor(color) {
    const picker = document.getElementById('colorPicker');
    picker.querySelectorAll('.color-option').forEach(c => {
        c.classList.toggle('selected', c.dataset.color === color);
    });
}

// ===== CAUSES DATA MODEL =====
function generateId() {
    return state.nextId++;
}

function findCause(id, causes = state.causes) {
    for (const cause of causes) {
        if (cause.id === id) return cause;
        if (cause.children.length) {
            const found = findCause(id, cause.children);
            if (found) return found;
        }
    }
    return null;
}

function findParent(id, causes = state.causes, parent = null) {
    for (const cause of causes) {
        if (cause.id === id) return parent;
        if (cause.children.length) {
            const found = findParent(id, cause.children, cause);
            if (found !== undefined) return found;
        }
    }
    return undefined;
}

// Returns 'top' or 'bottom' by walking up to the root ancestor
function getRootSide(id) {
    function walk(id, list) {
        for (const c of list) {
            if (c.id === id) return c.side || 'top';
            const found = walk(id, c.children || []);
            if (found) return found;
        }
        return null;
    }
    // Find root ancestor's side
    function rootOf(id, list) {
        for (const c of list) {
            if (c.id === id) return c.side || 'top';
            if (hasDescendant(id, c.children)) return c.side || 'top';
        }
        return 'top';
    }
    function hasDescendant(id, list) {
        for (const c of list) {
            if (c.id === id) return true;
            if (hasDescendant(id, c.children || [])) return true;
        }
        return false;
    }
    return rootOf(id, state.causes);
}

function removeCause(id, causes = state.causes) {
    const idx = causes.findIndex(c => c.id === id);
    if (idx !== -1) {
        causes.splice(idx, 1);
        return true;
    }
    for (const cause of causes) {
        if (removeCause(id, cause.children)) return true;
    }
    return false;
}

function getDepth(cause) {
    let depth = 0;
    let current = cause;
    let parent = findParent(current.id);
    while (parent) {
        depth++;
        current = parent;
        parent = findParent(current.id);
    }
    return depth;
}

function getMainCauseColor(cause) {
    let current = cause;
    let parent = findParent(current.id);
    while (parent) {
        current = parent;
        parent = findParent(current.id);
    }
    return current.color;
}

function getSubtreeCount(cause) {
    let count = 1;
    for (const child of cause.children) {
        count += getSubtreeCount(child);
    }
    return count;
}

// ===== MODAL =====
function openModal(mode, targetId = null) {
    modalMode = mode;
    modalTargetId = targetId;

    const overlay = document.getElementById('modalOverlay');
    const title = document.getElementById('modalTitle');
    const nameInput = document.getElementById('causeNameInput');
    const descInput = document.getElementById('causeDescInput');
    const colorGroup = document.getElementById('colorPickerGroup');
    const saveBtn = document.getElementById('modalSaveBtn');

    nameInput.value = '';
    descInput.value = '';

    if (mode === 'add') {
        title.textContent = 'Ana Neden Ekle';
        colorGroup.style.display = 'block';
        setSelectedColor(COLORS[state.causes.length % COLORS.length]);
        saveBtn.textContent = 'Ekle';
    } else if (mode === 'addChild') {
        title.textContent = 'Alt Neden Ekle';
        colorGroup.style.display = 'none';
        saveBtn.textContent = 'Ekle';
    } else if (mode === 'edit') {
        const cause = findCause(targetId);
        title.textContent = 'Nedeni D√ºzenle';
        nameInput.value = cause.name;
        descInput.value = cause.description || '';
        const depth = getDepth(cause);
        colorGroup.style.display = depth === 0 ? 'block' : 'none';
        if (depth === 0) setSelectedColor(cause.color);
        saveBtn.textContent = 'Kaydet';
    }

    overlay.classList.add('active');
    setTimeout(() => nameInput.focus(), 100);
}

function closeModal() {
    document.getElementById('modalOverlay').classList.remove('active');
    modalMode = null;
    modalTargetId = null;
}

function saveModal() {
    const name = document.getElementById('causeNameInput').value.trim();
    if (!name) {
        showNotification('L√ºtfen bir neden adƒ± girin', 'error');
        return;
    }

    const desc = document.getElementById('causeDescInput').value.trim();

    pushHistory(); // undo/redo: kayƒ±t

    if (modalMode === 'add') {
        // yeni ana neden: side'ƒ± mevcut sayƒ±ya g√∂re belirle (√ßift=√ºst, tek=alt)
        const newSide = state.causes.length % 2 === 0 ? 'top' : 'bottom';
        const cause = {
            id: generateId(),
            name: name,
            description: desc,
            color: getSelectedColor(),
            children: [],
            collapsed: false,
            side: newSide,
            offsetX: 0,
            offsetY: 0,
            baseOffsetX: 0,
            baseOffsetY: 0
        };
        state.causes.push(cause);
    } else if (modalMode === 'addChild') {
        const parent = findCause(modalTargetId);
        if (parent) {
            const child = {
                id: generateId(),
                name: name,
                description: desc,
                color: getMainCauseColor(parent),
                children: [],
                collapsed: false,
                offsetX: 0,
                offsetY: 0
            };
            parent.children.push(child);
            parent.collapsed = false;
        }
    } else if (modalMode === 'edit') {
        const cause = findCause(modalTargetId);
        if (cause) {
            cause.name = name;
            cause.description = desc;
            const depth = getDepth(cause);
            if (depth === 0) {
                cause.color = getSelectedColor();
                // Update children colors
                function updateChildColors(c, color) {
                    c.color = color;
                    c.children.forEach(ch => updateChildColors(ch, color));
                }
                updateChildColors(cause, cause.color);
            }
        }
    }

    closeModal();
    render();
    autoSave();
}

// ===== CONTEXT MENU =====
function showContextMenu(e, causeId) {
    e.preventDefault();
    e.stopPropagation();
    contextTargetId = causeId;

    const menu = document.getElementById('contextMenu');

    // Enable/disable menu items based on context
    const cause = findCause(causeId);
    const parentCause = findParent(causeId);
    const siblingList = parentCause ? parentCause.children : state.causes;
    const idx = siblingList.indexOf(cause);

    const SVG_UP    = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="18 15 12 9 6 15"/></svg>`;
    const SVG_DOWN  = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>`;
    const SVG_LEFT  = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/><line x1="9" y1="12" x2="20" y2="12"/></svg>`;
    const SVG_RIGHT = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/><line x1="4" y1="12" x2="15" y2="12"/></svg>`;

    // Move up/down: for main causes ‚Üí reorder; for sub-causes ‚Üí flip branch side
    if (parentCause) {
        // Alt neden: Yukarƒ±/A≈üaƒüƒ± = sibling sƒ±rasƒ±
        // Alt kemikler i√ßin y√∂n tersine d√∂nd√ºƒü√ºnden disabled da tersine √ßevrilir
        const isBottomBone = getRootSide(causeId) === 'bottom';
        if (isBottomBone) {
            document.getElementById('ctxMoveUp').classList.toggle('disabled', idx <= 0);
            document.getElementById('ctxMoveDown').classList.toggle('disabled', idx >= siblingList.length - 1);
        } else {
            document.getElementById('ctxMoveUp').classList.toggle('disabled', idx >= siblingList.length - 1);
            document.getElementById('ctxMoveDown').classList.toggle('disabled', idx <= 0);
        }
        // Sola/Saƒüa = branchFlip toggle ‚Äî etiket dal y√∂n√ºne g√∂re (yatay=sola/saƒüa, √ßapraz=yukarƒ±/a≈üaƒüƒ±)
        document.getElementById('ctxNudgeLeft').classList.toggle('disabled', !cause.branchFlip);
        document.getElementById('ctxNudgeRight').classList.toggle('disabled', !!cause.branchFlip);
        const causeDepth = getDepth(cause); // 1=yatay, 2=√ßapraz, 3=yatay ...
        const isHorizBranch = (causeDepth % 2 === 1);
        if (isHorizBranch) {
            // Yatay dal: branchFlip sadece sol/saƒü deƒüi≈ütirir
            document.getElementById('ctxNudgeLeft').innerHTML  = SVG_LEFT  + ' Sola Ta≈üƒ±';
            document.getElementById('ctxNudgeRight').innerHTML = SVG_RIGHT + ' Saƒüa Ta≈üƒ±';
        } else {
            // √áapraz dal: branchFlip g√∂rsel olarak yukarƒ±/a≈üaƒüƒ± deƒüi≈ütirir
            const isBottomBone = getRootSide(causeId) === 'bottom';
            if (isBottomBone) {
                document.getElementById('ctxNudgeLeft').innerHTML  = SVG_DOWN + ' A≈üaƒüƒ± Konumla';
                document.getElementById('ctxNudgeRight').innerHTML = SVG_UP   + ' Yukarƒ± Konumla';
            } else {
                document.getElementById('ctxNudgeLeft').innerHTML  = SVG_UP   + ' Yukarƒ± Konumla';
                document.getElementById('ctxNudgeRight').innerHTML = SVG_DOWN + ' A≈üaƒüƒ± Konumla';
            }
        }
    } else {
        // Ana kemik: Yukarƒ±/A≈üaƒüƒ± = spine √ºst/alt
        document.getElementById('ctxMoveUp').classList.toggle('disabled', cause.side === 'top');
        document.getElementById('ctxMoveDown').classList.toggle('disabled', cause.side === 'bottom');
        // Sola/Saƒüa = spine √ºzerinde 2 konum atla
        document.getElementById('ctxNudgeLeft').classList.toggle('disabled', idx < 2);
        document.getElementById('ctxNudgeRight').classList.toggle('disabled', idx >= siblingList.length - 2);
        document.getElementById('ctxNudgeLeft').innerHTML  = SVG_LEFT  + ' Sola Ta≈üƒ±';
        document.getElementById('ctxNudgeRight').innerHTML = SVG_RIGHT + ' Saƒüa Ta≈üƒ±';
    }
    // Promote: disabled if already at top level (no parent)
    document.getElementById('ctxPromote').classList.toggle('disabled', !parentCause);
    // Demote: disabled if first in list (no previous sibling to become child of)
    document.getElementById('ctxDemote').classList.toggle('disabled', idx <= 0);
    // Reset position: disabled if no offset
    const hasOffset = (cause.offsetX || 0) !== 0 || (cause.offsetY || 0) !== 0;
    document.getElementById('ctxResetPos').classList.toggle('disabled', !hasOffset);
    // √úste/Alta Ta≈üƒ±: sadece ana kemikler i√ßin (Sola/Saƒüa zaten spine yanƒ± yapƒ±yor)
    const isTopLevel = !parentCause;
    document.getElementById('ctxMoveLeft').classList.toggle('disabled', true);   // gizle/devre dƒ±≈üƒ±
    document.getElementById('ctxMoveRight').classList.toggle('disabled', true);
    // menu zaten yukarƒ±da visible yapƒ±ldƒ±

    // Konumlandƒ±r: √∂nce ekrana sƒ±ƒüacak yeri hesapla
    menu.style.left = '-9999px';
    menu.style.top  = '-9999px';
    menu.classList.add('visible');
    const mw = menu.offsetWidth  || 200;
    const mh = menu.offsetHeight || 300;
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const left = (e.clientX + mw + 6 > vw) ? e.clientX - mw : e.clientX;
    const top  = (e.clientY + mh + 6 > vh) ? e.clientY - mh : e.clientY;
    menu.style.left = Math.max(4, left) + 'px';
    menu.style.top  = Math.max(4, top)  + 'px';
}

function hideContextMenu() {
    document.getElementById('contextMenu').classList.remove('visible');
    contextTargetId = null;
}

function contextAction(action) {
    if (!contextTargetId) return;
    const id = contextTargetId;
    hideContextMenu();

    if (action === 'addChild') {
        openModal('addChild', id);
    } else if (action === 'edit') {
        openModal('edit', id);
    } else if (action === 'moveUp') {
        if (findParent(id)) {
            const dir = getRootSide(id) === 'bottom' ? -1 : 1;
            moveCause(id, dir);
        } else flipCauseSide(id, 'top');
    } else if (action === 'moveDown') {
        if (findParent(id)) {
            const dir = getRootSide(id) === 'bottom' ? 1 : -1;
            moveCause(id, dir);
        } else flipCauseSide(id, 'bottom');
    } else if (action === 'promote') {
        promoteCause(id);
    } else if (action === 'demote') {
        demoteCause(id);
    } else if (action === 'nudgeLeft') {
        if (findParent(id)) setBranchFlip(id, false); else moveCause(id, -1);
    } else if (action === 'nudgeRight') {
        if (findParent(id)) setBranchFlip(id, true);  else moveCause(id, 1);
    } else if (action === 'flipTop') {
        flipCauseSide(id, 'top');
    } else if (action === 'flipBottom') {
        flipCauseSide(id, 'bottom');
    } else if (action === 'resetPosition') {
        resetCausePosition(id);
    } else if (action === 'delete') {
        const cause = findCause(id);
        if (cause) {
            const count = getSubtreeCount(cause);
            if (count > 1) {
                if (!confirm(`"${cause.name}" ve ${count - 1} alt nedeni silinecek. Devam edilsin mi?`)) return;
            }
            pushHistory();
            removeCause(id);
            if (state.selectedCauseId === id) state.selectedCauseId = null;
            render();
            autoSave();
        }
    }
}

// ===== MOVE / PROMOTE / DEMOTE =====
function moveCause(id, direction) {
    const cause = findCause(id);
    const parentCause = findParent(id);
    const list = parentCause ? parentCause.children : state.causes;
    const idx = list.indexOf(cause);
    pushHistory();

    // Ana kemik: 2 pozisyon atlayarak ta≈üƒ± (bir oku kolu ge√ßer)
    // Alt nedenler: 1 pozisyon ta≈üƒ± (normal sƒ±ralama)
    const step = parentCause ? 1 : 2;
    const newIdx = idx + direction * step;
    if (newIdx < 0 || newIdx >= list.length) return;

    // Ana kemik swap: her ikisinin side'ƒ±nƒ± swap √ñNCESƒ∞ sabitle
    // b√∂ylece g√∂rsel √ºst/alt konumlarƒ± deƒüi≈ümez, sadece spine √ºzerindeki X pozisyonu deƒüi≈üir
    if (!parentCause) {
        const other = list[newIdx];
        const sideA = cause.side !== undefined ? cause.side : (idx % 2 === 0 ? 'top' : 'bottom');
        const sideB = other.side !== undefined ? other.side : (newIdx % 2 === 0 ? 'top' : 'bottom');
        cause.side = sideA;
        other.side = sideB;
    }

    // Swap positions
    [list[idx], list[newIdx]] = [list[newIdx], list[idx]];
    render();
    autoSave();
    showNotification(direction < 0 ? 'Sola ta≈üƒ±ndƒ±' : 'Saƒüa ta≈üƒ±ndƒ±', 'success');
}

function nudgeCause(id, dx, dy) {
    const cause = findCause(id);
    if (!cause) return;
    pushHistory();
    cause.offsetX = (cause.offsetX || 0) + dx;
    cause.offsetY = (cause.offsetY || 0) + dy;
    const hasOffset = cause.offsetX !== 0 || cause.offsetY !== 0;
    const btn = document.getElementById('ctxResetPos');
    if (btn) btn.classList.toggle('disabled', !hasOffset);
    render();
    autoSave();
    showNotification(dx < 0 ? 'Sola ta≈üƒ±ndƒ±' : 'Saƒüa ta≈üƒ±ndƒ±', 'success');
}

function flipCauseSide(id, side) {
    const cause = findCause(id);
    if (!cause) return;
    pushHistory();
    cause.side = side;
    render();
    autoSave();
    showNotification(side === 'top' ? '√úste ta≈üƒ±ndƒ±' : 'Alta ta≈üƒ±ndƒ±', 'success');
}

function flipLabelSide(id, flipped) {
    const cause = findCause(id);
    if (!cause) return;
    cause.labelFlip = flipped;
    render();
    autoSave();
    showNotification(flipped ? 'Yazƒ± kar≈üƒ± yana ta≈üƒ±ndƒ±' : 'Yazƒ± kar≈üƒ± yana ta≈üƒ±ndƒ±', 'success');
}

function toggleLabelFlip(id) {
    const cause = findCause(id);
    if (!cause) return;
    cause.labelFlip = !cause.labelFlip;
    render();
    autoSave();
    showNotification(cause.labelFlip ? 'Yazƒ± kar≈üƒ± yana ta≈üƒ±ndƒ±' : 'Yazƒ± eski konumuna d√∂nd√º', 'success');
}

function toggleBranchFlip(id) {
    const cause = findCause(id);
    if (!cause) return;
    pushHistory();
    cause.branchFlip = !cause.branchFlip;
    cause.offsetX = 0;
    cause.offsetY = 0;
    render();
    autoSave();
    showNotification(cause.branchFlip ? 'Kar≈üƒ± tarafa ta≈üƒ±ndƒ±' : 'Eski konumuna d√∂nd√º', 'success');
}

function setBranchFlip(id, flipped) {
    const cause = findCause(id);
    if (!cause) return;
    if (cause.branchFlip === flipped) return; // zaten o konumda
    pushHistory();
    cause.branchFlip = flipped;
    cause.offsetX = 0;
    cause.offsetY = 0;
    render();
    autoSave();
    showNotification(flipped ? 'Kar≈üƒ± tarafa ta≈üƒ±ndƒ±' : 'Normal tarafa d√∂nd√º', 'success');
}

function promoteCause(id) {
    const cause = findCause(id);
    const parentCause = findParent(id);
    if (!parentCause) {
        showNotification('Zaten en √ºst seviyede', 'error');
        return;
    }
    pushHistory();
    const grandParent = findParent(parentCause.id);
    const parentList = grandParent ? grandParent.children : state.causes;
    const parentIdx = parentList.indexOf(parentCause);

    // Remove from current parent
    const childIdx = parentCause.children.indexOf(cause);
    parentCause.children.splice(childIdx, 1);

    // Insert after the parent in grandparent's list
    parentList.splice(parentIdx + 1, 0, cause);

    // Ana kemik seviyesine y√ºkseldiyse side ata
    if (!grandParent) {
        const insertedIdx = state.causes.indexOf(cause);
        if (cause.side === undefined || cause.side === null) {
            cause.side = insertedIdx % 2 === 0 ? 'top' : 'bottom';
        }
    }

    // Update color to match new parent chain
    if (!grandParent) {
        // Promoted to top level, keep its own color or assign new
        // Already has color from main cause
    } else {
        cause.color = getMainCauseColor(cause);
        function updateColors(c, col) { c.color = col; c.children.forEach(ch => updateColors(ch, col)); }
        updateColors(cause, cause.color);
    }

    render();
    autoSave();
    showNotification(`"${cause.name}" bir √ºst seviyeye y√ºkseltildi`, 'success');
}

function demoteCause(id) {
    const cause = findCause(id);
    const parentCause = findParent(id);
    const list = parentCause ? parentCause.children : state.causes;
    const idx = list.indexOf(cause);
    if (idx <= 0) {
        showNotification('ƒ∞ndirilemez (√∂ncesinde karde≈ü yok)', 'error');
        return;
    }
    pushHistory();
    const prevSibling = list[idx - 1];

    // Remove from current position
    list.splice(idx, 1);

    // Add as last child of previous sibling
    prevSibling.children.push(cause);
    prevSibling.collapsed = false;

    // Update color to match new parent chain
    const newColor = getMainCauseColor(cause);
    function updateColors(c, col) { c.color = col; c.children.forEach(ch => updateColors(ch, col)); }
    updateColors(cause, newColor);

    render();
    autoSave();
    showNotification(`"${cause.name}" bir alt seviyeye indirildi`, 'success');
}

function resetCausePosition(id) {
    const cause = findCause(id);
    if (!cause) return;
    pushHistory();
    cause.offsetX = 0;
    cause.offsetY = 0;
    cause.baseOffsetX = 0;
    cause.baseOffsetY = 0;
    render();
    autoSave();
    showNotification('Konum sƒ±fƒ±rlandƒ±', 'success');
}

function resetAllPositions() {
    pushHistory();
    function clearOffsets(causes) {
        causes.forEach(c => {
            c.offsetX = 0;
            c.offsetY = 0;
            c.baseOffsetX = 0;
            c.baseOffsetY = 0;
            clearOffsets(c.children);
        });
    }
    clearOffsets(state.causes);
    render();
    autoSave();
    showNotification('T√ºm konumlar sƒ±fƒ±rlandƒ±', 'success');
}

document.addEventListener('click', () => hideContextMenu());

// ===== TREE RENDERING =====
function renderTree() {
    const container = document.getElementById('causeTree');
    container.innerHTML = '';

    if (state.causes.length === 0) {
        container.innerHTML = `
            <div style="text-align:center; padding:40px 20px; color:var(--text-secondary);">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-bottom:12px;opacity:0.5">
                    <path d="M2 12h20M12 2l-4 10 4 10M12 2l4 10-4 10"/>
                    <line x1="6" y1="6" x2="12" y2="12"/><line x1="18" y1="6" x2="12" y2="12"/>
                    <line x1="6" y1="18" x2="12" y2="12"/><line x1="18" y1="18" x2="12" y2="12"/>
                </svg>
                <div style="font-size:14px;font-weight:500;margin-bottom:6px;">Hen√ºz neden eklenmedi</div>
                <div style="font-size:12px;">"Ana Neden Ekle" butonuna tƒ±klayarak ba≈ülayƒ±n</div>
            </div>
        `;
        return;
    }

    state.causes.forEach(cause => {
        container.appendChild(createTreeNode(cause));
    });
}

// ===== DRAG & DROP STATE =====
let dragState = {
    dragging: false,
    dragCauseId: null,
    ghost: null,
    dropTarget: null,
    dropPosition: null // 'before', 'after', 'inside'
};

function createTreeNode(cause) {
    const node = document.createElement('div');
    node.className = 'tree-node';
    node.dataset.causeId = cause.id;

    const header = document.createElement('div');
    header.className = 'tree-node-header' + (state.selectedCauseId === cause.id ? ' selected' : '');
    header.dataset.causeId = cause.id;
    header.draggable = true;

    header.onclick = (e) => {
        e.stopPropagation();
        state.selectedCauseId = cause.id;
        render();
    };
    header.oncontextmenu = (e) => showContextMenu(e, cause.id);
    header.ondblclick = () => openModal('edit', cause.id);

    // ‚îÄ‚îÄ Drag events ‚îÄ‚îÄ
    header.addEventListener('dragstart', (e) => {
        e.stopPropagation();
        dragState.dragging = true;
        dragState.dragCauseId = cause.id;
        header.classList.add('dragging');

        // Invisible drag image (we draw our own ghost)
        const transparent = document.createElement('div');
        transparent.style.opacity = '0';
        document.body.appendChild(transparent);
        e.dataTransfer.setDragImage(transparent, 0, 0);
        setTimeout(() => transparent.remove(), 0);

        // Create ghost
        const ghost = document.createElement('div');
        ghost.className = 'drag-ghost';
        ghost.textContent = cause.name;
        document.body.appendChild(ghost);
        dragState.ghost = ghost;

        e.dataTransfer.effectAllowed = 'move';
    });

    header.addEventListener('dragend', (e) => {
        cleanDrag();
    });

    header.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!dragState.dragging || dragState.dragCauseId === cause.id) return;

        // Don't allow dropping on own descendant
        if (isDescendant(dragState.dragCauseId, cause.id)) return;

        e.dataTransfer.dropEffect = 'move';

        const rect = header.getBoundingClientRect();
        const y = e.clientY - rect.top;
        const h = rect.height;

        // Clear all drop indicators
        clearDropIndicators();

        if (y < h * 0.25) {
            header.classList.add('drag-over-top');
            dragState.dropTarget = cause.id;
            dragState.dropPosition = 'before';
        } else if (y > h * 0.75) {
            header.classList.add('drag-over-bottom');
            dragState.dropTarget = cause.id;
            dragState.dropPosition = 'after';
        } else {
            header.classList.add('drag-over-center');
            dragState.dropTarget = cause.id;
            dragState.dropPosition = 'inside';
        }
    });

    header.addEventListener('dragleave', (e) => {
        header.classList.remove('drag-over-top', 'drag-over-bottom', 'drag-over-center');
    });

    header.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!dragState.dragging || !dragState.dropTarget) return;
        executeDrop();
    });

    // Toggle
    const toggle = document.createElement('div');
    toggle.className = 'tree-toggle' + (cause.children.length === 0 ? ' empty' : (cause.collapsed ? ' collapsed' : ''));
    toggle.textContent = '‚ñº';
    toggle.onclick = (e) => {
        e.stopPropagation();
        cause.collapsed = !cause.collapsed;
        render();
    };
    header.appendChild(toggle);

    // Color dot
    const dot = document.createElement('div');
    dot.className = 'tree-color-dot';
    dot.style.background = cause.color;
    header.appendChild(dot);

    // Label
    const label = document.createElement('div');
    label.className = 'tree-node-label';
    label.textContent = cause.name;
    header.appendChild(label);

    // Actions
    const actions = document.createElement('div');
    actions.className = 'tree-node-actions';

    const addBtn = document.createElement('button');
    addBtn.className = 'tree-action-btn';
    addBtn.innerHTML = '+';
    addBtn.title = 'Alt neden ekle';
    addBtn.onclick = (e) => { e.stopPropagation(); openModal('addChild', cause.id); };
    actions.appendChild(addBtn);

    const editBtn = document.createElement('button');
    editBtn.className = 'tree-action-btn';
    editBtn.innerHTML = '‚úé';
    editBtn.title = 'D√ºzenle';
    editBtn.onclick = (e) => { e.stopPropagation(); openModal('edit', cause.id); };
    actions.appendChild(editBtn);

    const delBtn = document.createElement('button');
    delBtn.className = 'tree-action-btn delete';
    delBtn.innerHTML = '‚úï';
    delBtn.title = 'Sil';
    delBtn.onclick = (e) => {
        e.stopPropagation();
        contextTargetId = cause.id;
        contextAction('delete');
    };
    actions.appendChild(delBtn);

    header.appendChild(actions);
    node.appendChild(header);

    // Children
    if (cause.children.length > 0 && !cause.collapsed) {
        const childContainer = document.createElement('div');
        childContainer.className = 'tree-children';
        cause.children.forEach(child => {
            childContainer.appendChild(createTreeNode(child));
        });
        node.appendChild(childContainer);
    }

    return node;
}

// ===== DRAG HELPERS =====
function isDescendant(ancestorId, nodeId) {
    const ancestor = findCause(ancestorId);
    if (!ancestor) return false;
    function check(children) {
        for (const c of children) {
            if (c.id === nodeId) return true;
            if (check(c.children)) return true;
        }
        return false;
    }
    return check(ancestor.children);
}

function clearDropIndicators() {
    document.querySelectorAll('.drag-over-top, .drag-over-bottom, .drag-over-center').forEach(el => {
        el.classList.remove('drag-over-top', 'drag-over-bottom', 'drag-over-center');
    });
}

function cleanDrag() {
    dragState.dragging = false;
    if (dragState.ghost) {
        dragState.ghost.remove();
        dragState.ghost = null;
    }
    clearDropIndicators();
    document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
    dragState.dragCauseId = null;
    dragState.dropTarget = null;
    dragState.dropPosition = null;
}

function executeDrop() {
    const srcId = dragState.dragCauseId;
    const tgtId = dragState.dropTarget;
    const pos = dragState.dropPosition;

    if (!srcId || !tgtId || srcId === tgtId) { cleanDrag(); return; }

    const srcCause = findCause(srcId);
    if (!srcCause) { cleanDrag(); return; }

    // Clone source cause data before removing
    const srcClone = JSON.parse(JSON.stringify(srcCause));

    // Remove from original position
    pushHistory();
    removeCause(srcId);

    const tgtCause = findCause(tgtId);
    if (!tgtCause) { cleanDrag(); return; }

    if (pos === 'inside') {
        // Add as child of target
        tgtCause.children.push(srcClone);
        tgtCause.collapsed = false;
    } else {
        // Insert before or after target in target's parent list
        const tgtParent = findParent(tgtId);
        const list = tgtParent ? tgtParent.children : state.causes;
        const tgtIdx = list.findIndex(c => c.id === tgtId);
        const insertIdx = pos === 'before' ? tgtIdx : tgtIdx + 1;
        list.splice(insertIdx, 0, srcClone);
    }

    // Update colors to match new hierarchy
    const newColor = getMainCauseColor(srcClone);
    function updateColors(c, col) { c.color = col; c.children.forEach(ch => updateColors(ch, col)); }
    updateColors(srcClone, newColor);

    cleanDrag();
    render();
    autoSave();
    showNotification('Ta≈üƒ±ndƒ±', 'success');
}

// Ghost follow mouse
document.addEventListener('dragover', (e) => {
    if (dragState.ghost) {
        dragState.ghost.style.left = (e.clientX + 12) + 'px';
        dragState.ghost.style.top = (e.clientY + 12) + 'px';
    }
});

// ===== SVG CANVAS DRAG STATE =====
let svgDragState = {
    active: false,
    causeId: null,
    dragMode: 'tip',
    startMouseX: 0,
    startMouseY: 0,
    startOffsetX: 0,
    startOffsetY: 0,
    moved: false,
    DRAG_THRESHOLD: 1,
    snapEnabled: true,
    SNAP_CROSS_DISTANCE: 25,
    _snapTarget: null
};

// Store computed base positions for snap calculation
let computedPositions = new Map(); // causeId -> {baseX, baseY, anchorX, anchorY}

// Store all rendered line segments for cross-line snapping
// Each entry: { x1, y1, x2, y2, causeId (owner) }
let renderedLines = [];

// ===== FISHBONE DIAGRAM RENDERING =====
function renderFishbone() {
    const svg = document.getElementById('canvasSvg');
    const container = document.getElementById('canvasContainer');
    const W = container.clientWidth;
    const H = container.clientHeight;
    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

    // Sync toolbar button states
    const _als = state.autoLayoutSettings || {};
    const _sbBtn = document.getElementById('subBoxToggle');
    if (_sbBtn) _sbBtn.classList.toggle('active', _als.showSubBoxes !== false);

    computedPositions.clear();
    renderedLines = [];
    let svgContent = '';
    let hitContent = '';   // unused ‚Äî kept for compatibility, geometric detection used instead
    // NOTE: hit lines use stroke="${color}" (non-none = painted) + low opacity
    // so SVG pointer-events:auto (=visiblePainted) fires correctly.
    const defs = `
        <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                <polygon points="0 0, 10 3.5, 0 7" fill="var(--spine-color)" opacity="0.8"/>
            </marker>
        </defs>`;

    const centerY = H / 2;

    // ===== AUTO-LAYOUT SCALING =====
    const totalNodes = countAllNodes(state.causes);
    const als = state.autoLayoutSettings || {};
    const baseFontMain = als.fontSizeMain || 14;
    const baseFontSub = als.fontSizeSub || 13;
    const boneLen = als.boneLength || Math.min(220, H * 0.37);
    const branchLen = als.branchLength || 100;
    const subBranchLen = als.subBranchLength || 60;
    const showSubBoxes = als.showSubBoxes !== false; // default: true

    // Spine: als.spineLength varsa (autoLayout ayarladƒ±) onu kullan ‚Äî yoksa W-220 (default)
    const spineStartX = 80;
    const spineLength  = (als.spineLength && als.spineLength > 0) ? als.spineLength : (W - 80 - 140);
    const spineEndX    = spineStartX + spineLength;

    svgContent += `<g transform="translate(${state.panX},${state.panY}) scale(${state.zoom})">`;

    // ‚îÄ‚îÄ SPINE ‚îÄ‚îÄ
    svgContent += `<line x1="${spineStartX}" y1="${centerY}" x2="${spineEndX}" y2="${centerY}"
        stroke="var(--spine-color)" stroke-width="5" stroke-linecap="round" marker-end="url(#arrowhead)"
        class="spine-line"/>`;

    // ‚îÄ‚îÄ PROBLEM BOX (fish head) ‚îÄ‚îÄ
    const headX = spineEndX + 12, headW = 160;
    // Word-wrap problem text inside the head box
    const headFontSize = 14;
    const headChPerLine = Math.max(8, Math.floor((headW - 16) / (headFontSize * 0.62)));
    const headWordsList = state.problem.split(' ');
    const headLinesList = [];
    let headCurLine = '';
    for (const w of headWordsList) {
        const test = headCurLine ? headCurLine + ' ' + w : w;
        if (test.length > headChPerLine && headCurLine) { headLinesList.push(headCurLine); headCurLine = w; }
        else { headCurLine = test; }
    }
    if (headCurLine) headLinesList.push(headCurLine);
    const headLineH = headFontSize + 4;
    const headH = Math.max(52, headLinesList.length * headLineH + 16);
    const headCX = headX + headW / 2;
    const headTY = centerY - ((headLinesList.length - 1) * headLineH) / 2;
    const headTspans = headLinesList.map((ln, li) =>
        `<tspan x="${headCX}" dy="${li === 0 ? 0 : headLineH}">${escapeHtml(ln)}</tspan>`
    ).join('');
    svgContent += `
        <rect x="${headX}" y="${centerY - headH/2}" width="${headW}" height="${headH}" rx="8"
              fill="var(--accent)" opacity="0.15" stroke="var(--accent)" stroke-width="2.5"/>
        <text x="${headCX}" y="${headTY}" text-anchor="middle" dominant-baseline="central"
              fill="var(--accent)" font-size="${headFontSize}" font-weight="700">
            ${headTspans}
        </text>`;

    // ‚îÄ‚îÄ FISH TAIL + SPINE RESIZE HANDLE ‚îÄ‚îÄ
    // Kuyruk √º√ßgeni
    svgContent += `<polygon points="${spineStartX},${centerY} ${spineStartX-40},${centerY-35} ${spineStartX-40},${centerY+35}"
        fill="var(--spine-color)" opacity="0.15" stroke="var(--spine-color)" stroke-width="1.5"/>`;  
    // Spine resize handle: kuyruk ucunda, yatay s√ºr√ºkle ‚Üí spine uzar/kƒ±salƒ±r
    svgContent += `<g data-drag-mode="spine-resize" style="cursor:ew-resize">
        <rect x="${spineStartX-48}" y="${centerY-18}" width="16" height="36" rx="4"
              fill="var(--spine-color)" opacity="0.35" stroke="var(--spine-color)" stroke-width="1.5"/>
        <line x1="${spineStartX-44}" y1="${centerY-6}" x2="${spineStartX-36}" y2="${centerY-6}"
              stroke="white" stroke-width="1.5" opacity="0.7" stroke-linecap="round"/>
        <line x1="${spineStartX-44}" y1="${centerY}"   x2="${spineStartX-36}" y2="${centerY}"
              stroke="white" stroke-width="1.5" opacity="0.7" stroke-linecap="round"/>
        <line x1="${spineStartX-44}" y1="${centerY+6}" x2="${spineStartX-36}" y2="${centerY+6}"
              stroke="white" stroke-width="1.5" opacity="0.7" stroke-linecap="round"/>
    </g>`;

    // ‚îÄ‚îÄ MAIN CAUSE BONES ‚îÄ‚îÄ
    if (state.causes.length > 0) {
        const numCauses = state.causes.length;
        const boneAngleRad = 60 * Math.PI / 180;
        const spacing = spineLength / (numCauses + 1);

        state.causes.forEach((cause, i) => {
        const isTop = cause.side === 'top' ? true
                     : cause.side === 'bottom' ? false
                     : (i % 2 === 0);
            const dir = isTop ? -1 : 1;
            const boneBaseX = spineStartX + spacing * (i + 1);

            // Apply baseOffset ‚Äî dragging root moves the whole bone
            const baseOffX = cause.baseOffsetX || 0;
            const baseOffY = cause.baseOffsetY || 0;
            const actualBaseX = boneBaseX + baseOffX;
            const actualBaseY = centerY + baseOffY;

            const baseTipX = actualBaseX - boneLen * Math.cos(boneAngleRad);
            const baseTipY = actualBaseY + dir * boneLen * Math.sin(boneAngleRad);
            const tipX = baseTipX + (cause.offsetX || 0);
            const tipY = baseTipY + (cause.offsetY || 0);

            computedPositions.set(cause.id, {
                baseX: baseTipX, baseY: baseTipY,
                anchorX: actualBaseX, anchorY: actualBaseY
            });

            // Visual: thin bone line
            svgContent += `<line x1="${actualBaseX}" y1="${actualBaseY}" x2="${tipX}" y2="${tipY}"
                stroke="${cause.color}" stroke-width="2.5" opacity="0.85" stroke-linecap="round" pointer-events="none"/>`;
            renderedLines.push({ x1: actualBaseX, y1: actualBaseY, x2: tipX, y2: tipY, causeId: cause.id });

            // Draggable ROOT handle (k√∂k noktasƒ±) ‚Äî hidden by default, hover shows it
            const isBaseDragged = svgDragState.active && svgDragState.causeId === cause.id && svgDragState.dragMode === 'base';
            svgContent += `<circle cx="${actualBaseX}" cy="${actualBaseY}" r="${isBaseDragged ? 10 : 7}"
                fill="${cause.color}"
                stroke="white" stroke-width="2"
                data-cause-id="${cause.id}" data-drag-mode="base"
                class="drag-handle-base"
                style="${isBaseDragged ? 'opacity:1;cursor:grabbing' : ''}"/>`;

            // Draggable TIP handle ‚Äî only visible while dragging
            const isTipDragged = svgDragState.active && svgDragState.causeId === cause.id && svgDragState.dragMode === 'tip';
            if (isTipDragged) {
                svgContent += `<circle cx="${tipX}" cy="${tipY}" r="8"
                    fill="${cause.color}" opacity="0.9"
                    stroke="white" stroke-width="1.5"
                    style="pointer-events:none"/>`;
            }

            // Category label box (with word-wrap)
            const sel = state.selectedCauseId === cause.id;
            const lblMaxW = 140;
            const lblChPerLine = Math.max(8, Math.floor(lblMaxW / (baseFontMain * 0.62)));
            const lblWords = cause.name.split(' ');
            const lblLines = [];
            let lblCur = '';
            for (const w of lblWords) {
                const test = lblCur ? lblCur + ' ' + w : w;
                if (test.length > lblChPerLine && lblCur) { lblLines.push(lblCur); lblCur = w; }
                else { lblCur = test; }
            }
            if (lblCur) lblLines.push(lblCur);
            const lblLineH = baseFontMain + 4;
            const lblW = lblMaxW;
            const lblH = Math.max(34, lblLines.length * lblLineH + 12);
            const lblX = tipX - lblW / 2;
            const lblY = isTop ? tipY - lblH - 10 : tipY + 10;
            const lblTspans = lblLines.map((ln, li) =>
                `<tspan x="${tipX}" dy="${li === 0 ? lblLineH : lblLineH}">${escapeHtml(ln)}</tspan>`
            ).join('');

            svgContent += `
                <g data-cause-id="${cause.id}" style="cursor:grab">
                <rect x="${lblX}" y="${lblY}" width="${lblW}" height="${lblH}" rx="6"
                      fill="${cause.color}" opacity="${sel ? 0.35 : 0.15}"
                      stroke="${cause.color}" stroke-width="${sel ? 2.5 : 1.5}"/>
                <text x="${tipX}" y="${lblY + 4}" text-anchor="middle"
                      fill="${cause.color}" font-size="${baseFontMain}" font-weight="700" style="pointer-events:none">
                    ${lblTspans}
                </text>
                </g>`;

            // Main bone unit vector (for even-depth parallelism)
            const mbdx = tipX - actualBaseX, mbdy = tipY - actualBaseY;
            const mblen = Math.sqrt(mbdx * mbdx + mbdy * mbdy) || 1;
            const mainUX = mbdx / mblen, mainUY = mbdy / mblen;

            drawChildren(cause.children,
                { x: actualBaseX, y: actualBaseY }, { x: tipX, y: tipY },
                dir, cause.color, 1, mainUX, mainUY);
        });
    }

    // Store spine line in renderedLines so bones can snap to it (causeId: null = spine, no reparent)
    renderedLines.push({ x1: spineStartX, y1: centerY, x2: spineEndX, y2: centerY, causeId: null });

    // Snap guide visuals (drawn on top if dragging with snap)
    if (svgDragState.active && svgDragState.moved && svgDragState.snapEnabled) {
        // Show own-line guide (actual current bone position)
        const pos = computedPositions.get(svgDragState.causeId);
        const _guideCause = findCause(svgDragState.causeId);
        if (pos && _guideCause) {
            const _curTipX = pos.baseX + (_guideCause.offsetX || 0);
            const _curTipY = pos.baseY + (_guideCause.offsetY || 0);
            svgContent += `<line x1="${pos.anchorX}" y1="${pos.anchorY}" x2="${_curTipX}" y2="${_curTipY}"
                class="snap-guide" style="pointer-events:none"/>`;
        }
        // Show cross-line snap indicator
        if (svgDragState._snapTarget) {
            const st = svgDragState._snapTarget;
            const snapColor = st.snapCauseId != null ? '#4ade80' : '#22d3ee';
            // Highlight the target line
            svgContent += `<line x1="${st.lx1}" y1="${st.ly1}" x2="${st.lx2}" y2="${st.ly2}"
                stroke="${snapColor}" stroke-width="3" stroke-dasharray="8,4" opacity="0.7" style="pointer-events:none"/>`;
            // Snap point dot
            svgContent += `<circle cx="${st.px}" cy="${st.py}" r="10" fill="none" stroke="${snapColor}" stroke-width="1.5" opacity="0.45" style="pointer-events:none"/>`;
            svgContent += `<circle cx="${st.px}" cy="${st.py}" r="5" fill="${snapColor}" opacity="0.95" style="pointer-events:none"/>`;
            // Compute perpendicular direction to target line (for label placement)
            const ldx = st.lx2 - st.lx1, ldy = st.ly2 - st.ly1;
            const llen = Math.sqrt(ldx * ldx + ldy * ldy) || 1;
            // Perpendicular unit vector (rotated 90¬∞ CCW: -ldy, ldx)
            let pnx = -ldy / llen, pny = ldx / llen;
            // Orient perpendicular toward the SAME side as the dragged endpoint
            const _dragCause = findCause(svgDragState.causeId);
            const _dragPos = computedPositions.get(svgDragState.causeId);
            if (_dragCause && _dragPos) {
                // In base drag, snap is at the ANCHOR end; in tip drag, snap is at TIP end
                let snapRefX, snapRefY;
                if (svgDragState.dragMode === 'base') {
                    snapRefX = _dragPos.anchorX;
                    snapRefY = _dragPos.anchorY;
                } else {
                    snapRefX = _dragPos.baseX + (_dragCause.offsetX || 0);
                    snapRefY = _dragPos.baseY + (_dragCause.offsetY || 0);
                }
                // dot product: if negative, perpendicular points away from endpoint ‚Üí flip
                const dot = pnx * (snapRefX - st.px) + pny * (snapRefY - st.py);
                if (dot < 0) { pnx = -pnx; pny = -pny; }
            }
            const labelDist = 36; // px offset from snap point along perpendicular
            const lblAnchorX = st.px + pnx * labelDist;
            const lblAnchorY = st.py + pny * labelDist;
            // If reparenting, show target cause name label perpendicular to line
            if (st.snapCauseId != null) {
                const targetC = findCause(st.snapCauseId);
                if (targetC) {
                    const lbl = `\u2192 "${targetC.name}" alt\u0131na ta\u015f\u0131`;
                    const boxW = lbl.length * 7.5 + 14;
                    const boxH = 22;
                    const boxX = lblAnchorX - boxW / 2;
                    const boxY = lblAnchorY - boxH / 2;
                    // Arrow from snap dot to label box along perpendicular
                    svgContent += `<line x1="${st.px + pnx * 8}" y1="${st.py + pny * 8}" x2="${lblAnchorX - pnx * boxH * 0.5}" y2="${lblAnchorY - pny * boxH * 0.5}"
                        stroke="${snapColor}" stroke-width="1.5" stroke-dasharray="4,3" opacity="0.7" style="pointer-events:none"/>`;
                    svgContent += `<rect x="${boxX}" y="${boxY}" width="${boxW}" height="${boxH}" rx="5" fill="rgba(0,0,0,0.72)" stroke="${snapColor}" stroke-width="1" style="pointer-events:none"/>`;
                    svgContent += `<text x="${boxX + 7}" y="${boxY + 15}" font-size="12" fill="#4ade80" font-family="sans-serif" style="pointer-events:none">${lbl}</text>`;
                }
            }
        }
    }

    // No hitLayer ‚Äî geometric hit detection is used instead (see setupCanvasInteractions)
    svgContent += '</g>';
    svg.innerHTML = defs + svgContent;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Recursive branch drawer
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function drawChildren(children, lineStart, lineEnd, direction, color, depth, mainUX, mainUY) {
        if (!children || children.length === 0 || depth > 8) return;
        const depthScale = Math.max(0.35, 1 - (depth - 1) * 0.14);
        const blLen = (depth === 1 ? branchLen : subBranchLen) * depthScale;

        // Classic fishbone layout (matches reference):
        // depth=1 (off main bone)   ‚Üí HORIZONTAL left  ‚Üê
        // depth=2 (off depth-1)     ‚Üí DIAGONAL, parallel to main bone  ‚Üñ‚Üô
        // depth=3 (off depth-2)     ‚Üí HORIZONTAL left again
        const isHorizontal = (depth % 2 === 1);
        const pux = isHorizontal ? -1    : mainUX;
        const puy = isHorizontal ?  0    : mainUY;

        children.forEach((child, ci) => {
            const t = (ci + 1) / (children.length + 1);
            const rawAx = lineStart.x + (lineEnd.x - lineStart.x) * t;
            const rawAy = lineStart.y + (lineEnd.y - lineStart.y) * t;

            // Apply baseOffset so this branch can be dragged from its anchor
            const ax = rawAx + (child.baseOffsetX || 0);
            const ay = rawAy + (child.baseOffsetY || 0);

            // branchFlip mirrors the branch to the other side of the parent bone
            const bpux = child.branchFlip ? -pux : pux;
            const bpuy = child.branchFlip ? -puy : puy;

            // Child branch parallel to parent: same direction, length blLen from anchor
            const baseEndX = ax + bpux * blLen;
            const baseEndY = ay + bpuy * blLen;

            const endX = baseEndX + (child.offsetX || 0);
            const endY = baseEndY + (child.offsetY || 0);

            computedPositions.set(child.id, {
                baseX: baseEndX, baseY: baseEndY,
                anchorX: ax, anchorY: ay,
                rawAnchorX: rawAx, rawAnchorY: rawAy
            });

            // Visual: thin branch line
            const sw = Math.max(0.7, 2.2 - depth * 0.35);
            const op = Math.max(0.3, 0.75 - depth * 0.08);
            svgContent += `<line x1="${ax}" y1="${ay}" x2="${endX}" y2="${endY}"
                stroke="${color}" stroke-width="${sw}" opacity="${op}" stroke-linecap="round" pointer-events="none"/>`;
            renderedLines.push({ x1: ax, y1: ay, x2: endX, y2: endY, causeId: child.id });

            // Branch ROOT drag handle (hidden by default, hover shows it)
            const isBranchBaseDragged = svgDragState.active && svgDragState.causeId === child.id && svgDragState.dragMode === 'base';
            const hr3 = Math.max(4, 6 - depth);
            svgContent += `<circle cx="${ax}" cy="${ay}" r="${isBranchBaseDragged ? hr3+3 : hr3}"
                fill="${color}" stroke="white" stroke-width="1.5"
                data-cause-id="${child.id}" data-drag-mode="base"
                class="drag-handle-base"
                style="${isBranchBaseDragged ? 'opacity:1;cursor:grabbing' : ''}"/>`;

            // Branch TIP handle ‚Äî only visible while dragging
            const isBranchTipDragged = svgDragState.active && svgDragState.causeId === child.id && svgDragState.dragMode === 'tip';
            if (isBranchTipDragged) {
                const hr2 = Math.max(4, 7 - depth);
                svgContent += `<circle cx="${endX}" cy="${endY}" r="${hr2}"
                    fill="${color}" opacity="0.9" stroke="white" stroke-width="1"
                    style="pointer-events:none"/>`;
            }

            // Small arrow at anchor pointing along branch direction
            const arrowLen = 6;
            const ax2 = ax + bpux * arrowLen, ay2 = ay + bpuy * arrowLen;
            const pnx2 = -bpuy, pny2 = bpux; // perpendicular
            svgContent += `<polygon points="${ax},${ay} ${ax2 - pnx2*3},${ay2 - pny2*3} ${ax2 + pnx2*3},${ay2 + pny2*3}"
                fill="${color}" opacity="${op}" style="pointer-events:none"/>`;

            // Label: kutu geni≈üliƒüi dal uzunluƒüunu a≈ümasƒ±n
            const childSel = state.selectedCauseId === child.id;
            const fs = Math.max(8, baseFontSub - (depth - 1) * 1.5);
            // maxBoxW: derinliƒüe g√∂re k√º√ß√ºl√ºr VE bulunduƒüu dal uzunluƒüunun %80'ini ge√ßemez
            const maxBoxW = Math.min(
                Math.max(50, 100 - depth * 12),
                Math.round(blLen * 0.80)
            );
            const chPerLine = Math.max(6, Math.floor(maxBoxW / (fs * 0.58)));
            const words = child.name.split(' ');
            const lines = [];
            let cur = '';
            for (const w of words) {
                const test = cur ? cur + ' ' + w : w;
                if (test.length > chPerLine && cur) { lines.push(cur); cur = w; }
                else { cur = test; }
            }
            if (cur) lines.push(cur);
            const lineH = fs + 3;
            const tw = maxBoxW;
            const th = Math.max(18, lines.length * lineH + 8);

            let lcx, lcy;
            // T√ºm derinlikler: dal ucunun direction y√∂n√ºnde (√ºst kemik=yukarƒ±, alt=a≈üaƒüƒ±)
            lcx = endX;
            lcy = endY + direction * (th / 2 + 6);
            const tx = lcx - tw / 2;
            const ty = lcy - th / 2;

            const boxOp = childSel ? 0.3 : Math.max(0.06, 0.14 - depth * 0.02);
            const strokeW = childSel ? 2 : Math.max(0.5, 1.2 - depth * 0.2);
            const dash = depth > 2 ? ' stroke-dasharray="4,2"' : '';
            // tspan: first line offset from top of box with padding, then each line shifts down by lineH
            const pad = 4;
            const tspans = lines.map((ln, li) =>
                `<tspan x="${tx + tw/2}" dy="${li === 0 ? lineH - 1 : lineH}">${escapeHtml(ln)}</tspan>`
            ).join('');

            svgContent += `
                <g data-cause-id="${child.id}" style="cursor:grab">
                ${showSubBoxes ? `<rect x="${tx}" y="${ty}" width="${tw}" height="${th}" rx="${Math.max(3, 6 - depth)}"
                      fill="${color}" opacity="${boxOp}" stroke="${color}" stroke-width="${strokeW}"${dash}/>` : ''}
                <text x="${tx + tw/2}" y="${ty + pad}" text-anchor="middle"
                      fill="${color}" font-size="${fs}" font-weight="${depth <= 1 ? 600 : 400}"
                      style="pointer-events:none">${tspans}</text>
                </g>`;
            drawChildren(child.children,
                { x: ax, y: ay }, { x: endX, y: endY },
                direction, color, depth + 1, mainUX, mainUY);
        }); // end children.forEach
    } // end drawChildren
}

function countAllNodes(causes) {
    let n = 0;
    causes.forEach(c => { n += 1 + countAllNodes(c.children); });
    return n;
}

// ===== CANVAS INTERACTIONS =====
function setupCanvasInteractions() {
    const wrapper = document.getElementById('canvasWrapper');
    const svg = document.getElementById('canvasSvg');
    let dblClickTimer = null;

    // --- SVG: mousedown on cause group or line ---
    svg.addEventListener('mousedown', (e) => {
        e.preventDefault(); // always prevent browser text-selection / default drag
        // First try label/box delegation
        const causeEl = e.target.closest('[data-cause-id]');
        // Spine resize handle kontrol√º
        const spineHandle = e.target.closest('[data-drag-mode="spine-resize"]');
        if (spineHandle) {
            e.preventDefault(); e.stopPropagation();
            _preDragSnapshot = _snapshot();
            const als = state.autoLayoutSettings || {};
            const container = document.getElementById('canvasContainer');
            const currentSpine = (als.spineLength && als.spineLength > 0)
                ? als.spineLength
                : (container.clientWidth - 80 - 140);
            svgDragState.active     = true;
            svgDragState.causeId    = null;
            svgDragState.dragMode   = 'spine-resize';
            svgDragState.startMouseX = e.clientX;
            svgDragState.startMouseY = e.clientY;
            svgDragState.startOffsetX = currentSpine; // spine uzunluƒüu ba≈ülangƒ±√ß deƒüeri
            svgDragState.moved      = false;
            wrapper.style.cursor    = 'ew-resize';
            wrapper.classList.add('dragging');
            return;
        }
        if (causeEl) {
            e.stopPropagation();
            const causeId = parseInt(causeEl.dataset.causeId);
            const cause = findCause(causeId);
            if (!cause) return;
            const dragMode = causeEl.dataset.dragMode || 'tip';
            _preDragSnapshot = _snapshot(); // undo/redo i√ßin drag √∂ncesi snapshot
            svgDragState.active = true;
            svgDragState.causeId = causeId;
            svgDragState.dragMode = dragMode;
            svgDragState.startMouseX = e.clientX;
            svgDragState.startMouseY = e.clientY;
            svgDragState.startOffsetX = dragMode === 'base' ? (cause.baseOffsetX || 0) : (cause.offsetX || 0);
            svgDragState.startOffsetY = dragMode === 'base' ? (cause.baseOffsetY || 0) : (cause.offsetY || 0);
            svgDragState.moved = false;
            wrapper.style.cursor = 'grabbing';
            wrapper.classList.add('dragging');
            return;
        }

        // Geometric hit-test against rendered line segments
        const rect = svg.getBoundingClientRect();
        const svgX = (e.clientX - rect.left - state.panX) / state.zoom;
        const svgY = (e.clientY - rect.top  - state.panY) / state.zoom;
        const HIT_DIST = 14;
        let bestId = null, bestDist = Infinity;
        for (const seg of renderedLines) {
            const dx = seg.x2 - seg.x1, dy = seg.y2 - seg.y1;
            const lenSq = dx * dx + dy * dy;
            const t = lenSq > 0 ? Math.max(0, Math.min(1, ((svgX - seg.x1) * dx + (svgY - seg.y1) * dy) / lenSq)) : 0;
            const nearX = seg.x1 + t * dx, nearY = seg.y1 + t * dy;
            const dist = Math.sqrt((svgX - nearX) ** 2 + (svgY - nearY) ** 2);
            if (dist < HIT_DIST && dist < bestDist) { bestDist = dist; bestId = seg.causeId; }
        }
        if (bestId !== null) {
            const cause = findCause(bestId);
            if (cause) {
                e.stopPropagation();
                e.preventDefault();
                _preDragSnapshot = _snapshot(); // undo/redo i√ßin drag √∂ncesi snapshot
                svgDragState.active = true;
                svgDragState.causeId = bestId;
                svgDragState.startMouseX = e.clientX;
                svgDragState.startMouseY = e.clientY;
                svgDragState.startOffsetX = cause.offsetX || 0;
                svgDragState.startOffsetY = cause.offsetY || 0;
                svgDragState.moved = false;
                wrapper.style.cursor = 'grabbing';
                wrapper.classList.add('dragging');
                return;
            }
        }
        // Nothing hit ‚Äî let event bubble to wrapper for panning
    });

    // --- SVG: context menu ---
    svg.addEventListener('contextmenu', (e) => {
        const causeEl = e.target.closest('[data-cause-id]');
        if (causeEl) {
            showContextMenu(e, parseInt(causeEl.dataset.causeId));
        }
    });

    // --- SVG: double-click to edit ---
    svg.addEventListener('dblclick', (e) => {
        const causeEl = e.target.closest('[data-cause-id]');
        if (causeEl) {
            e.stopPropagation();
            e.preventDefault();
            openModal('edit', parseInt(causeEl.dataset.causeId));
        }
    });

    // --- Pan on empty canvas OR geometric line-drag detection ---
    wrapper.addEventListener('mousedown', (e) => {
        if (svgDragState.active) return;

        // If a labelled SVG element was hit, the svg listener above already handled it
        if (e.target.closest('[data-cause-id]')) return;

        // ‚îÄ‚îÄ Geometric hit-test against rendered line segments ‚îÄ‚îÄ
        // Convert screen coords ‚Üí SVG group coords (accounting for pan+zoom)
        const svgEl = document.getElementById('canvasSvg');
        const rect = svgEl.getBoundingClientRect();
        const svgX = (e.clientX - rect.left - state.panX) / state.zoom;
        const svgY = (e.clientY - rect.top  - state.panY) / state.zoom;

        const HIT_DIST = 14; // pixels in SVG coordinate space
        let bestId = null, bestDist = Infinity;

        for (const seg of renderedLines) {
            const dx = seg.x2 - seg.x1;
            const dy = seg.y2 - seg.y1;
            const lenSq = dx * dx + dy * dy;
            let t = 0;
            if (lenSq > 0) {
                t = ((svgX - seg.x1) * dx + (svgY - seg.y1) * dy) / lenSq;
                t = Math.max(0, Math.min(1, t));
            }
            const nearX = seg.x1 + t * dx;
            const nearY = seg.y1 + t * dy;
            const dist = Math.sqrt((svgX - nearX) ** 2 + (svgY - nearY) ** 2);
            if (dist < HIT_DIST && dist < bestDist) {
                bestDist = dist;
                bestId = seg.causeId;
            }
        }

        if (bestId !== null) {
            const cause = findCause(bestId);
            if (cause) {
                e.stopPropagation();
                e.preventDefault();
                svgDragState.active = true;
                svgDragState.causeId = bestId;
                svgDragState.dragMode = 'base'; // line body ‚Üí move whole bone; anchor snaps
                svgDragState.startMouseX = e.clientX;
                svgDragState.startMouseY = e.clientY;
                svgDragState.startOffsetX = cause.baseOffsetX || 0;
                svgDragState.startOffsetY = cause.baseOffsetY || 0;
                svgDragState.moved = false;
                wrapper.style.cursor = 'grabbing';
                return;
            }
        }

        // Nothing hit ‚Äî start panning
        state.isPanning = true;
        state.panStartX = e.clientX - state.panX;
        state.panStartY = e.clientY - state.panY;
        wrapper.classList.add('dragging');
    });

    // --- Mousemove: drag box / line or pan ---
    document.addEventListener('mousemove', (e) => {
        if (svgDragState.active) {
            const dx = (e.clientX - svgDragState.startMouseX) / state.zoom;
            const dy = (e.clientY - svgDragState.startMouseY) / state.zoom;
            if (!svgDragState.moved && (Math.abs(dx) > svgDragState.DRAG_THRESHOLD || Math.abs(dy) > svgDragState.DRAG_THRESHOLD)) {
                svgDragState.moved = true;
            }
            // ‚îÄ‚îÄ SPINE RESIZE ‚îÄ‚îÄ
            if (svgDragState.dragMode === 'spine-resize' && svgDragState.moved) {
                // Kuyruk sola √ßekilince spine uzar (dx negatif ‚Üí spineLength artar)
                const newLen = Math.max(200, Math.round(svgDragState.startOffsetX - dx));
                if (!state.autoLayoutSettings) state.autoLayoutSettings = {};
                state.autoLayoutSettings.spineLength = newLen;
                renderFishbone();
                return;
            }
            if (svgDragState.moved) {
                const cause = findCause(svgDragState.causeId);
                if (cause) {
                    let newOffX = svgDragState.startOffsetX + dx;
                    let newOffY = svgDragState.startOffsetY + dy;

                    if (svgDragState.dragMode === 'base') {
                        // Base drag with snap from ROOT/ANCHOR endpoint
                        if (svgDragState.snapEnabled) {
                            const pos = computedPositions.get(svgDragState.causeId);
                            if (pos) {
                                // Raw new anchor position (boneBaseX + newOffX)
                                const rawAnchorX = pos.anchorX - (cause.baseOffsetX || 0) + newOffX;
                                const rawAnchorY = pos.anchorY - (cause.baseOffsetY || 0) + newOffY;
                                const snapResult = findNearestLineSnap(rawAnchorX, rawAnchorY, svgDragState.causeId, svgDragState.SNAP_CROSS_DISTANCE);
                                if (snapResult) {
                                    const tlVX = snapResult.lx2 - snapResult.lx1;
                                    const tlVY = snapResult.ly2 - snapResult.ly1;
                                    const tlLen = Math.sqrt(tlVX * tlVX + tlVY * tlVY);
                                    if (tlLen > 0) {
                                        const tux = tlVX / tlLen, tuy = tlVY / tlLen;
                                        const proj = (rawAnchorX - snapResult.lx1) * tux + (rawAnchorY - snapResult.ly1) * tuy;
                                        const clampedProj = Math.max(-30, Math.min(tlLen + 30, proj));
                                        const slidePx = snapResult.lx1 + clampedProj * tux;
                                        const slidePy = snapResult.ly1 + clampedProj * tuy;
                                        newOffX = slidePx - (pos.anchorX - (cause.baseOffsetX || 0));
                                        newOffY = slidePy - (pos.anchorY - (cause.baseOffsetY || 0));
                                        svgDragState._snapTarget = {
                                            px: slidePx, py: slidePy,
                                            dist: snapResult.dist,
                                            snapCauseId: snapResult.causeId,
                                            lx1: snapResult.lx1, ly1: snapResult.ly1,
                                            lx2: snapResult.lx2, ly2: snapResult.ly2
                                        };
                                    } else { svgDragState._snapTarget = null; }
                                } else { svgDragState._snapTarget = null; }
                            } else { svgDragState._snapTarget = null; }
                        } else { svgDragState._snapTarget = null; }
                        cause.baseOffsetX = newOffX;
                        cause.baseOffsetY = newOffY;
                    } else {
                        // Tip drag with snap
                        if (svgDragState.snapEnabled) {
                            const pos = computedPositions.get(svgDragState.causeId);
                            if (pos) {
                                const rawEndX = pos.baseX + newOffX;
                                const rawEndY = pos.baseY + newOffY;
                                const snapResult = findNearestLineSnap(rawEndX, rawEndY, svgDragState.causeId, svgDragState.SNAP_CROSS_DISTANCE);
                                if (snapResult) {
                                    const tlVX = snapResult.lx2 - snapResult.lx1;
                                    const tlVY = snapResult.ly2 - snapResult.ly1;
                                    const tlLen = Math.sqrt(tlVX * tlVX + tlVY * tlVY);
                                    if (tlLen > 0) {
                                        const tux = tlVX / tlLen, tuy = tlVY / tlLen;
                                        const proj = (rawEndX - snapResult.lx1) * tux + (rawEndY - snapResult.ly1) * tuy;
                                        const clampedProj = Math.max(-30, Math.min(tlLen + 30, proj));
                                        const slidePx = snapResult.lx1 + clampedProj * tux;
                                        const slidePy = snapResult.ly1 + clampedProj * tuy;
                                        newOffX = slidePx - pos.baseX;
                                        newOffY = slidePy - pos.baseY;
                                        svgDragState._snapTarget = {
                                            px: slidePx, py: slidePy,
                                            dist: snapResult.dist,
                                            snapCauseId: snapResult.causeId,
                                            lx1: snapResult.lx1, ly1: snapResult.ly1,
                                            lx2: snapResult.lx2, ly2: snapResult.ly2
                                        };
                                    } else { svgDragState._snapTarget = null; }
                                } else { svgDragState._snapTarget = null; }
                            }
                        } else { svgDragState._snapTarget = null; }
                        cause.offsetX = newOffX;
                        cause.offsetY = newOffY;
                    } // end tip drag
                    renderFishbone();
                }
            }
            return;
        }
        if (state.isPanning) {
            state.panX = e.clientX - state.panStartX;
            state.panY = e.clientY - state.panStartY;
            renderFishbone();
        }
    });

    // --- Mouseup ---
    document.addEventListener('mouseup', (e) => {
        if (svgDragState.active) {
            // ‚îÄ‚îÄ SPINE RESIZE mouseup ‚îÄ‚îÄ
            if (svgDragState.dragMode === 'spine-resize') {
                if (svgDragState.moved) {
                    _commitDragHistory();
                    autoSave();
                } else {
                    _preDragSnapshot = null;
                }
                svgDragState.active   = false;
                svgDragState.causeId  = null;
                svgDragState.dragMode = 'tip';
                svgDragState.moved    = false;
                wrapper.style.cursor  = 'grab';
                wrapper.classList.remove('dragging');
                return;
            }
            if (!svgDragState.moved) {
                _preDragSnapshot = null; // click only ‚Äî don't save history
                state.selectedCauseId = svgDragState.causeId;
                render();
            } else {
                _commitDragHistory(); // drag bitti ‚Äî pre-drag snapshot'ƒ± undo stack'e at
                // Reparent if snapped onto another cause's line (both tip and base drag)
                const st = svgDragState._snapTarget;
                if (st && st.snapCauseId === null) {
                    // Snapped to SPINE ‚Üí keep X position where dragged, force Y to spine, natural tip angle
                    const draggedId = svgDragState.causeId;
                    const dragged = findCause(draggedId);
                    if (dragged) {
                        const parent = findParent(draggedId);
                        if (parent) {
                            // Was a sub-cause ‚Üí promote to main cause
                            removeCause(draggedId);
                            // Keep current baseOffsetX so it stays at the dragged X,
                            // but anchor must sit ON the spine (baseOffsetY=0)
                            dragged.baseOffsetY = 0;
                            dragged.offsetX = 0; dragged.offsetY = 0;
                            state.causes.push(dragged);
                            showNotification(`"${dragged.name}" ana nedene y√ºkseltildi`, 'success');
                        } else {
                            // Already main cause ‚Üí snap anchor X to where dragged, Y=spine, tip angle natural
                            dragged.baseOffsetY = 0;
                            dragged.offsetX = 0; dragged.offsetY = 0;
                            showNotification(`"${dragged.name}" spine'a hizalandƒ±`, 'info');
                        }
                        state.selectedCauseId = draggedId;
                        autoSave(); render();
                        svgDragState.active = false; svgDragState.causeId = null;
                        svgDragState.dragMode = 'tip'; svgDragState.moved = false;
                        svgDragState._snapTarget = null;
                        wrapper.style.cursor = 'grab'; wrapper.classList.remove('dragging');
                        return;
                    }
                } else if (st && st.snapCauseId != null) {
                    const draggedId = svgDragState.causeId;
                    const targetId  = st.snapCauseId;
                    if (draggedId !== targetId) {
                        const dragged = findCause(draggedId);
                        const target  = findCause(targetId);
                        // Make sure target is not a descendant of dragged
                        function isDescendant(ancestor, id) {
                            return ancestor.children.some(c => c.id === id || isDescendant(c, id));
                        }
                        if (dragged && target && !isDescendant(dragged, targetId)) {
                            // Remove dragged from its current parent
                            removeCause(draggedId);
                            // Reset offsets
                            dragged.offsetX = 0; dragged.offsetY = 0;
                            dragged.baseOffsetX = 0; dragged.baseOffsetY = 0;
                            // Add as child of target
                            target.children.push(dragged);
                            target.collapsed = false;
                            state.selectedCauseId = draggedId;
                            autoSave();
                            render();
                            showNotification(`"${dragged.name}" ‚Üí "${target.name}" altƒ±na ta≈üƒ±ndƒ±`, 'success');
                            svgDragState.active = false;
                            svgDragState.causeId = null;
                            svgDragState.dragMode = 'tip';
                            svgDragState.moved = false;
                            svgDragState._snapTarget = null;
                            wrapper.style.cursor = 'grab';
                            wrapper.classList.remove('dragging');
                            return;
                        }
                    }
                }
                autoSave();
            }
            svgDragState.active = false;
            svgDragState.causeId = null;
            svgDragState.dragMode = 'tip';
            svgDragState.moved = false;
            svgDragState._snapTarget = null;
            wrapper.style.cursor = 'grab';
            wrapper.classList.remove('dragging');
            renderFishbone();
            return;
        }
        state.isPanning = false;
        wrapper.classList.remove('dragging');
    });

    // --- Zoom ---
    wrapper.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.05 : 0.05;
        state.zoom = Math.max(0.3, Math.min(3, state.zoom + delta));
        document.getElementById('zoomLevel').textContent = Math.round(state.zoom * 100) + '%';
        renderFishbone();
    });
}

// ===== SNAP TOGGLE =====
function toggleSnap() {
    svgDragState.snapEnabled = !svgDragState.snapEnabled;
    document.getElementById('snapToggle').classList.toggle('active', svgDragState.snapEnabled);
    showNotification(svgDragState.snapEnabled ? 'Snap a√ßƒ±k' : 'Snap kapalƒ±', 'success');
}

function toggleSubBoxes() {
    if (!state.autoLayoutSettings) state.autoLayoutSettings = {};
    const current = state.autoLayoutSettings.showSubBoxes !== false;
    state.autoLayoutSettings.showSubBoxes = !current;
    document.getElementById('subBoxToggle').classList.toggle('active', !current);
    renderFishbone();
    autoSave();
    showNotification(!current ? 'Alt kutular g√∂steriliyor' : 'Alt kutular gizlendi', 'success');
}

// ===== CROSS-LINE SNAP: find nearest line segment =====
// Returns { px, py, dist, lx1, ly1, lx2, ly2 } or null
function findNearestLineSnap(ptX, ptY, excludeCauseId, maxDist) {
    let best = null;
    let bestDist = maxDist;

    // Collect IDs to exclude: the cause itself + all its descendants
    const excludeIds = new Set();
    excludeIds.add(excludeCauseId);
    function addDescendants(cause) {
        if (!cause) return;
        cause.children.forEach(c => {
            excludeIds.add(c.id);
            addDescendants(c);
        });
    }
    addDescendants(findCause(excludeCauseId));

    for (const seg of renderedLines) {
        // Skip lines belonging to the dragged cause or its descendants
        if (excludeIds.has(seg.causeId)) continue;

        // Closest point on segment (x1,y1)-(x2,y2) to (ptX,ptY)
        const dx = seg.x2 - seg.x1;
        const dy = seg.y2 - seg.y1;
        const lenSq = dx * dx + dy * dy;
        if (lenSq < 1) continue;

        let t = ((ptX - seg.x1) * dx + (ptY - seg.y1) * dy) / lenSq;
        t = Math.max(0, Math.min(1, t));

        const closestX = seg.x1 + t * dx;
        const closestY = seg.y1 + t * dy;
        const dist = Math.sqrt((ptX - closestX) ** 2 + (ptY - closestY) ** 2);

        if (dist < bestDist) {
            bestDist = dist;
            best = {
                px: closestX, py: closestY,
                dist: dist,
                causeId: seg.causeId,
                lx1: seg.x1, ly1: seg.y1,
                lx2: seg.x2, ly2: seg.y2
            };
        }
    }

    // Also snap to line ENDPOINTS specifically (stronger magnet at endpoints)
    const endpointSnapDist = maxDist * 0.7;
    for (const seg of renderedLines) {
        if (excludeIds.has(seg.causeId)) continue;
        // Check endpoint 1
        let d1 = Math.sqrt((ptX - seg.x1) ** 2 + (ptY - seg.y1) ** 2);
        if (d1 < endpointSnapDist && d1 < bestDist) {
            bestDist = d1;
            best = { px: seg.x1, py: seg.y1, dist: d1, causeId: seg.causeId, lx1: seg.x1, ly1: seg.y1, lx2: seg.x2, ly2: seg.y2 };
        }
        // Check endpoint 2
        let d2 = Math.sqrt((ptX - seg.x2) ** 2 + (ptY - seg.y2) ** 2);
        if (d2 < endpointSnapDist && d2 < bestDist) {
            bestDist = d2;
            best = { px: seg.x2, py: seg.y2, dist: d2, causeId: seg.causeId, lx1: seg.x1, ly1: seg.y1, lx2: seg.x2, ly2: seg.y2 };
        }
    }

    return best;
}

// ===== AUTO-LAYOUT ENGINE =====
function autoLayout() {
    const container = document.getElementById('canvasContainer');
    let W = container.clientWidth  || container.offsetWidth  || window.innerWidth  - 340;
    let H = container.clientHeight || container.offsetHeight || window.innerHeight - 56;
    const numMain = state.causes.length;

    if (numMain === 0) {
        showNotification('√ñnce neden ekleyin', 'error');
        return;
    }
    pushHistory(); // autoLayout √∂ncesi undo noktasƒ±

    // ‚îÄ‚îÄ 1. T√ºm offsetleri sƒ±fƒ±rla (side'a dokunma ‚Äî kullanƒ±cƒ± kararƒ± korunur) ‚îÄ‚îÄ
    function clearAllOffsets(causes) {
        causes.forEach(c => {
            c.offsetX = 0; c.offsetY = 0;
            c.baseOffsetX = 0; c.baseOffsetY = 0;
            clearAllOffsets(c.children);
        });
    }
    // side atanmamƒ±≈ü ana kemiklere ≈üimdi sƒ±radaki konuma g√∂re ata
    state.causes.forEach((c, i) => {
        if (c.side === undefined || c.side === null) {
            c.side = i % 2 === 0 ? 'top' : 'bottom';
        }
    });
    clearAllOffsets(state.causes);

    // ‚îÄ‚îÄ 2. Metrikler ‚îÄ‚îÄ
    const totalNodes = countAllNodes(state.causes);
    const maxDepth   = state.causes.reduce((m, c) => Math.max(m, countBranchDepthMax(c)), 0);

    function maxNameLen(causes) {
        let mx = 4;
        causes.forEach(c => {
            mx = Math.max(mx, Math.min(18, (c.name || '').length));
            mx = Math.max(mx, Math.min(14, (c.label || '').length));
            mx = Math.max(mx, maxNameLen(c.children));
        });
        return mx;
    }
    const maxLenChar = maxNameLen(state.causes);

    // ‚îÄ‚îÄ 3. Font boyutu: yoƒüunluk bazlƒ± ‚îÄ‚îÄ
    const fontByDensity = totalNodes <= 8  ? 15
                        : totalNodes <= 15 ? 14
                        : totalNodes <= 25 ? 13
                        : totalNodes <= 40 ? 12 : 11;
    const fontSizeMain = Math.max(10, Math.min(fontByDensity, 15));
    const fontSizeSub  = Math.max(9, fontSizeMain - 1);
    const sin60 = Math.sin(60 * Math.PI / 180);  // ‚âà 0.866
    const cos60 = Math.cos(60 * Math.PI / 180);  // ‚âà 0.500

    // ‚îÄ‚îÄ Ger√ßek render form√ºl√ºyle e≈üle≈üen label y√ºkseklik hesabƒ± ‚îÄ‚îÄ
    function labelHForBoxW(name, fs, boxW) {
        const chPL = Math.max(6, Math.floor(boxW / (fs * 0.58)));
        const words = (name || '').split(' ');
        let lines = 0, cur = '';
        for (const w of words) {
            const test = cur ? cur + ' ' + w : w;
            if (test.length > chPL && cur) { lines++; cur = w; } else cur = test;
        }
        if (cur) lines++;
        return Math.max(18, lines * (fontSizeSub + 3) + 8);
    }

    // ‚îÄ‚îÄ 4. boneLength ve branchLen beraber hesapla ‚îÄ‚îÄ
    // drawChildren'daki ger√ßek maxBoxW: min(max(50, 100-depth*12), round(blLen*0.80))
    // depth=1: min(88, round(branchLen*0.80))
    // depth=2: min(76, round(subBranchLen*0.80))
    //
    // depth=2 label'larƒ±: tip'ten perpendicular y√∂nde yerle≈üir.
    // Perpendicular direccion ‚âà (sin60, -cos60) yani saƒüa+yukarƒ±.
    // Yatay kayma ‚âà perpOff * sin60 ‚âà (labelH/2+8)*0.866
    // Bu kayma depth=1 tip label ile √ßakƒ±≈üƒ±r eƒüer branchLen yeterince uzun deƒüilse.
    //
    // Kural: branchLen ‚â• d2_horizOffset + d1_label_halfW + d2_label_halfW + gap
    //        d2_horizOffset = s*branchLen - subBranchLen*cos60  (en saƒü torun i√ßin s‚âà1)
    //        Sadele≈ütirince: branchLen ‚â• subBranchLen*cos60 + d1W/2 + d2W/2 + 20
    //
    // Iteratif √ß√∂z√ºm: 3 ge√ßi≈ü

    // subBranch oranƒ± sabiti (branchLen*ratio = subBranchLen)
    const SUB_RATIO = 0.38;

    // depth=2 label perpendicular offset ‚âà tipik label y√ºksekliƒüi/2 + 8
    // Varsayƒ±lan max th_d2 ‚âà 40px (2 satƒ±r) ‚Üí perpOff ‚âà 28; sin60*28 ‚âà 24px
    const PERP_OFF_EST = 28;  // tipik perpOff = th/2+8

    function solveLayout(boneGuess) {
        // Render ger√ßek maxBoxW: depth=1 ‚Üí min(88, round(branchL*0.80))
        // B√ºy√ºk branchLen i√ßin d1W = 88 (sat√ºre); biz en k√∂t√º duruma g√∂re planlarƒ±z.
        const d1W = 88;   // saturated max
        const d2W = 76;   // saturated max for depth=2

        // boneLength: her main cause'un depth=1 √ßocuklarƒ± dikey alan hesabƒ±
        // boneLen * sin60 ‚â• sum(labelH_i + gap)  ‚Üí  boneLen ‚â• sum/sin60
        let maxTotalH = 0;
        state.causes.forEach(mainCause => {
            if (mainCause.children.length === 0) return;
            let total = 0;
            mainCause.children.forEach(c => {
                total += labelHForBoxW(c.name, fontSizeSub, d1W) + 12;
            });
            if (total > maxTotalH) maxTotalH = total;
        });
        const boneLenByChildren = maxTotalH > 0 ? Math.ceil(maxTotalH / sin60) : 120;
        const rawBL = H * 0.40 - (maxDepth - 1) * 8;
        const boneL = Math.min(700, Math.max(boneLenByChildren, rawBL, 120));

        // branchLen: boneLength'in sabit oranƒ± ‚Äî torun sayƒ±sƒ±na g√∂re hafif√ße b√ºy√ºr
        const maxGrandN = state.causes.reduce((m, mc) =>
            mc.children.reduce((m2, c) => Math.max(m2, c.children.length), m), 0);
        // Temel oran 0.45; her ek torun i√ßin k√º√ß√ºk artƒ±≈ü (maks 0.65)
        const branchRatio = Math.min(0.65, 0.45 + maxGrandN * 0.03);
        const branchL = Math.max(Math.round(boneL * branchRatio), 80);
        const subBranchL = Math.max(Math.round(branchL * SUB_RATIO), 45);

        return { boneL, branchL, subBranchL };
    }

    const r1 = solveLayout(200);
    const r2 = solveLayout(r1.boneL);
    const r3 = solveLayout(r2.boneL);
    const boneLength    = r3.boneL;
    const branchLen     = r3.branchL;
    const subBranchLen  = r3.subBranchL;

    // ‚îÄ‚îÄ 7. Spine slot geni≈üliƒüi: ana neden label + branch soldan uzanƒ±m ‚îÄ‚îÄ
    const charW   = fontSizeMain * 0.64;
    const mainMaxChar = state.causes.reduce((m, c) => Math.max(m, Math.min(18, (c.name || '').length)), 6);
    const mainLblW    = mainMaxChar * charW + 24;
    // Her slot en az branchLen kadar geni≈ü olmalƒ±:
    // Yatay dal tamamen kendi slotuna sƒ±ƒüsƒ±n, kom≈üu kemiklerle √ßakƒ±≈ümasƒ±n.
    // + ana neden label geni≈üliƒüi + g√ºvenlik payƒ±
    const minSlotG    = Math.max(120, mainLblW + 24, branchLen + 60);
    const neededSpineG  = minSlotG * (numMain + 1);
    const naturalSpineG = W - 80 - 140;
    const spineG = Math.max(naturalSpineG, neededSpineG);

    // ‚îÄ‚îÄ 8. Zoom: geni≈ülik VE y√ºkseklik kƒ±sƒ±tlarƒ±nƒ± kar≈üƒ±la ‚îÄ‚îÄ
    const boneH  = boneLength * Math.sin(60 * Math.PI / 180);
    const halfH  = H / 2 - 60;
    const zoomW  = naturalSpineG / spineG;
    const zoomH  = boneH > halfH ? halfH / boneH : 1.0;
    const fitZoom = Math.max(0.25, Math.min(1.0, Math.min(zoomW, zoomH)));

    // ‚îÄ‚îÄ 9. Ayarlarƒ± kaydet ‚îÄ‚îÄ
    state.autoLayoutSettings = {
        fontSizeMain,
        fontSizeSub,
        boneLength,
        branchLength: branchLen,
        subBranchLength: subBranchLen,
        spineLength: spineG
    };

    state.zoom = fitZoom;
    state.panX = 0;

    // panY: spine g-koordinatƒ± H/2'de, scale sonrasƒ± i√ßerik dikey ortada olsun.
    // Ekran koord: screenY = panY + gY * fitZoom
    // √úst kemik tipi: (H/2 - boneH) * fitZoom + panY  ‚Üí topMargin ~70px
    // Alt kemik tipi: (H/2 + boneH) * fitZoom + panY  ‚Üí H - botMargin ~20px
    // Merkez: panY = (topMargin + H - botMargin)/2 - H/2 * fitZoom
    const _topMargin = 70;   // √ºst etiket i√ßin
    const _botMargin = 20;
    state.panY = Math.round((_topMargin + H - _botMargin) / 2 - (H / 2) * fitZoom);
    document.getElementById('zoomLevel').textContent = Math.round(fitZoom * 100) + '%';

    render();
    autoSave();
    showNotification(
        `Otomatik yerle≈ütirildi ‚Äî ${numMain} dal, slot: ${Math.round(minSlotG)}px, kemik: ${Math.round(boneLength)}px, yazƒ±: ${fontSizeMain}px`,
        'success'
    );
}

function countBranchDepthMax(cause) {
    if (cause.children.length === 0) return 1;
    let maxD = 0;
    cause.children.forEach(c => { maxD = Math.max(maxD, countBranchDepthMax(c)); });
    return 1 + maxD;
}

function selectCause(id) {
    state.selectedCauseId = id;
    render();
}

function zoomIn() {
    state.zoom = Math.min(3, state.zoom + 0.1);
    document.getElementById('zoomLevel').textContent = Math.round(state.zoom * 100) + '%';
    renderFishbone();
}

function zoomOut() {
    state.zoom = Math.max(0.3, state.zoom - 0.1);
    document.getElementById('zoomLevel').textContent = Math.round(state.zoom * 100) + '%';
    renderFishbone();
}

function resetView() {
    state.zoom = 1;
    state.panX = 0;
    state.panY = 0;
    resetAllPositions();
    document.getElementById('zoomLevel').textContent = '100%';
    renderFishbone();
}

// ===== KEYBOARD =====
function setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
        // Close modal on Escape
        if (e.key === 'Escape') {
            const modal = document.getElementById('modalOverlay');
            if (modal.classList.contains('active')) {
                closeModal();
                return;
            }
            hideContextMenu();
        }

        // Enter to save modal
        if (e.key === 'Enter' && !e.shiftKey) {
            const modal = document.getElementById('modalOverlay');
            if (modal.classList.contains('active')) {
                saveModal();
                return;
            }
        }

        // Delete selected cause
        if (e.key === 'Delete' && state.selectedCauseId) {
            const modal = document.getElementById('modalOverlay');
            if (!modal.classList.contains('active')) {
                contextTargetId = state.selectedCauseId;
                contextAction('delete');
            }
        }

        // Ctrl+Z geri al
        if (e.ctrlKey && !e.shiftKey && e.key === 'z') {
            e.preventDefault();
            undo();
            return;
        }
        // Ctrl+Y veya Ctrl+Shift+Z yeniden yap
        if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
            e.preventDefault();
            redo();
            return;
        }

        // Ctrl+S to save
        if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
            saveDiagram();
        }

        // Ctrl+N new
        if (e.ctrlKey && e.key === 'n') {
            e.preventDefault();
            addMainCause();
        }
    });
}

// ===== UTILITIES =====
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function truncateText(text, maxLen) {
    return text.length > maxLen ? text.substring(0, maxLen) + '...' : text;
}

// ===== TEMPLATES =====
const BUILTIN_TEMPLATES = [
    // ‚îÄ‚îÄ KALƒ∞TE: 6M √úretim ‚îÄ‚îÄ
    {
        id: 'bt_6m', icon: 'üè≠', title: '6M √úretim',
        desc: '√úretim s√ºre√ßlerinde klasik 6M k√∂k neden analizi',
        tags: ['√úretim', '6M', 'Kalite'],
        problem: 'Kalite Problemi',
        causes: [
            { name: 'Makine',   color: '#3b82f6', children: [{ name: 'Bakƒ±msƒ±zlƒ±k',       color: '#3b82f6', children: [] }, { name: 'Arƒ±za/Titre≈üim',    color: '#3b82f6', children: [] }, { name: 'Kalibrasyon hatasƒ±', color: '#3b82f6', children: [] }] },
            { name: 'Malzeme',  color: '#8b5cf6', children: [{ name: 'Ham madde kalitesi', color: '#8b5cf6', children: [] }, { name: 'Yanlƒ±≈ü malzeme',    color: '#8b5cf6', children: [] }, { name: 'Depolama sorunu',   color: '#8b5cf6', children: [] }] },
            { name: 'Metot',    color: '#ec4899', children: [{ name: 'Standart dƒ±≈üƒ± uygulama', color: '#ec4899', children: [] }, { name: 'Prosed√ºr eksikliƒüi', color: '#ec4899', children: [] }] },
            { name: 'ƒ∞nsan',    color: '#f59e0b', children: [{ name: 'Eƒüitim eksikliƒüi',   color: '#f59e0b', children: [] }, { name: 'Yorgunluk',          color: '#f59e0b', children: [] }, { name: 'Dikkatsizlik',       color: '#f59e0b', children: [] }] },
            { name: '√ñl√ß√ºm',    color: '#10b981', children: [{ name: '√ñl√ß√ºm cihazƒ± hatasƒ±', color: '#10b981', children: [] }, { name: 'Kalibrasyon eksik',  color: '#10b981', children: [] }] },
            { name: '√áevre',    color: '#ef4444', children: [{ name: 'Nem / Sƒ±caklƒ±k',     color: '#ef4444', children: [] }, { name: 'Toz / Titre≈üim',    color: '#ef4444', children: [] }] }
        ]
    },
    // ‚îÄ‚îÄ KALƒ∞TE: √ñl√ß√ºsel Problem ‚îÄ‚îÄ
    {
        id: 'bt_dim', icon: 'üìê', title: '√ñl√ß√ºsel Problem',
        desc: 'Boyut, tolerans ve √∂l√ß√ºm dƒ±≈üƒ± √ºr√ºnlerin k√∂k neden analizi',
        tags: ['√ñl√ß√º', 'Tolerans', 'Boyut', 'Kalite'],
        problem: '√ñl√ß√º Dƒ±≈üƒ± √úr√ºn',
        causes: [
            { name: '√ñl√ß√ºm Sistemi',  color: '#3b82f6', children: [
                { name: 'Kumpas/Mikrometre hatasƒ±', color: '#3b82f6', children: [] },
                { name: '√ñl√ß√ºm tekniƒüi yanlƒ±≈ülƒ±ƒüƒ±', color: '#3b82f6', children: [] },
                { name: 'Kalibrasyon s√ºresi dolmu≈ü', color: '#3b82f6', children: [] }
            ]},
            { name: 'Makine/Takƒ±m',   color: '#8b5cf6', children: [
                { name: 'Takƒ±m a≈üƒ±nmasƒ±',    color: '#8b5cf6', children: [] },
                { name: 'Baƒülama hatasƒ±',    color: '#8b5cf6', children: [] },
                { name: 'Termal genle≈üme',   color: '#8b5cf6', children: [] },
                { name: 'Titre≈üim',          color: '#8b5cf6', children: [] }
            ]},
            { name: 'Malzeme',        color: '#ec4899', children: [
                { name: 'Hammadde boyut toleransƒ±', color: '#ec4899', children: [] },
                { name: 'Isƒ±l i≈ülem deƒüi≈üimi',      color: '#ec4899', children: [] }
            ]},
            { name: 'Metot',          color: '#f59e0b', children: [
                { name: 'Yanlƒ±≈ü fikst√ºr',       color: '#f59e0b', children: [] },
                { name: 'Program/CNC hatasƒ±',   color: '#f59e0b', children: [] },
                { name: 'ƒ∞≈ülem sƒ±rasƒ± hatasƒ±',  color: '#f59e0b', children: [] }
            ]},
            { name: 'ƒ∞nsan',          color: '#10b981', children: [
                { name: 'Operat√∂r hatasƒ±',   color: '#10b981', children: [] },
                { name: 'Yorgunluk',         color: '#10b981', children: [] }
            ]},
            { name: '√áevre',          color: '#ef4444', children: [
                { name: 'Sƒ±caklƒ±k deƒüi≈üimi', color: '#ef4444', children: [] },
                { name: 'Nem etkisi',         color: '#ef4444', children: [] }
            ]}
        ]
    },
    // ‚îÄ‚îÄ KALƒ∞TE: G√∂rsel Problem ‚îÄ‚îÄ
    {
        id: 'bt_visual', icon: 'üëÅÔ∏è', title: 'G√∂rsel Problem',
        desc: 'Y√ºzey, renk, ≈üekil bozukluƒüu gibi g√∂rsel hatalarƒ±n k√∂k neden analizi',
        tags: ['G√∂rsel', 'Y√ºzey', 'Renk', 'Kalite'],
        problem: 'G√∂rsel / Kozmetik Hata',
        causes: [
            { name: 'Y√ºzey ƒ∞≈ülemi',   color: '#3b82f6', children: [
                { name: 'Boyama parametresi', color: '#3b82f6', children: [] },
                { name: 'Kaplama kalƒ±nlƒ±ƒüƒ±',  color: '#3b82f6', children: [] },
                { name: 'Kurutma s√ºresi',     color: '#3b82f6', children: [] },
                { name: 'Y√ºzey hazƒ±rlƒ±ƒüƒ±',    color: '#3b82f6', children: [] }
            ]},
            { name: 'Malzeme',        color: '#8b5cf6', children: [
                { name: 'Boya/Vernik kalitesi',  color: '#8b5cf6', children: [] },
                { name: 'Hammadde y√ºzeyi',        color: '#8b5cf6', children: [] },
                { name: 'Renk uyumsuzluƒüu (lot)', color: '#8b5cf6', children: [] }
            ]},
            { name: 'Ortam',          color: '#ec4899', children: [
                { name: 'Toz/Kirlilik',         color: '#ec4899', children: [] },
                { name: 'Nem/Sƒ±caklƒ±k',         color: '#ec4899', children: [] },
                { name: 'UV ƒ±≈üƒ±k maruziyeti',    color: '#ec4899', children: [] }
            ]},
            { name: 'Ekipman',        color: '#f59e0b', children: [
                { name: 'Nozul tƒ±kanƒ±klƒ±ƒüƒ±',  color: '#f59e0b', children: [] },
                { name: 'Bant/Kalƒ±p izleri',  color: '#f59e0b', children: [] }
            ]},
            { name: 'ƒ∞nsan',          color: '#10b981', children: [
                { name: 'Elle√ßleme hasarƒ±',  color: '#10b981', children: [] },
                { name: 'Muayene kriteri',   color: '#10b981', children: [] }
            ]},
            { name: 'Ta≈üƒ±ma/Ambalaj', color: '#ef4444', children: [
                { name: '√áizik/Darbe',       color: '#ef4444', children: [] },
                { name: 'Yetersiz koruma',   color: '#ef4444', children: [] }
            ]}
        ]
    },
    // ‚îÄ‚îÄ KALƒ∞TE: Etiket/Ambalaj Problemi ‚îÄ‚îÄ
    {
        id: 'bt_label', icon: 'üè∑Ô∏è', title: 'Etiket & Ambalaj',
        desc: 'Yanlƒ±≈ü/eksik etiket ve ambalaj hatalarƒ±nƒ±n k√∂k neden analizi',
        tags: ['Etiket', 'Ambalaj', 'Baskƒ±', 'Kalite'],
        problem: 'Etiket / Ambalaj Hatasƒ±',
        causes: [
            { name: 'Tasarƒ±m',        color: '#3b82f6', children: [
                { name: 'Yanlƒ±≈ü versiyon',     color: '#3b82f6', children: [] },
                { name: 'Veri eksikliƒüi',      color: '#3b82f6', children: [] },
                { name: 'Barkod/QR hatasƒ±',    color: '#3b82f6', children: [] }
            ]},
            { name: 'Baskƒ± S√ºreci',   color: '#8b5cf6', children: [
                { name: 'M√ºrekkep sorunu',     color: '#8b5cf6', children: [] },
                { name: 'Baskƒ± kaymasƒ±',       color: '#8b5cf6', children: [] },
                { name: 'Renk uyumsuzluƒüu',   color: '#8b5cf6', children: [] }
            ]},
            { name: 'Malzeme',        color: '#ec4899', children: [
                { name: 'Yapƒ±≈ütƒ±rƒ±cƒ± tutmama', color: '#ec4899', children: [] },
                { name: 'Etiket malzeme hatasƒ±', color: '#ec4899', children: [] }
            ]},
            { name: 'S√ºre√ß',          color: '#f59e0b', children: [
                { name: 'Yanlƒ±≈ü √ºr√ºne uygulama', color: '#f59e0b', children: [] },
                { name: 'G√∂zden ge√ßirme eksikliƒüi', color: '#f59e0b', children: [] },
                { name: 'Lot karƒ±≈üƒ±mƒ±',            color: '#f59e0b', children: [] }
            ]},
            { name: 'ƒ∞nsan',          color: '#10b981', children: [
                { name: 'Operat√∂r hatasƒ±',   color: '#10b981', children: [] },
                { name: 'Eƒüitim eksikliƒüi',  color: '#10b981', children: [] }
            ]},
            { name: 'Makine',         color: '#ef4444', children: [
                { name: 'Uygulama makinesi ayarƒ±', color: '#ef4444', children: [] },
                { name: 'Sens√∂r/okuyucu hatasƒ±',   color: '#ef4444', children: [] }
            ]}
        ]
    },
    // ‚îÄ‚îÄ KALƒ∞TE: Montaj/Fonksiyonel Problem ‚îÄ‚îÄ
    {
        id: 'bt_assem', icon: 'üî©', title: 'Montaj / Fonksiyonel',
        desc: '√úr√ºn√ºn √ßalƒ±≈ümamasƒ± veya montaj hatalarƒ±nƒ±n k√∂k neden analizi',
        tags: ['Montaj', 'Fonksiyon', '√úretim'],
        problem: 'Montaj / Fonksiyon Hatasƒ±',
        causes: [
            { name: 'Tasarƒ±m',         color: '#3b82f6', children: [
                { name: 'Tolerans uyumsuzluƒüu', color: '#3b82f6', children: [] },
                { name: 'DFM uygulanmamƒ±≈ü',     color: '#3b82f6', children: [] }
            ]},
            { name: 'Par√ßa Kalitesi',  color: '#8b5cf6', children: [
                { name: 'Satƒ±n alƒ±nan par√ßa hatasƒ±', color: '#8b5cf6', children: [] },
                { name: 'Dahili par√ßa hatasƒ±',       color: '#8b5cf6', children: [] }
            ]},
            { name: 'Montaj S√ºreci',   color: '#ec4899', children: [
                { name: 'Yanlƒ±≈ü tork',          color: '#ec4899', children: [] },
                { name: 'Eksik par√ßa',          color: '#ec4899', children: [] },
                { name: 'Montaj sƒ±rasƒ± hatasƒ±', color: '#ec4899', children: [] }
            ]},
            { name: 'Takƒ±m/Ekipman',   color: '#f59e0b', children: [
                { name: 'Tornavida/Anahtar kalibrasyonu', color: '#f59e0b', children: [] },
                { name: 'Fikst√ºr hatasƒ±',                 color: '#f59e0b', children: [] }
            ]},
            { name: 'ƒ∞nsan',           color: '#10b981', children: [
                { name: 'Yorgunluk',         color: '#10b981', children: [] },
                { name: 'Eƒüitim eksikliƒüi',  color: '#10b981', children: [] }
            ]},
            { name: 'Muayene',         color: '#ef4444', children: [
                { name: 'Muayene atlama',     color: '#ef4444', children: [] },
                { name: 'Kriter belirsizliƒüi', color: '#ef4444', children: [] }
            ]}
        ]
    },
    // ‚îÄ‚îÄ KALƒ∞TE: M√º≈üteri ≈ûikayeti ‚îÄ‚îÄ
    {
        id: 'bt_complaint', icon: 'üò§', title: 'M√º≈üteri ≈ûikayeti',
        desc: 'M√º≈üteri ≈üikayetlerinin sistematik k√∂k neden analizi (8D uyumlu)',
        tags: ['M√º≈üteri', '8D', '≈ûikayet', 'Kalite'],
        problem: 'M√º≈üteri ≈ûikayeti',
        causes: [
            { name: '√úr√ºn Kalitesi',   color: '#3b82f6', children: [
                { name: 'Performans sorunu',  color: '#3b82f6', children: [] },
                { name: 'G√ºvenilirlik',       color: '#3b82f6', children: [] },
                { name: 'G√∂r√ºn√ºm hatasƒ±',     color: '#3b82f6', children: [] }
            ]},
            { name: 'S√ºre√ß',           color: '#8b5cf6', children: [
                { name: '√úretim hatasƒ±',      color: '#8b5cf6', children: [] },
                { name: 'Muayene yetersizliƒüi', color: '#8b5cf6', children: [] }
            ]},
            { name: 'Teslimat',        color: '#ec4899', children: [
                { name: 'Gecikme',          color: '#ec4899', children: [] },
                { name: 'Yanlƒ±≈ü √ºr√ºn',      color: '#ec4899', children: [] },
                { name: 'Hasar',            color: '#ec4899', children: [] }
            ]},
            { name: 'ƒ∞leti≈üim',        color: '#f59e0b', children: [
                { name: 'Yanlƒ±≈ü bilgi',     color: '#f59e0b', children: [] },
                { name: 'Yanƒ±t gecikmesi', color: '#f59e0b', children: [] }
            ]},
            { name: 'Satƒ±≈ü Sonrasƒ±',   color: '#10b981', children: [
                { name: 'Servis yetersizliƒüi', color: '#10b981', children: [] },
                { name: 'Yedek par√ßa sorunu',  color: '#10b981', children: [] }
            ]},
            { name: 'Ambalaj',         color: '#ef4444', children: [
                { name: 'Hasar',              color: '#ef4444', children: [] },
                { name: 'Yanlƒ±≈ü etiket',      color: '#ef4444', children: [] }
            ]}
        ]
    },
    // ‚îÄ‚îÄ KALƒ∞TE: FMEA Tarzƒ± ‚îÄ‚îÄ
    {
        id: 'bt_fmea', icon: '‚ö†Ô∏è', title: 'FMEA / Risk',
        desc: 'Hata modu ve etki analizi tarzƒ± k√∂k neden ≈üablonu',
        tags: ['FMEA', 'Risk', 'Hata Modu'],
        problem: 'Potansiyel Hata Modu',
        causes: [
            { name: 'Tasarƒ±m Hatasƒ±',     color: '#3b82f6', children: [
                { name: 'Malzeme se√ßimi',      color: '#3b82f6', children: [] },
                { name: 'Tolerans belirleme',  color: '#3b82f6', children: [] },
                { name: 'G√º√ßlendirme eksikliƒüi', color: '#3b82f6', children: [] }
            ]},
            { name: 'S√ºre√ß Hatasƒ±',       color: '#8b5cf6', children: [
                { name: 'Kontrol planƒ± eksik',  color: '#8b5cf6', children: [] },
                { name: 'Hata √∂nleme (Poka-yoke) yok', color: '#8b5cf6', children: [] }
            ]},
            { name: '√áevre / Kullanƒ±m',   color: '#ec4899', children: [
                { name: 'A≈üƒ±rƒ± y√ºk',         color: '#ec4899', children: [] },
                { name: 'Yanlƒ±≈ü kullanƒ±m',   color: '#ec4899', children: [] }
            ]},
            { name: 'Tedarik√ßi',          color: '#f59e0b', children: [
                { name: 'Satƒ±n alƒ±nan par√ßa', color: '#f59e0b', children: [] },
                { name: 'Denetim eksikliƒüi',  color: '#f59e0b', children: [] }
            ]},
            { name: 'Kontrol',            color: '#10b981', children: [
                { name: 'Muayene atlama',     color: '#10b981', children: [] },
                { name: '√ñl√ß√ºm belirsizliƒüi', color: '#10b981', children: [] }
            ]}
        ]
    },
    // ‚îÄ‚îÄ YAZILIM GELƒ∞≈ûTƒ∞RME ‚îÄ‚îÄ
    {
        id: 'bt_sw', icon: 'üíª', title: 'Yazƒ±lƒ±m Geli≈ütirme',
        desc: 'Yazƒ±lƒ±m projelerinde hata ve gecikme analizleri',
        tags: ['Yazƒ±lƒ±m', 'IT', 'Proje'],
        problem: 'Yazƒ±lƒ±m Hatasƒ± / Gecikme',
        causes: [
            { name: 'Kod',           color: '#3b82f6', children: [{ name: 'Teknik bor√ß',       color: '#3b82f6', children: [] }, { name: 'Test eksikliƒüi',  color: '#3b82f6', children: [] }] },
            { name: 'Gereksinim',    color: '#8b5cf6', children: [{ name: 'Belirsiz kapsam',   color: '#8b5cf6', children: [] }, { name: 'Sƒ±k deƒüi≈üim',     color: '#8b5cf6', children: [] }] },
            { name: 'S√ºre√ß',         color: '#ec4899', children: [{ name: 'Yetersiz planlama', color: '#ec4899', children: [] }, { name: 'CI/CD eksikliƒüi', color: '#ec4899', children: [] }] },
            { name: 'ƒ∞nsan',         color: '#f59e0b', children: [{ name: 'Deneyim eksikliƒüi', color: '#f59e0b', children: [] }, { name: 'ƒ∞leti≈üim kopukluƒüu', color: '#f59e0b', children: [] }] },
            { name: 'Altyapƒ±',       color: '#10b981', children: [{ name: 'Sunucu sorunlarƒ±',  color: '#10b981', children: [] }, { name: 'Baƒüƒ±mlƒ±lƒ±k sorunlarƒ±', color: '#10b981', children: [] }] },
            { name: 'Test',          color: '#ef4444', children: [{ name: 'Yetersiz kapsam',   color: '#ef4444', children: [] }, { name: 'Otomasyon eksikliƒüi', color: '#ef4444', children: [] }] }
        ]
    },
    // ‚îÄ‚îÄ SAƒûLIK Hƒ∞ZMETLERƒ∞ ‚îÄ‚îÄ
    {
        id: 'bt_health', icon: 'üè•', title: 'Saƒülƒ±k Hizmetleri',
        desc: 'Hasta g√ºvenliƒüi ve saƒülƒ±k s√ºre√ßleri k√∂k neden analizi',
        tags: ['Saƒülƒ±k', 'Hastane', 'Risk'],
        problem: 'Hasta G√ºvenliƒüi Olayƒ±',
        causes: [
            { name: 'ƒ∞nsan',      color: '#3b82f6', children: [{ name: 'Yorgunluk',            color: '#3b82f6', children: [] }, { name: 'Eƒüitim eksikliƒüi', color: '#3b82f6', children: [] }] },
            { name: 'Ekipman',    color: '#8b5cf6', children: [{ name: 'Arƒ±za',                color: '#8b5cf6', children: [] }, { name: 'Kalibrasyon hatasƒ±', color: '#8b5cf6', children: [] }] },
            { name: 'Protokol',   color: '#ec4899', children: [{ name: 'Prosed√ºr ihlali',      color: '#ec4899', children: [] }, { name: 'Dok√ºmantasyon eksik', color: '#ec4899', children: [] }] },
            { name: 'ƒ∞la√ß',       color: '#f59e0b', children: [{ name: 'Doz hatasƒ±',           color: '#f59e0b', children: [] }, { name: 'Etiketleme sorunu', color: '#f59e0b', children: [] }] },
            { name: 'Ortam',      color: '#10b981', children: [{ name: 'Hijyen',               color: '#10b981', children: [] }, { name: 'Dikkat daƒüƒ±nƒ±klƒ±ƒüƒ±', color: '#10b981', children: [] }] }
        ]
    },
    // ‚îÄ‚îÄ TEDARƒ∞K Zƒ∞NCƒ∞Rƒ∞ ‚îÄ‚îÄ
    {
        id: 'bt_supply', icon: 'üì¶', title: 'Tedarik Zinciri',
        desc: 'Lojistik ve tedarik s√ºre√ßlerinde gecikme ve aksama analizleri',
        tags: ['Lojistik', 'Tedarik', 'Depo'],
        problem: 'Teslimat Gecikmesi',
        causes: [
            { name: 'Tedarik√ßi',  color: '#3b82f6', children: [{ name: 'Kapasite yetersizliƒüi', color: '#3b82f6', children: [] }, { name: 'Kalite sorunu', color: '#3b82f6', children: [] }] },
            { name: 'Ta≈üƒ±ma',     color: '#8b5cf6', children: [{ name: 'Ara√ß arƒ±zasƒ±',          color: '#8b5cf6', children: [] }, { name: 'Rota sorunu',  color: '#8b5cf6', children: [] }] },
            { name: 'Depo',       color: '#ec4899', children: [{ name: 'Stok hatasƒ±',           color: '#ec4899', children: [] }, { name: 'Yer yetersizliƒüi', color: '#ec4899', children: [] }] },
            { name: 'Planlama',   color: '#f59e0b', children: [{ name: 'Talep tahmini hatasƒ±', color: '#f59e0b', children: [] }] },
            { name: 'G√ºmr√ºk',     color: '#10b981', children: [{ name: 'Belge eksikliƒüi',      color: '#10b981', children: [] }, { name: 'Denetim gecikmesi', color: '#10b981', children: [] }] }
        ]
    }
];

let _tmplActiveTab = 'builtin';

function openTemplates() {
    document.getElementById('tmplOverlay').classList.add('active');
    renderTmplBuiltin();
    renderTmplSaved();
}
function closeTemplates() {
    document.getElementById('tmplOverlay').classList.remove('active');
}
function switchTmplTab(tab) {
    _tmplActiveTab = tab;
    document.getElementById('tmplBuiltinPanel').style.display = tab === 'builtin' ? '' : 'none';
    document.getElementById('tmplSavedPanel').style.display  = tab === 'saved'   ? '' : 'none';
    document.getElementById('tabBuiltin').classList.toggle('active', tab === 'builtin');
    document.getElementById('tabSaved').classList.toggle('active',   tab === 'saved');
    if (tab === 'saved') renderTmplSaved();
}

function renderTmplBuiltin() {
    const grid = document.getElementById('tmplBuiltinGrid');
    grid.innerHTML = BUILTIN_TEMPLATES.map(t => `
        <div class="tmpl-card" onclick="loadTemplate('${t.id}')">
            <div class="tmpl-card-icon">${t.icon}</div>
            <div class="tmpl-card-title">${t.title}</div>
            <div class="tmpl-card-desc">${t.desc}</div>
            <div class="tmpl-card-tags">${t.tags.map(tg => `<span class="tmpl-tag">${tg}</span>`).join('')}</div>
        </div>
    `).join('');
}

function renderTmplSaved() {
    const saved = getSavedTemplates();
    const grid = document.getElementById('tmplSavedGrid');
    if (saved.length === 0) {
        grid.innerHTML = '<div class="tmpl-empty" style="grid-column:1/-1">Hen√ºz kaydedilmi≈ü ≈üablon yok.<br><small>Header\'daki ‚òÖ <strong>≈ûablon Kaydet</strong> butonuyla mevcut diyagramƒ± kaydedin.</small></div>';
        return;
    }
    function countAll(causes) { return causes.reduce((s, c) => s + 1 + countAll(c.children || []), 0); }
    grid.innerHTML = saved.map((t, i) => {
        const mainCount  = (t.causes || []).length;
        const totalCount = countAll(t.causes || []);
        const subCount   = totalCount - mainCount;
        const date = new Date(t.savedAt).toLocaleDateString('tr-TR', { day:'numeric', month:'short', year:'numeric' });
        return `
        <div class="tmpl-card" onclick="loadSavedTemplate(${i})">
            <button class="tmpl-card-delete" onclick="deleteSavedTemplate(event,${i})" title="≈ûablonu sil">‚úï</button>
            <div class="tmpl-card-icon">‚òÖ</div>
            <div class="tmpl-card-title">${escapeHtml(t.name)}</div>
            <div class="tmpl-card-desc">${escapeHtml(t.problem || 'Problem')}</div>
            <div class="tmpl-card-tags">
                <span class="tmpl-tag">${mainCount} ana neden</span>
                ${subCount > 0 ? `<span class="tmpl-tag">${subCount} alt neden</span>` : ''}
                <span class="tmpl-tag">${date}</span>
            </div>
        </div>`;
    }).join('');
}

function getSavedTemplates() {
    try { return JSON.parse(localStorage.getItem('fishbone_templates') || '[]'); } catch { return []; }
}
function saveSavedTemplates(arr) {
    localStorage.setItem('fishbone_templates', JSON.stringify(arr));
}

function saveCurrentAsTemplate() {
    const nameEl = document.getElementById('tmplSaveName');
    const name = nameEl.value.trim();
    if (!name) { nameEl.focus(); showNotification('≈ûablon adƒ± girin', 'error'); return; }
    _doSaveTemplate(name);
    nameEl.value = '';
    renderTmplSaved();
}

function openQuickSaveTemplate() {
    if (!state.causes || state.causes.length === 0) {
        showNotification('Kaydedilecek diyagram yok ‚Äî √∂nce neden ekleyin', 'error'); return;
    }
    const el = document.getElementById('qsaveNameInput');
    el.value = (state.problem && state.problem !== 'Ana Problem') ? state.problem : '';
    document.getElementById('qsaveOverlay').classList.add('active');
    setTimeout(() => { el.select(); el.focus(); }, 60);
}

function closeQuickSaveTemplate() {
    document.getElementById('qsaveOverlay').classList.remove('active');
}

function confirmQuickSave() {
    const nameEl = document.getElementById('qsaveNameInput');
    const name = nameEl.value.trim();
    if (!name) { nameEl.focus(); showNotification('≈ûablon adƒ± girin', 'error'); return; }
    _doSaveTemplate(name);
    closeQuickSaveTemplate();
    renderTmplSaved(); // update panel if open
}

function _doSaveTemplate(name) {
    const saved = getSavedTemplates();
    saved.unshift({
        name,
        problem: state.problem || '',
        causes: JSON.parse(JSON.stringify(state.causes)),
        savedAt: Date.now()
    });
    saveSavedTemplates(saved);
    showNotification(`"${name}" ≈üablonu kaydedildi`, 'success');
}

function loadTemplate(id) {
    const t = BUILTIN_TEMPLATES.find(x => x.id === id);
    if (!t) return;
    if (!confirm(`"${t.title}" ≈üablonu y√ºklensin mi? Mevcut diyagram sƒ±fƒ±rlanacak.`)) return;
    const nextId = () => Date.now() + Math.floor(Math.random() * 1000);
    function assignIds(causes) {
        return causes.map(c => ({
            ...c,
            id: nextId(),
            offsetX: 0, offsetY: 0, baseOffsetX: 0, baseOffsetY: 0,
            collapsed: false,
            children: assignIds(c.children || [])
        }));
    }
    state.problem = t.problem;
    state.causes  = assignIds(t.causes);
    state.selectedCauseId = null;
    document.getElementById('problemTitle').value = t.problem;
    autoSave(); render();
    closeTemplates();
    showNotification(`"${t.title}" ≈üablonu y√ºklendi`, 'success');
}

function loadSavedTemplate(i) {
    const saved = getSavedTemplates();
    const t = saved[i];
    if (!t) return;
    if (!confirm(`"${t.name}" ≈üablonu y√ºklensin mi? Mevcut diyagram sƒ±fƒ±rlanacak.`)) return;
    const nextId = () => Date.now() + Math.floor(Math.random() * 1000);
    function assignIds(causes) {
        return causes.map(c => ({
            ...c,
            id: nextId(),
            offsetX: 0, offsetY: 0, baseOffsetX: 0, baseOffsetY: 0,
            collapsed: false,
            children: assignIds(c.children || [])
        }));
    }
    state.problem = t.problem || '';
    state.causes  = assignIds(t.causes || []);
    state.selectedCauseId = null;
    document.getElementById('problemTitle').value = state.problem;
    autoSave(); render();
    closeTemplates();
    showNotification(`"${t.name}" ≈üablonu y√ºklendi`, 'success');
}

function deleteSavedTemplate(e, i) {
    e.stopPropagation();
    const saved = getSavedTemplates();
    const name = saved[i]?.name;
    if (!confirm(`"${name}" ≈üablonu silinsin mi?`)) return;
    saved.splice(i, 1);
    saveSavedTemplates(saved);
    renderTmplSaved();
    showNotification(`≈ûablon silindi`, 'info');
}

function showNotification(message, type = 'success') {
    const el = document.getElementById('notification');
    el.textContent = message;
    el.className = 'notification visible ' + type;
    setTimeout(() => el.classList.remove('visible'), 2500);
}

// ===== MAIN RENDER =====
function render() {
    renderTree();
    renderFishbone();
}

// ===== ADD MAIN CAUSE =====
function addMainCause() {
    openModal('add');
}

// ===== SAVE / LOAD / EXPORT =====
function autoSave() {
    localStorage.setItem('fishbone_state', JSON.stringify(state));
    // √ñzellik 3: Ak≈üiyon √∂zeti ‚Äî Uygunsuzluk Analizi'ne geri besleme
    if (state.problem && state.problem !== 'Ana Problem') {
        try {
            const aksiyonlar = JSON.parse(localStorage.getItem('fishbone_aksiyonlar') || '{}');
            aksiyonlar[state.problem] = state.actionPlan ? state.actionPlan.rows.length : 0;
            localStorage.setItem('fishbone_aksiyonlar', JSON.stringify(aksiyonlar));
        } catch(e) {}
    }
}

function saveDiagram() {
    const data = JSON.stringify(state, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const filename = (state.problem || 'fishbone').replace(/[^a-zA-Z0-9ƒü√º≈üƒ±√∂√ßƒû√ú≈ûƒ∞√ñ√á ]/g, '_');
    a.download = `${filename}_analiz.json`;
    a.click();
    URL.revokeObjectURL(url);
    showNotification('Diyagram kaydedildi!', 'success');
}

function loadDiagram() {
    document.getElementById('fileInput').click();
}

function handleFileLoad(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const parsed = JSON.parse(e.target.result);
            Object.assign(state, parsed);
            document.getElementById('problemTitle').value = state.problem;
            document.getElementById('problemDesc').value = state.problemDesc || '';
            render();
            autoSave();
            showNotification('Diyagram y√ºklendi!', 'success');
        } catch(err) {
            showNotification('Dosya okunamadƒ±!', 'error');
        }
    };
    reader.readAsText(file);
    event.target.value = '';
}

function resetDiagram() {
    if (state.causes.length > 0 && !confirm('Mevcut diyagram silinecek. Devam edilsin mi?')) return;
    state.causes = [];
    state.problem = 'Ana Problem';
    state.problemDesc = '';
    state.selectedCauseId = null;
    state.nextId = 1;
    state.zoom = 1;
    state.panX = 0;
    state.panY = 0;
    document.getElementById('problemTitle').value = state.problem;
    document.getElementById('problemDesc').value = '';
    render();
    autoSave();
    showNotification('Yeni diyagram olu≈üturuldu', 'success');
}

function exportAsPNG() {
    // Read live CSS variable values so they survive SVG serialization
    const rs = getComputedStyle(document.documentElement);
    const CSS = {
        bg      : rs.getPropertyValue('--bg-primary').trim()    || '#0f172a',
        bgSec   : rs.getPropertyValue('--bg-secondary').trim()  || '#1e293b',
        text    : rs.getPropertyValue('--text-primary').trim()  || '#f1f5f9',
        textSec : rs.getPropertyValue('--text-secondary').trim()|| '#94a3b8',
        accent  : rs.getPropertyValue('--accent').trim()        || '#3b82f6',
        spine   : rs.getPropertyValue('--spine-color').trim()   || '#f1f5f9',
        border  : rs.getPropertyValue('--border').trim()        || '#334155',
    };

    const origSvg  = document.getElementById('canvasSvg');
    const panGroup = origSvg.querySelector('g[transform]');

    // ‚îÄ‚îÄ 1. Measure actual content bounds in natural (zoom=1, pan=0) coordinates ‚îÄ‚îÄ
    const savedTransform = panGroup ? panGroup.getAttribute('transform') : null;
    if (panGroup) panGroup.setAttribute('transform', 'translate(0,0) scale(1)');

    let bbox;
    try { bbox = panGroup ? panGroup.getBBox() : origSvg.getBBox(); }
    catch(e) { bbox = { x: 0, y: 0, width: 1200, height: 700 }; }

    if (panGroup && savedTransform) panGroup.setAttribute('transform', savedTransform);

    // Ensure bbox has meaningful size (getBBox sometimes returns 0 for invisible elements)
    if (bbox.width < 10 || bbox.height < 10) {
        bbox = { x: 0, y: 0, width: 1200, height: 700 };
    }

    const PAD   = 60;   // padding around content
    const SCALE = 2.5;  // output pixel density multiplier

    const vbX = bbox.x - PAD;
    const vbY = bbox.y - PAD;
    const vbW = bbox.width  + PAD * 2;
    const vbH = bbox.height + PAD * 2;

    const exportW = Math.round(vbW * SCALE);
    const exportH = Math.round(vbH * SCALE);

    // ‚îÄ‚îÄ 2. Clone SVG, strip pan/zoom, set full-diagram viewBox ‚îÄ‚îÄ
    const svgClone = origSvg.cloneNode(true);
    const cloneGroup = svgClone.querySelector('g[transform]');
    if (cloneGroup) cloneGroup.setAttribute('transform', 'translate(0,0) scale(1)');

    // Remove interactive-only elements from clone
    svgClone.querySelectorAll('[class*="drag-handle"], [data-drag-mode="spine-resize"]')
            .forEach(el => el.remove());

    svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    svgClone.removeAttribute('style');
    svgClone.setAttribute('width',   exportW);
    svgClone.setAttribute('height',  exportH);
    svgClone.setAttribute('viewBox', `${vbX} ${vbY} ${vbW} ${vbH}`);

    // ‚îÄ‚îÄ 3. Inline all CSS variables ‚îÄ‚îÄ
    let svgStr = new XMLSerializer().serializeToString(svgClone);
    svgStr = svgStr
        .replace(/var\(--spine-color\)/g,   CSS.spine)
        .replace(/var\(--accent\)/g,        CSS.accent)
        .replace(/var\(--text-primary\)/g,  CSS.text)
        .replace(/var\(--text-secondary\)/g,CSS.textSec)
        .replace(/var\(--bg-primary\)/g,    CSS.bg)
        .replace(/var\(--bg-secondary\)/g,  CSS.bgSec)
        .replace(/var\(--border\)/g,        CSS.border)
        .replace(/var\(--[^)]+\)/g,         '#888');

    // Inject background rect immediately inside <svg>
    svgStr = svgStr.replace(/(<svg\b[^>]*>)/, `$1<rect x="${vbX}" y="${vbY}" width="${vbW}" height="${vbH}" fill="${CSS.bg}"/>`);

    const filename = `${(state.problem || 'fishbone').replace(/[^a-zA-Z0-9ƒü√º≈üƒ±√∂√ßƒû√ú≈ûƒ∞√ñ√á ]/g, '_')}_analiz.png`;
    _renderSvgToPng(svgStr, exportW, exportH, CSS.bg, filename);
}

function _renderSvgToPng(svgStr, w, h, bgColor, filename) {
    const canvas = document.createElement('canvas');
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, w, h);

    function doDownload() {
        const a = document.createElement('a');
        a.download = filename;
        a.href = canvas.toDataURL('image/png');
        document.body.appendChild(a);
        a.click();
        setTimeout(() => document.body.removeChild(a), 150);
        showNotification('PNG indirildi ‚úì', 'success');
    }

    // Primary: Blob URL (fastest, best quality)
    const blob = new Blob([svgStr], { type: 'image/svg+xml;charset=utf-8' });
    const blobUrl = URL.createObjectURL(blob);
    const imgA = new Image();
    imgA.onload = () => {
        ctx.drawImage(imgA, 0, 0, w, h);
        URL.revokeObjectURL(blobUrl);
        doDownload();
    };
    imgA.onerror = () => {
        URL.revokeObjectURL(blobUrl);
        // Fallback: base64 data URL (avoids potential blob-URL restrictions)
        try {
            const b64 = btoa(unescape(encodeURIComponent(svgStr)));
            const imgB = new Image();
            imgB.onload = () => { ctx.drawImage(imgB, 0, 0, w, h); doDownload(); };
            imgB.onerror = () => showNotification('PNG olu≈üturulamadƒ±', 'error');
            imgB.src = 'data:image/svg+xml;base64,' + b64;
        } catch(e) { showNotification('PNG olu≈üturulamadƒ±: ' + e.message, 'error'); }
    };
    imgA.src = blobUrl;
}


// Handle window resize
window.addEventListener('resize', () => renderFishbone());

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  AI ASƒ∞STAN Wƒ∞ZARD
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const AI_FORMAT_HINT = '\n\nüìå Format:\n‚Ä¢ <b>Neden1, Neden2</b> ‚Äî d√ºz liste\n‚Ä¢ <b>Neden &gt; Alt1, Alt2</b> ‚Äî alt nedenler\n‚Ä¢ <b>Neden &gt; Alt &gt; Alt-alt</b> ‚Äî 3. seviye\nHer satƒ±r ayrƒ± bir neden grubu olarak i≈ülenir. Ge√ßmek i√ßin <b>ge√ß</b> yazƒ±n.';

const AI_STEPS = [
    { key: 'problem',   question: 'üëã Merhaba! Analiz etmek istediƒüiniz problemi kƒ±saca yazƒ±n.\n\n√ñrnek: "√úretim hattƒ±nda √ºr√ºn kalite redleri artƒ±yor"', category: null },
    { key: 'Makine',    question: '‚öôÔ∏è **Makine / Ekipman**' + AI_FORMAT_HINT, category: 'Makine' },
    { key: 'Malzeme',   question: 'üì¶ **Malzeme / Hammadde**' + AI_FORMAT_HINT, category: 'Malzeme' },
    { key: 'Metot',     question: 'üìã **Metot / Prosed√ºr**' + AI_FORMAT_HINT, category: 'Metot' },
    { key: 'ƒ∞nsan',     question: 'üë§ **ƒ∞nsan / Operat√∂r**' + AI_FORMAT_HINT, category: 'ƒ∞nsan' },
    { key: '√áevre',     question: 'üå°Ô∏è **√áevre / Ortam**' + AI_FORMAT_HINT, category: '√áevre' },
    { key: '√ñl√ß√ºm',    question: 'üìê **√ñl√ß√ºm / Kontrol**' + AI_FORMAT_HINT, category: '√ñl√ß√ºm' },
    { key: 'done',      question: null, category: null },
];

let _aiStep = 0;
let _aiProblem = '';
let _aiCauses = {}; // { 'Makine': [{name, children:[{name, children:[]}]}, ...] }

function switchView(view) {
    const fv = document.getElementById('fishboneView');
    const av = document.getElementById('actionPlanView');
    const aiv = document.getElementById('aiAssistView');
    const tf = document.getElementById('tabFishbone');
    const ta = document.getElementById('tabAction');
    const tai = document.getElementById('tabAI');

    fv.style.display = 'none';
    av.style.display = 'none';
    aiv.style.display = 'none';
    [tf, ta, tai].forEach(t => t && t.classList.remove('active'));

    if (view === 'action') {
        av.style.display = 'flex';
        ta.classList.add('active');
        initActionPlan();
        renderActionPlan();
        renderMethodsGrid();
    } else if (view === 'ai') {
        aiv.style.display = 'flex';
        tai.classList.add('active');
        if (document.getElementById('aiMessages').children.length === 0) aiReset();
    } else {
        fv.style.display = '';
        tf.classList.add('active');
    }
}

// Template chip templates: { label, template, placeholder start/end in template }
const AI_CHIP_TEMPLATES = {
    'D√ºz':   { tpl: 'Neden1, Neden2',        sel: [0, 6]  },
    'Alt':   { tpl: 'Neden > Alt1, Alt2',     sel: [0, 5]  },
    'AltAlt':{ tpl: 'Neden > Alt > Alt-alt',  sel: [0, 5]  },
};

function aiInsertChip(type) {
    const ta = document.getElementById('aiUserInput');
    if (!ta) return;
    const { tpl, sel } = AI_CHIP_TEMPLATES[type];
    const cur = ta.value;
    const prefix = cur.length > 0 && !cur.endsWith('\n') ? '\n' : '';
    const insertAt = cur.length + prefix.length;
    ta.value = cur + prefix + tpl;
    ta.focus();
    ta.setSelectionRange(insertAt + sel[0], insertAt + sel[1]);
}

function aiReset() {
    _aiStep = 0;
    _aiProblem = '';
    _aiCauses = {};
    document.getElementById('aiMessages').innerHTML = '';
    document.getElementById('aiUserInput').value = '';
    document.getElementById('aiUserInput').disabled = false;
    document.getElementById('aiSendBtn').disabled = false;
    document.getElementById('aiGenerateBtn').disabled = true;
    aiRenderPreview();
    aiAsk(0);
}

function aiAsk(stepIdx) {
    const step = AI_STEPS[stepIdx];
    if (!step || !step.question) return;
    const lines = step.question.split('\n').map(l => {
        l = l.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        return l;
    }).join('<br>');
    aiAddMessage('bot', lines);
    // ≈ûablonlarƒ± sadece kategori adƒ±mlarƒ±nda g√∂ster
    const bar = document.querySelector('.ai-template-bar');
    if (bar) bar.style.display = step.category ? 'flex' : 'none';
}

function aiAddMessage(role, html) {
    const wrap = document.getElementById('aiMessages');
    const div = document.createElement('div');
    div.className = 'ai-msg ' + role;
    div.innerHTML = `
        <div class="ai-msg-avatar">${role === 'bot' ? 'ü§ñ' : 'üë§'}</div>
        <div class="ai-msg-bubble">${html}</div>`;
    wrap.appendChild(div);
    wrap.scrollTop = wrap.scrollHeight;
}

// Parses hierarchical cause text into tree: [{name, children:[{name, children:[]}]}]
// Format: "Neden" / "Neden1, Neden2" / "Neden > Alt1, Alt2" / "Neden > Alt > AltAlt"
function aiParseCauses(text) {
    const results = [];
    const lines = text.split(/\n/).map(l => l.trim()).filter(l => l.length > 0);
    lines.forEach(line => {
        if (line.includes('>')) {
            const levels = line.split('>').map(l => l.trim());
            const rootNames = levels[0].split(',').map(s => s.trim()).filter(s => s.length > 0);
            rootNames.forEach(rootName => {
                const node = { name: rootName, children: [] };
                if (levels.length > 1) {
                    const subNames = levels[1].split(',').map(s => s.trim()).filter(s => s.length > 0);
                    node.children = subNames.map(subName => {
                        const subNode = { name: subName, children: [] };
                        if (levels.length > 2) {
                            subNode.children = levels[2].split(',').map(s => s.trim()).filter(s => s.length > 0)
                                .map(ssName => ({ name: ssName, children: [] }));
                        }
                        return subNode;
                    });
                }
                results.push(node);
            });
        } else {
            line.split(',').map(s => s.trim()).filter(s => s.length > 1)
                .forEach(name => results.push({ name, children: [] }));
        }
    });
    return results;
}

function aiSend() {
    const input = document.getElementById('aiUserInput');
    const text = input.value.trim();
    if (!text) return;

    aiAddMessage('user', text.replace(/\n/g,'<br>'));
    input.value = '';

    const step = AI_STEPS[_aiStep];

    if (step.key === 'problem') {
        _aiProblem = text;
        aiAddMessage('bot', `‚úÖ Problem kaydedildi: <strong>${text}</strong><br><br>≈ûimdi her kategori i√ßin olasƒ± nedenleri soracaƒüƒ±m. ƒ∞stemediƒüiniz kategoriyi bo≈ü bƒ±rakabilir veya "ge√ß" yazabilirsiniz.`);
        _aiStep++;
        setTimeout(() => aiAsk(_aiStep), 600);
    } else if (step.category) {
        if (text.toLowerCase() !== 'ge√ß' && text.toLowerCase() !== 'gec' && text !== '-') {
            const causes = aiParseCauses(text);
            if (causes.length > 0) {
                _aiCauses[step.category] = causes;
                const subCount = causes.reduce((s,c) => s + c.children.length + c.children.reduce((ss,cc) => ss + cc.children.length,0), 0);
                const msg = subCount > 0
                    ? `‚úÖ <strong>${step.category}</strong> i√ßin ${causes.length} neden, ${subCount} alt neden eklendi.`
                    : `‚úÖ <strong>${step.category}</strong> i√ßin ${causes.length} neden eklendi.`;
                aiAddMessage('bot', msg);
            } else {
                aiAddMessage('bot', `‚è≠Ô∏è ${step.category} kategorisi ge√ßildi.`);
            }
        } else {
            aiAddMessage('bot', `‚è≠Ô∏è ${step.category} kategorisi ge√ßildi.`);
        }
        _aiStep++;
        aiRenderPreview();

        if (_aiStep < AI_STEPS.length - 1) {
            setTimeout(() => aiAsk(_aiStep), 600);
        } else {
            // Done
            const total = Object.values(_aiCauses).reduce((s, arr) => s + arr.length, 0);
            if (total > 0) {
                aiAddMessage('bot', `üéâ Harika! Toplam <strong>${total} neden</strong> ${Object.keys(_aiCauses).length} kategoride olu≈üturuldu.<br><br>Saƒü taraftan nedenleri d√ºzenleyebilir, sonra <strong>"Balƒ±k Kƒ±l√ßƒ±ƒüƒ±nƒ± Olu≈ütur"</strong> butonuna basabilirsiniz.`);
                document.getElementById('aiGenerateBtn').disabled = false;
            } else {
                aiAddMessage('bot', '‚ö†Ô∏è Hi√ß neden girilmedi. L√ºtfen sƒ±fƒ±rlayƒ±p tekrar deneyin.');
            }
            document.getElementById('aiUserInput').disabled = true;
            document.getElementById('aiSendBtn').disabled = true;
        }
    }
}

function aiDeleteCause(category, idx) {
    if (_aiCauses[category]) {
        _aiCauses[category].splice(idx, 1);
        if (_aiCauses[category].length === 0) delete _aiCauses[category];
    }
    aiRenderPreview();
}

function aiRenderPreview() {
    // Step indicator
    const indicator = document.getElementById('aiStepIndicator');
    const categorySteps = AI_STEPS.filter(s => s.category);
    indicator.innerHTML = categorySteps.map((s, i) => {
        const isDone = _aiCauses[s.category] !== undefined;
        const isCurrent = AI_STEPS[_aiStep] && AI_STEPS[_aiStep].category === s.category;
        return `<div class="ai-step-dot ${isDone ? 'done' : isCurrent ? 'active' : ''}" title="${s.category}"></div>`;
    }).join('');

    // Category cards
    const cards = document.getElementById('aiCategoryCards');
    const categoryStepKeys = AI_STEPS.filter(s => s.category).map(s => s.category);
    cards.innerHTML = categoryStepKeys.map(cat => {
        const causes = _aiCauses[cat] || [];
        return `<div class="ai-category-card">
            <div class="ai-category-title">${cat}</div>
            <div class="ai-tag-list">
                ${causes.length === 0
                    ? `<span class="ai-tag-empty">Hen√ºz neden yok</span>`
                    : causes.map((c, i) => {
                        const name = (typeof c === 'object') ? c.name : c;
                        const kids = (typeof c === 'object' && c.children && c.children.length > 0) ? c.children : [];
                        const subHtml = kids.length > 0
                            ? `<span class="ai-tag-subs">${kids.map(k => {
                                const ks = (typeof k==='object') ? k : {name:k,children:[]};
                                return escapeHtml(ks.name) + (ks.children&&ks.children.length ? ` (${ks.children.length})` : '');
                              }).join(', ')}</span>`
                            : '';
                        const badge = kids.length > 0 ? `<span class="ai-tag-badge">${kids.length}</span>` : '';
                        return `<span class="ai-tag ${kids.length ? 'ai-tag-tree' : ''}">${escapeHtml(name)}${badge}<span class="ai-tag-del" onclick="aiDeleteCause('${cat}',${i})">√ó</span>${subHtml}</span>`;
                    }).join('')}
            </div>
        </div>`;
    }).join('');
}

function aiGenerateFishbone() {
    if (!_aiProblem && !state.problem) {
        showNotification('Problem adƒ± bulunamadƒ±', 'error');
        return;
    }

    // Set problem
    if (_aiProblem) {
        state.problem = _aiProblem;
        const el = document.getElementById('problemTitle');
        if (el) el.value = _aiProblem;
    }

    // Clear existing causes
    state.causes = [];
    state.nextId = 1;

    // Recursively build cause nodes from tree structure
    function buildCauseNode(node, color) {
        const name = (typeof node === 'object') ? node.name : node;
        const kids = (typeof node === 'object' && node.children) ? node.children : [];
        return {
            id: state.nextId++, name, color,
            x: 0, y: 0, angle: 0, branchFlip: false, labelFlip: false,
            children: kids.map(k => buildCauseNode(k, color))
        };
    }

    const SIDES = ['top','bottom','top','bottom','top','bottom','top','bottom'];
    const categories = Object.keys(_aiCauses);
    categories.forEach((cat, idx) => {
        const side = SIDES[idx % SIDES.length] || 'top';
        const color = COLORS[idx % COLORS.length];
        const parentId = state.nextId++;
        const parent = {
            id: parentId, name: cat, side, color,
            x: 0, y: 0, angle: 0, branchFlip: false,
            labelFlip: false, children: []
        };
        _aiCauses[cat].forEach(node => {
            parent.children.push(buildCauseNode(node, color));
        });
        state.causes.push(parent);
    });

    autoSave();

    // fishboneView g√∂r√ºn√ºr hale getir, SONRA render + autoLayout √ßalƒ±≈ütƒ±r
    switchView('fishbone');
    setTimeout(() => {
        const container = document.getElementById('canvasContainer');
        const W = container.clientWidth  || (window.innerWidth  - 340);
        const H = container.clientHeight || (window.innerHeight - 56);
        // Render i√ßin ger√ßek boyutlara g√∂re sabit ayarlar
        state.autoLayoutSettings = {
            fontSizeMain: 13,
            fontSizeSub: 12,
            boneLength: Math.round(H * 0.38),
            branchLength: 110,
            subBranchLength: 70,
            spineLength: W - 220
        };
        render();
        autoLayout();
        showNotification('Balƒ±k kƒ±l√ßƒ±ƒüƒ± olu≈üturuldu!', 'success');
    }, 200);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  AKSƒ∞YON PLANI
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const SOLUTION_METHODS = [
    { code: '',      label: '‚Äî Se√ß ‚Äî',                  desc: '' },
    { code: '5why',  label: '5 Neden (5-Why)',           desc: 'Semptomdan k√∂k nedene ula≈ümak i√ßin 5 kez "Neden?" sorusu sorulur. Basit, g√∂rsel ve hƒ±zlƒ± uygulanabilir.' },
    { code: 'pdca',  label: 'PDCA (Plan-Do-Check-Act)',  desc: 'Deming d√∂ng√ºs√º: Plan ‚Üí Uygula ‚Üí Kontrol Et ‚Üí √ñnlem Al. S√ºrekli iyile≈ütirme i√ßin temel √ßer√ßeve.' },
    { code: 'fmea',  label: 'FMEA',                     desc: 'Olasƒ± hata modlarƒ±nƒ± ve etkilerini risk √∂ncelik sayƒ±sƒ±na (RPN) g√∂re √∂nceliklendirme tekniƒüi.' },
    { code: '8d',    label: '8D Raporu',                 desc: '8 disiplinli takƒ±m tabanlƒ± problem √ß√∂zme: tanƒ±mlama ‚Üí kƒ±sa vadeli ‚Üí k√∂k neden ‚Üí kalƒ±cƒ± d√ºzeltme ‚Üí √∂nleme.' },
    { code: 'a3',    label: 'A3 Raporu',                 desc: 'Toyota kaynaklƒ± tek sayfa format: durum ‚Üí hedef ‚Üí analiz ‚Üí planda ‚Üí sonu√ßlar. Toyota Problem Solving.' },
    { code: 'kaizen',label: 'Kaizen / S√ºrekli ƒ∞yile≈ütirme', desc: 'K√º√ß√ºk, s√ºrekli ve katƒ±lƒ±mcƒ± iyile≈ütirmeler. "ƒ∞yi deƒüi≈üim" felsefesini t√ºm √ßalƒ±≈üanlara yayar.' },
    { code: 'dmaic', label: 'DMAIC (Six Sigma)',         desc: 'Tanƒ±mla ‚Üí √ñl√ß ‚Üí Analiz Et ‚Üí ƒ∞yile≈ütir ‚Üí Kontrol Et. Veri odaklƒ± kalite iyile≈ütirme metodolojisi.' },
    { code: 'pareto',label: 'Pareto Analizi (80/20)',    desc: 'Sorunlarƒ±n %80\'ini yaratan %20\'lik nedenleri tespit et. √ñnceliklendirme i√ßin temel ara√ß.' },
    { code: 'poka',  label: 'Poka-Yoke (Hata Engelleme)',desc: 'ƒ∞nsan hatalarƒ±nƒ± fiziksel veya dijital √∂nlemlerle imk√¢nsƒ±z kƒ±lan mekanizmalar tasarlama.' },
    { code: 'lean',  label: 'Lean / Deƒüer Akƒ±≈üƒ± (VSM)', desc: 'ƒ∞srafƒ± (muda) tespit edip elimine ederek deƒüer akƒ±≈üƒ±nƒ± optimize et. Value Stream Mapping ile g√∂rselle≈ütir.' },
    { code: 'spc',   label: 'SPC / Kontrol Grafikleri', desc: 'ƒ∞statistiksel Proses Kontrol√º: s√ºre√ß varyasyonunu kontrol sƒ±nƒ±rlarƒ±yla izle, sapmalarƒ± erkenden yakala.' },
    { code: 'tpm',   label: 'TPM (Toplam Verimli Bakƒ±m)',desc: 'Ekipman verimliliƒüini (OEE) maksimize etmek i√ßin √∂nleyici ve otonom bakƒ±m sistemleri.' },
    { code: 'smed',  label: 'SMED (Hƒ±zlƒ± Kalƒ±p Deƒüi≈üimi)',desc: 'Kurulum/deƒüi≈üim s√ºrelerini tek haneli dakikalara indirme. ƒ∞√ß ‚Üí dƒ±≈ü faaliyet d√∂n√º≈ü√ºm√º.' },
    { code: 'doe',   label: 'DoE (Deney Tasarƒ±mƒ±)',     desc: 'Birden fazla fakt√∂r√º e≈ü zamanlƒ± deƒüi≈ütirerek etkilerini √∂l√ßen istatistiksel deney metodolojisi.' },
    { code: 'kano',  label: 'Kano Modeli',              desc: 'M√º≈üteri memnuniyetini: temel beklentiler, performans √∂zellikleri ve heyecan yaratƒ±cƒ±lar olarak sƒ±nƒ±flandƒ±rƒ±r.' },
];

let _apNextId = 1;

function initActionPlan() {
    if (!state.actionPlan) state.actionPlan = { rows: [] };
    if (state.actionPlan.rows.length > 0) {
        _apNextId = Math.max(...state.actionPlan.rows.map(r => r.apId || 0)) + 1;
    }
}

// Collect all leaf causes (deepest level causes) from the fishbone
function collectAllCauses() {
    const all = [];
    function walk(causes, parentLabel, depth) {
        causes.forEach(c => {
            if (depth > 1) {
                all.push({ id: c.id, name: c.name, parent: parentLabel, depth, _contrib: c._contrib || null });
            }
            if (c.children && c.children.length > 0) {
                walk(c.children, c.name, depth + 1);
            }
        });
    }
    walk(state.causes, 'Ana Neden', 1);
    return all;
}

function syncCausesToActionPlan() {
    initActionPlan();
    const allCauses = collectAllCauses(); // depth > 1, ana nedenler hari√ß

    // Mevcut kullanƒ±cƒ± verilerini causeId ‚Üí row olarak sakla (aksiyon, sorumlu vs.)
    const existingData = new Map(
        state.actionPlan.rows
            .filter(r => r.causeId !== null)
            .map(r => [r.causeId, r])
    );
    // causeId===null olan manuel eklenmi≈ü satƒ±rlarƒ± koru
    const manualRows = state.actionPlan.rows.filter(r => r.causeId === null);

    // Balƒ±k kƒ±l√ßƒ±ƒüƒ±ndaki sƒ±rayla yeni satƒ±r listesini olu≈ütur
    const newRows = allCauses.map(c => {
        const old = existingData.get(c.id);
        return {
            apId:         old ? old.apId : _apNextId++,
            causeId:      c.id,
            causeName:    c.name,
            parentCause:  c.parent,
            action:       old ? old.action       : '',
            responsible:  old ? old.responsible  : '',
            dueDate:      old ? old.dueDate       : '',
            contribution: old ? old.contribution  : (c._contrib != null ? c._contrib : 0),
            method:       old ? old.method        : '',
            status:       old ? old.status        : 'A√ßƒ±k'
        };
    });

    state.actionPlan.rows = [...newRows, ...manualRows];
    autoSave();
    renderActionPlan();
    showNotification(newRows.length + ' neden senkronize edildi', 'success');
}

function addActionRow() {
    initActionPlan();
    state.actionPlan.rows.push({
        apId: _apNextId++,
        causeId: null,
        isManual: true,
        causeName: '',
        parentCause: '',
        action: '',
        responsible: '',
        dueDate: '',
        contribution: 0,
        method: '',
        status: 'A√ßƒ±k'
    });
    autoSave();
    renderActionPlan();
}

function deleteActionRow(apId) {
    initActionPlan();
    const row = state.actionPlan.rows.find(r => r.apId === apId);
    // Manuel eklenen satƒ±r: kƒ±l√ßƒ±ktaki d√ºƒü√ºm√º de sil
    if (row && row.isManual && row.causeId !== null) {
        removeCause(row.causeId);
        autoSave();
        render();
    }
    state.actionPlan.rows = state.actionPlan.rows.filter(r => r.apId !== apId);
    autoSave();
    renderActionPlan();
}

function updateActionRow(apId, field, value) {
    initActionPlan();
    const row = state.actionPlan.rows.find(r => r.apId === apId);
    if (!row) return;
    if (field === 'contribution') {
        row[field] = Math.min(100, Math.max(0, parseFloat(value) || 0));
    } else {
        row[field] = value;
    }
    // Manuel satƒ±r ‚Üí kƒ±l√ßƒ±kla senkronize et
    if (row.isManual && (field === 'causeName' || field === 'parentCause')) {
        if (row.causeId !== null) {
            // Zaten baƒülƒ±: sadece adƒ± g√ºncelle
            const node = findCause(row.causeId);
            if (node && field === 'causeName') { node.name = value; render(); }
        } else if (row.causeName && row.parentCause) {
            // Hem ad hem kategori doldu: kƒ±l√ßƒ±ƒüa ekle
            apAddToFishbone(row);
        }
    }
    autoSave();
    // Update contribution total display without full re-render
    updateContribTotal();
    if (field === 'contribution') {
        const bar = document.getElementById('apBar_' + apId);
        if (bar) bar.style.width = Math.min(100, row.contribution) + '%';
        const barNum = document.getElementById('apBarNum_' + apId);
        if (barNum) barNum.textContent = row.contribution + '%';
    }
}

// Aksiyon planƒ±ndaki manuel satƒ±rƒ± kƒ±l√ßƒ±k diyagramƒ±na ekler
function apBuildCauseOptions(selected) {
    const opts = [];
    function walk(nodes, depth) {
        nodes.forEach(c => {
            const prefix = depth === 0 ? '' : '¬†¬†'.repeat(depth) + '‚Ü≥ ';
            const sel = selected === c.name ? 'selected' : '';
            opts.push(`<option value="${escapeHtml(c.name)}" ${sel}>${prefix}${escapeHtml(c.name)}</option>`);
            if (c.children && c.children.length) walk(c.children, depth + 1);
        });
    }
    walk(state.causes, 0);
    return opts.join('');
}

function apAddToFishbone(row) {
    // T√ºm d√ºƒü√ºmlerde e≈üle≈üen √ºst nedeni ara (adƒ±na g√∂re)
    let parent = findCause(null) || null; // reset
    function findByName(name, nodes) {
        for (const c of nodes) {
            if (c.name === name) return c;
            const found = findByName(name, c.children || []);
            if (found) return found;
        }
        return null;
    }
    parent = findByName(row.parentCause, state.causes);
    if (!parent) {
        // Kategori yok: se√ßilen isimde √ºst neden olu≈ütur
        const color = COLORS[state.causes.length % COLORS.length];
        parent = {
            id: state.nextId++, name: row.parentCause || 'Diƒüer',
            side: state.causes.length % 2 === 0 ? 'top' : 'bottom',
            color, x: 0, y: 0, angle: 0, branchFlip: false, labelFlip: false, children: []
        };
        state.causes.push(parent);
    }
    if (!parent) {
        // Kategori yok: 'Diƒüer' adƒ±yla √ºst neden olu≈ütur
        const color = COLORS[state.causes.length % COLORS.length];
        parent = {
            id: state.nextId++, name: row.parentCause || 'Diƒüer',
            side: state.causes.length % 2 === 0 ? 'top' : 'bottom',
            color, x: 0, y: 0, angle: 0, branchFlip: false, labelFlip: false, children: []
        };
        state.causes.push(parent);
    }
    const newNode = {
        id: state.nextId++, name: row.causeName, color: parent.color,
        x: 0, y: 0, angle: 0, branchFlip: false, labelFlip: false, children: []
    };
    parent.children.push(newNode);
    row.causeId = newNode.id;
    showNotification('"' + row.causeName + '" kƒ±l√ßƒ±ƒüa eklendi', 'success');
    autoSave();
    render();
    renderActionPlan();
}

function updateContribTotal() {
    if (!state.actionPlan) return;
    const total = state.actionPlan.rows.reduce((s, r) => s + (parseFloat(r.contribution) || 0), 0);
    const el = document.getElementById('apContribTotal');
    if (el) {
        el.textContent = 'Toplam Katkƒ±: ' + Math.round(total * 10) / 10 + '%';
        el.className = 'ap-contrib-total' + (total > 100 ? ' over' : total === 100 ? ' perfect' : '');
    }
}

const STATUS_OPTIONS = ['A√ßƒ±k', 'Devam Ediyor', 'Tamamlandƒ±', 'ƒ∞ptal'];

function renderActionPlan() {
    initActionPlan();
    const problemBadge = document.getElementById('apProblemBadge');
    if (problemBadge) problemBadge.textContent = state.problem || 'Ana Problem';

    const tbody = document.getElementById('apTableBody');
    const emptyEl = document.getElementById('apEmpty');
    if (!tbody) return;

    const rows = state.actionPlan.rows;
    emptyEl.style.display = rows.length === 0 ? 'flex' : 'none';

    const methodOptions = SOLUTION_METHODS.map(m =>
        `<option value="${m.code}">${escapeHtml(m.label)}</option>`
    ).join('');
    const statusOptions = STATUS_OPTIONS.map(s =>
        `<option value="${s}">${s}</option>`
    ).join('');

    tbody.innerHTML = rows.map(row => {
        const pct = Math.min(100, parseFloat(row.contribution) || 0);
        const barColor = pct >= 100 ? '#ef4444' : pct >= 70 ? '#f59e0b' : '#22c55e';
        const statusClass = row.status === 'Tamamlandƒ±' ? 'done' : row.status === 'ƒ∞ptal' ? 'cancelled' : row.status === 'Devam Ediyor' ? 'wip' : '';
        return `<tr class="ap-row ${statusClass}" data-apid="${row.apId}">
            <td>
                <input class="ap-input ap-cause-edit" type="text"
                    value="${escapeHtml(row.causeName)}"
                    placeholder="Neden a√ßƒ±klamasƒ±..."
                    onchange="updateActionRow(${row.apId},'causeName',this.value)"
                    title="${row.parentCause ? '√úst: ' + escapeHtml(row.parentCause) : ''}" />
                ${row.isManual
                    ? `<select class="ap-cat-select" onchange="updateActionRow(${row.apId},'parentCause',this.value)">
                        <option value="">‚Äî √úst neden se√ß ‚Äî</option>
                        ${apBuildCauseOptions(row.parentCause)}
                       </select>`
                    : (row.parentCause ? `<div class="ap-parent-label">${escapeHtml(row.parentCause)}</div>` : '')}
            </td>
            <td>
                <textarea class="ap-input ap-action-ta" rows="2"
                    placeholder="Yapƒ±lacak aksiyon..."
                    onchange="updateActionRow(${row.apId},'action',this.value)">${escapeHtml(row.action)}</textarea>
            </td>
            <td>
                <input class="ap-input" type="text"
                    value="${escapeHtml(row.responsible)}"
                    placeholder="Ad Soyad"
                    onchange="updateActionRow(${row.apId},'responsible',this.value)" />
            </td>
            <td>
                <input class="ap-input" type="date"
                    value="${escapeHtml(row.dueDate)}"
                    onchange="updateActionRow(${row.apId},'dueDate',this.value)" />
            </td>
            <td>
                <div class="ap-contrib-cell">
                    <input class="ap-input ap-contrib-input" type="number" min="0" max="100"
                        value="${row.contribution}"
                        oninput="updateActionRow(${row.apId},'contribution',this.value)" />
                    <div class="ap-contrib-bar-wrap">
                        <div class="ap-contrib-bar" id="apBar_${row.apId}" style="width:${pct}%;background:${barColor}"></div>
                    </div>
                </div>
            </td>
            <td>
                <select class="ap-select" onchange="updateActionRow(${row.apId},'method',this.value)">
                    ${methodOptions}
                </select>
            </td>
            <td>
                <select class="ap-select ap-status-sel" onchange="updateActionRow(${row.apId},'status',this.value)">
                    ${statusOptions}
                </select>
            </td>
            <td style="text-align:center;">
                <button class="btn-8d-ap" onclick="open8DForActionRow()" title="8D Raporu A√ß">üìã</button>
            </td>
            <td>
                <button class="ap-del-btn" onclick="deleteActionRow(${row.apId})" title="Sil">
                    <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14H6L5 6"/><path d="M10 11v6M14 11v6"/><path d="M9 6V4h6v2"/></svg>
                </button>
            </td>
        </tr>`;
    }).join('');

    // Set saved select values
    tbody.querySelectorAll('.ap-row').forEach(tr => {
        const apId = parseInt(tr.dataset.apid);
        const row = rows.find(r => r.apId === apId);
        if (!row) return;
        const methodSel = tr.querySelector('.ap-select:not(.ap-status-sel)');
        const statusSel = tr.querySelector('.ap-status-sel');
        if (methodSel) methodSel.value = row.method;
        if (statusSel) statusSel.value = row.status;
    });

    updateContribTotal();
}

function open8DForActionRow() {
    const konu = (state && state.problem) ? state.problem : '';
    const url  = '8d-rapor.html?source=' + encodeURIComponent('Balƒ±k Kƒ±l√ßƒ±ƒüƒ±') + '&konu=' + encodeURIComponent(konu);
    window.open(url, '_blank');
}

function renderMethodsGrid() {
    const grid = document.getElementById('apMethodsGrid');
    if (!grid) return;
    grid.innerHTML = SOLUTION_METHODS.filter(m => m.code).map(m => `
        <div class="ap-method-card">
            <div class="ap-method-title">${escapeHtml(m.label)}</div>
            <div class="ap-method-desc">${escapeHtml(m.desc)}</div>
        </div>
    `).join('');
}

// Fishbone SVG'yi beyaz arka plan PNG olarak yakalar, Promise<dataURL> d√∂nd√ºr√ºr
function captureFishbonePng() {
    return new Promise((resolve) => {
        const rs  = getComputedStyle(document.documentElement);
        const origSvg  = document.getElementById('canvasSvg');
        if (!origSvg) return resolve(null);
        const panGroup = origSvg.querySelector('g[transform]');

        const savedTransform = panGroup ? panGroup.getAttribute('transform') : null;
        if (panGroup) panGroup.setAttribute('transform', 'translate(0,0) scale(1)');
        let bbox;
        try { bbox = panGroup ? panGroup.getBBox() : origSvg.getBBox(); }
        catch(e) { bbox = { x:0, y:0, width:1200, height:700 }; }
        if (panGroup && savedTransform) panGroup.setAttribute('transform', savedTransform);
        if (bbox.width < 10 || bbox.height < 10) bbox = { x:0, y:0, width:1200, height:700 };

        const PAD=60, SCALE=1.5;
        const vbX=bbox.x-PAD, vbY=bbox.y-PAD, vbW=bbox.width+PAD*2, vbH=bbox.height+PAD*2;
        const W=Math.round(vbW*SCALE), H=Math.round(vbH*SCALE);

        const svgClone = origSvg.cloneNode(true);
        const cg = svgClone.querySelector('g[transform]');
        if (cg) cg.setAttribute('transform','translate(0,0) scale(1)');
        svgClone.querySelectorAll('[class*="drag-handle"],[data-drag-mode="spine-resize"]').forEach(el=>el.remove());
        svgClone.setAttribute('xmlns','http://www.w3.org/2000/svg');
        svgClone.removeAttribute('style');
        svgClone.setAttribute('width',W); svgClone.setAttribute('height',H);
        svgClone.setAttribute('viewBox',`${vbX} ${vbY} ${vbW} ${vbH}`);

        let svgStr = new XMLSerializer().serializeToString(svgClone);
        svgStr = svgStr
            .replace(/var\(--spine-color\)/g,    rs.getPropertyValue('--spine-color').trim()||'#64748b')
            .replace(/var\(--accent\)/g,          rs.getPropertyValue('--accent').trim()||'#6366f1')
            .replace(/var\(--text-primary\)/g,    '#1e293b')
            .replace(/var\(--text-secondary\)/g,  '#64748b')
            .replace(/var\(--bg-primary\)/g,      '#ffffff')
            .replace(/var\(--bg-secondary\)/g,    '#f1f5f9')
            .replace(/var\(--border\)/g,          rs.getPropertyValue('--border').trim()||'#334155')
            .replace(/var\(--[^)]+\)/g,           '#888');
        svgStr = svgStr.replace(/(<svg\b[^>]*>)/, `$1<rect x="${vbX}" y="${vbY}" width="${vbW}" height="${vbH}" fill="#ffffff"/>`);

        const canvas = document.createElement('canvas');
        canvas.width=W; canvas.height=H;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,W,H);

        const blob2 = new Blob([svgStr],{type:'image/svg+xml;charset=utf-8'});
        const blobUrl = URL.createObjectURL(blob2);
        const img = new Image();
        img.onload = () => { ctx.drawImage(img,0,0,W,H); URL.revokeObjectURL(blobUrl); resolve(canvas.toDataURL('image/png')); };
        img.onerror = () => {
            URL.revokeObjectURL(blobUrl);
            try {
                const b64=btoa(unescape(encodeURIComponent(svgStr)));
                const img2=new Image();
                img2.onload=()=>{ctx.drawImage(img2,0,0,W,H); resolve(canvas.toDataURL('image/png'));};
                img2.onerror=()=>resolve(null);
                img2.src='data:image/svg+xml;base64,'+b64;
            } catch(e){ resolve(null); }
        };
        img.src = blobUrl;
    });
}

// Excel i√ßin SVG'yi inline string olarak d√∂nd√ºr√ºr (data: URI yerine doƒürudan markup)
function captureFishboneSvg() {
    const rs = getComputedStyle(document.documentElement);
    const origSvg = document.getElementById('canvasSvg');
    if (!origSvg) return null;
    const panGroup = origSvg.querySelector('g[transform]');

    const savedTransform = panGroup ? panGroup.getAttribute('transform') : null;
    if (panGroup) panGroup.setAttribute('transform', 'translate(0,0) scale(1)');
    let bbox;
    try { bbox = panGroup ? panGroup.getBBox() : origSvg.getBBox(); }
    catch(e) { bbox = { x:0, y:0, width:1200, height:700 }; }
    if (panGroup && savedTransform) panGroup.setAttribute('transform', savedTransform);
    if (bbox.width < 10 || bbox.height < 10) bbox = { x:0, y:0, width:1200, height:700 };

    const PAD = 60;
    const vbX=bbox.x-PAD, vbY=bbox.y-PAD, vbW=bbox.width+PAD*2, vbH=bbox.height+PAD*2;
    const W = Math.round(vbW), H = Math.round(vbH);

    const svgClone = origSvg.cloneNode(true);
    const cg = svgClone.querySelector('g[transform]');
    if (cg) cg.setAttribute('transform', 'translate(0,0) scale(1)');
    svgClone.querySelectorAll('[class*="drag-handle"],[data-drag-mode="spine-resize"]').forEach(el => el.remove());
    svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    svgClone.removeAttribute('style');
    svgClone.setAttribute('width', W);
    svgClone.setAttribute('height', H);
    svgClone.setAttribute('viewBox', `${vbX} ${vbY} ${vbW} ${vbH}`);

    let svgStr = new XMLSerializer().serializeToString(svgClone);
    svgStr = svgStr
        .replace(/var\(--spine-color\)/g,   rs.getPropertyValue('--spine-color').trim()  || '#64748b')
        .replace(/var\(--accent\)/g,         rs.getPropertyValue('--accent').trim()        || '#6366f1')
        .replace(/var\(--text-primary\)/g,   '#1e293b')
        .replace(/var\(--text-secondary\)/g, '#64748b')
        .replace(/var\(--bg-primary\)/g,     '#ffffff')
        .replace(/var\(--bg-secondary\)/g,   '#f1f5f9')
        .replace(/var\(--border\)/g,         rs.getPropertyValue('--border').trim()        || '#334155')
        .replace(/var\(--[^)]+\)/g,          '#888');
    // Beyaz arka plan rect
    svgStr = svgStr.replace(/(<svg\b[^>]*>)/, `$1<rect x="${vbX}" y="${vbY}" width="${vbW}" height="${vbH}" fill="#ffffff"/>`);
    return svgStr;
}

async function downloadFishbonePng() {
    showNotification('PNG hazƒ±rlanƒ±yor...', 'info');
    const jpegUrl = await (async () => {
        try {
            const svgStr = captureFishboneSvg();
            if (!svgStr) return null;
            return await new Promise(res => {
                const img = new Image();
                img.onload = () => {
                    const c = document.createElement('canvas');
                    c.width  = img.naturalWidth  || 1200;
                    c.height = img.naturalHeight || 700;
                    const ctx = c.getContext('2d');
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, c.width, c.height);
                    ctx.drawImage(img, 0, 0, c.width, c.height);
                    res(c.toDataURL('image/png'));
                };
                img.onerror = () => res(null);
                img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgStr);
            });
        } catch(e) { return null; }
    })();
    if (!jpegUrl) { showNotification('Diyagram yakalanamadƒ±', 'error'); return; }
    const a = document.createElement('a');
    a.href = jpegUrl;
    a.download = 'balik-kilcigi-' + new Date().toISOString().slice(0,10) + '.png';
    a.click();
    showNotification('Diyagram PNG indirildi ‚Äî Excel\'e yapƒ±≈ütƒ±rabilirsiniz', 'success');
}

// ‚îÄ‚îÄ‚îÄ Minimal uncompressed ZIP builder (for XLSX) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function _buildZip(files) {
    const CRC = new Uint32Array(256);
    for (let i = 0; i < 256; i++) {
        let c = i;
        for (let j = 0; j < 8; j++) c = (c & 1) ? 0xEDB88320 ^ (c >>> 1) : c >>> 1;
        CRC[i] = c;
    }
    function crc32(buf) {
        let c = 0xFFFFFFFF;
        for (let i = 0; i < buf.length; i++) c = (c >>> 8) ^ CRC[(c ^ buf[i]) & 0xFF];
        return (c ^ 0xFFFFFFFF) >>> 0;
    }
    const enc = new TextEncoder();
    function u16(n) { return [(n&0xFF),((n>>8)&0xFF)]; }
    function u32(n) { return [(n&0xFF),((n>>8)&0xFF),((n>>16)&0xFF),((n>>24)&0xFF)]; }

    const localParts = [], centralDirEntries = [];
    let offset = 0;
    for (const f of files) {
        const nameBytes = enc.encode(f.name);
        const data = (typeof f.data === 'string') ? enc.encode(f.data) : f.data;
        const crc = crc32(data), size = data.length;
        const lh = new Uint8Array([0x50,0x4B,0x03,0x04,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,...u32(crc),...u32(size),...u32(size),...u16(nameBytes.length),0x00,0x00,...nameBytes]);
        const ce = new Uint8Array([0x50,0x4B,0x01,0x02,0x14,0x00,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,...u32(crc),...u32(size),...u32(size),...u16(nameBytes.length),0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,...u32(offset),...nameBytes]);
        localParts.push(lh, data); centralDirEntries.push(ce);
        offset += lh.length + data.length;
    }
    const cdSize = centralDirEntries.reduce((s,e) => s+e.length, 0);
    const eocd = new Uint8Array([0x50,0x4B,0x05,0x06,0x00,0x00,0x00,0x00,...u16(files.length),...u16(files.length),...u32(cdSize),...u32(offset),0x00,0x00]);
    const total = offset + cdSize + eocd.length;
    const result = new Uint8Array(total); let pos = 0;
    for (const p of localParts) { result.set(p,pos); pos+=p.length; }
    for (const e of centralDirEntries) { result.set(e,pos); pos+=e.length; }
    result.set(eocd, pos);
    return result;
}

// ‚îÄ‚îÄ‚îÄ Excel Export (.xlsx ‚Äî real OOXML with embedded PNG) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function exportActionPlanXLSX() {
    try {
        initActionPlan();
        showNotification('Excel haz\u0131rlan\u0131yor...', 'info');

        const xe = s => String(s == null ? '' : s)
            .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
        const methodMap = Object.fromEntries(SOLUTION_METHODS.map(m=>[m.code, m.label]));

        const now      = new Date();
        const tarih    = now.toLocaleDateString('tr-TR',{day:'2-digit',month:'long',year:'numeric'});
        const problem  = xe(state.problem  || 'Ana Problem');
        const aciklama = xe(state.problemDesc || '');
        const catSay   = state.causes.length;
        const rows     = state.actionPlan.rows;
        const akcSay   = rows.length;
        const tamamSay = rows.filter(r => r.status === 'Tamamland\u0131').length;
        const topKatki = Math.round(rows.reduce((s,r) => s + (parseFloat(r.contribution)||0), 0) * 10) / 10;

        // ‚îÄ‚îÄ PNG (binary) ‚îÄ‚îÄ
        let pngBytes = null;
        try {
            const pngDataUrl = await captureFishbonePng();
            if (pngDataUrl && pngDataUrl.startsWith('data:image/')) {
                const b64 = pngDataUrl.split(',')[1];
                const bin = atob(b64);
                pngBytes = new Uint8Array(bin.length);
                for (let i = 0; i < bin.length; i++) pngBytes[i] = bin.charCodeAt(i);
            }
        } catch(e) {}
        const hasPng = !!pngBytes;

        // ‚îÄ‚îÄ Cell helpers ‚îÄ‚îÄ
        const CL = n => String.fromCharCode(64 + n); // 1=A..8=H
        const ic = (col, row, sId, type, val) => {
            const r = CL(col) + row;
            if (type === 'n') return `<c r="${r}" s="${sId}"><v>${val}</v></c>`;
            if (type === 's') return `<c r="${r}" s="${sId}" t="inlineStr"><is><t>${val}</t></is></c>`;
            return `<c r="${r}" s="${sId}"/>`;
        };

        // ‚îÄ‚îÄ Column widths ‚îÄ‚îÄ
        const WIDTHS  = [150,130,260,110,100,70,160,100];
        const COLS_XML = WIDTHS.map((w,i) => `<col min="${i+1}" max="${i+1}" width="${+(w/7).toFixed(1)}" customWidth="1"/>`).join('');
        const HEADERS  = ['K\u00f6k Neden','\u00dcst Neden/Kategori','Aksiyon','Sorumlu','Hedef Tarih','Katk\u0131 %','\u00c7\u00f6z\u00fcm Y\u00f6ntemi','Durum'];

        // ‚îÄ‚îÄ Row numbers depend on whether image row exists ‚îÄ‚îÄ
        const gapRow      = hasPng ? 6 : 5;
        const hdrRow      = hasPng ? 7 : 6;
        const dataRowStart = hasPng ? 8 : 7;

        // ‚îÄ‚îÄ Build sheet rows ‚îÄ‚îÄ
        const merges = ['A1:H1','B2:F2','B3:F3'];
        merges.push(`A${gapRow}:H${gapRow}`);
        let sheetRows = '';

        // Row 1 title ‚Äî explicit covered cells for A1:H1 merge
        sheetRows += `<row r="1" ht="44" customHeight="1">${ic(1,1,1,'s','AKS\u0130YON PLANI')}${ic(2,1,1)}${ic(3,1,1)}${ic(4,1,1)}${ic(5,1,1)}${ic(6,1,1)}${ic(7,1,1)}${ic(8,1,1)}</row>`;
        // Row 2 problem/date ‚Äî explicit covered cells for B2:F2 merge
        sheetRows += `<row r="2" ht="24" customHeight="1">${ic(1,2,2,'s','Problem / K\u00f6k Neden')}${ic(2,2,3,'s',problem)}${ic(3,2,3)}${ic(4,2,3)}${ic(5,2,3)}${ic(6,2,3)}${ic(7,2,2,'s','Olu\u015fturma Tarihi')}${ic(8,2,3,'s',tarih)}</row>`;
        // Row 3 description/author ‚Äî explicit covered cells for B3:F3 merge
        sheetRows += `<row r="3" ht="36" customHeight="1">${ic(1,3,2,'s','A\u00e7\u0131klama')}${ic(2,3,3,'s',aciklama||'-')}${ic(3,3,3)}${ic(4,3,3)}${ic(5,3,3)}${ic(6,3,3)}${ic(7,3,2,'s','Olu\u015fturan')}${ic(8,3,3,'s','')}</row>`;
        // Row 4 stats
        sheetRows += `<row r="4" ht="26" customHeight="1">${ic(1,4,2,'s','Kategori Say\u0131s\u0131')}${ic(2,4,4,'n',catSay)}${ic(3,4,2,'s','Toplam Aksiyon')}${ic(4,4,4,'n',akcSay)}${ic(5,4,2,'s','Tamamlanan')}${ic(6,4,4,'n',tamamSay)}${ic(7,4,2,'s','Toplam Katk\u0131 %')}${ic(8,4,4,'n',topKatki)}</row>`;
        // Row 5 image (if PNG)
        if (hasPng) sheetRows += `<row r="5" ht="340" customHeight="1">${ic(1,5,17)}${ic(2,5,17)}${ic(3,5,17)}${ic(4,5,17)}${ic(5,5,17)}${ic(6,5,17)}${ic(7,5,17)}${ic(8,5,17)}</row>`;
        // Gap row ‚Äî explicit covered cells for A${gapRow}:H${gapRow} merge
        sheetRows += `<row r="${gapRow}" ht="6" customHeight="1">${ic(1,gapRow,16)}${ic(2,gapRow,16)}${ic(3,gapRow,16)}${ic(4,gapRow,16)}${ic(5,gapRow,16)}${ic(6,gapRow,16)}${ic(7,gapRow,16)}${ic(8,gapRow,16)}</row>`;
        // Header row
        sheetRows += `<row r="${hdrRow}" ht="30" customHeight="1">${HEADERS.map((_,i)=>ic(i+1,hdrRow,5,'s',HEADERS[i])).join('')}</row>`;
        // Data rows
        const statusStyle = {'Tamamland\u0131':12,'Devam Ediyor':13,'\u0130ptal':14};
        rows.forEach((r,i) => {
            const even = (i%2===0), rn = dataRowStart+i, pct = parseFloat(r.contribution)||0;
            const Ss = statusStyle[r.status] || 15;
            sheetRows += `<row r="${rn}" ht="22" customHeight="1">${ic(1,rn,even?9:8,'s',xe(r.causeName))}${ic(2,rn,even?7:6,'s',xe(r.parentCause))}${ic(3,rn,even?7:6,'s',xe(r.action))}${ic(4,rn,even?7:6,'s',xe(r.responsible))}${ic(5,rn,even?7:6,'s',xe(r.dueDate))}${ic(6,rn,even?11:10,'n',pct)}${ic(7,rn,even?7:6,'s',xe(methodMap[r.method]||''))}${ic(8,rn,Ss,'s',xe(r.status))}</row>`;
        });

        const mergeCellsXml = `<mergeCells count="${merges.length}">${merges.map(m=>`<mergeCell ref="${m}"/>`).join('')}</mergeCells>`;

        // ‚îÄ‚îÄ Styles XML ‚îÄ‚îÄ
        const stylesXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"><fonts count="5"><font><sz val="10"/><name val="Calibri"/></font><font><sz val="10"/><b/><name val="Calibri"/></font><font><sz val="16"/><b/><color rgb="FFFFFFFF"/><name val="Calibri"/></font><font><sz val="11"/><b/><name val="Calibri"/></font><font><sz val="11"/><b/><color rgb="FFFFFFFF"/><name val="Calibri"/></font></fonts><fills count="13"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill><fill><patternFill patternType="solid"><fgColor rgb="FF0F172A"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFE2E8F0"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFF8FAFC"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFDBEAFE"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FF1E293B"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFF1F5F9"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFCBD5E1"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFEFF6FF"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FF92D050"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFFFFF00"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFFF7171"/></patternFill></fill></fills><borders count="2"><border><left/><right/><top/><bottom/><diagonal/></border><border><left style="thin"><color rgb="FF94A3B8"/></left><right style="thin"><color rgb="FF94A3B8"/></right><top style="thin"><color rgb="FF94A3B8"/></top><bottom style="thin"><color rgb="FF94A3B8"/></bottom><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="18"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/><xf numFmtId="0" fontId="2" fillId="2" borderId="0" xfId="0"><alignment vertical="center" wrapText="1"/></xf><xf numFmtId="0" fontId="1" fillId="3" borderId="1" applyBorder="1" xfId="0"><alignment vertical="center" wrapText="1"/></xf><xf numFmtId="0" fontId="0" fillId="4" borderId="1" applyBorder="1" xfId="0"><alignment vertical="center" wrapText="1"/></xf><xf numFmtId="0" fontId="3" fillId="5" borderId="1" applyBorder="1" xfId="0"><alignment horizontal="center" vertical="center"/></xf><xf numFmtId="0" fontId="4" fillId="6" borderId="1" applyBorder="1" xfId="0"><alignment horizontal="center" vertical="center" wrapText="1"/></xf><xf numFmtId="0" fontId="0" fillId="0" borderId="1" applyBorder="1" xfId="0"><alignment vertical="center" wrapText="1"/></xf><xf numFmtId="0" fontId="0" fillId="7" borderId="1" applyBorder="1" xfId="0"><alignment vertical="center" wrapText="1"/></xf><xf numFmtId="0" fontId="1" fillId="0" borderId="1" applyBorder="1" xfId="0"><alignment vertical="center" wrapText="1"/></xf><xf numFmtId="0" fontId="1" fillId="7" borderId="1" applyBorder="1" xfId="0"><alignment vertical="center" wrapText="1"/></xf><xf numFmtId="0" fontId="1" fillId="9" borderId="1" applyBorder="1" xfId="0"><alignment horizontal="center" vertical="center"/></xf><xf numFmtId="0" fontId="1" fillId="5" borderId="1" applyBorder="1" xfId="0"><alignment horizontal="center" vertical="center"/></xf><xf numFmtId="0" fontId="0" fillId="10" borderId="1" applyBorder="1" xfId="0"><alignment horizontal="center" vertical="center"/></xf><xf numFmtId="0" fontId="0" fillId="11" borderId="1" applyBorder="1" xfId="0"><alignment horizontal="center" vertical="center"/></xf><xf numFmtId="0" fontId="0" fillId="12" borderId="1" applyBorder="1" xfId="0"><alignment horizontal="center" vertical="center"/></xf><xf numFmtId="0" fontId="0" fillId="0" borderId="1" applyBorder="1" xfId="0"><alignment horizontal="center" vertical="center"/></xf><xf numFmtId="0" fontId="0" fillId="8" borderId="0" xfId="0"/><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/></cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles></styleSheet>`;

        // ‚îÄ‚îÄ Worksheet XML ‚îÄ‚îÄ
        const drawingRef = hasPng ? `<drawing r:id="rId1"/>` : '';
        const sheetXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"><sheetPr><pageSetUpPr fitToPage="1"/></sheetPr><sheetViews><sheetView tabSelected="1" workbookViewId="0"><selection/></sheetView></sheetViews><sheetFormatPr defaultRowHeight="15"/><cols>${COLS_XML}</cols><sheetData>${sheetRows}</sheetData>${mergeCellsXml}<pageMargins left="0.25" right="0.25" top="0.5" bottom="0.5" header="0.2" footer="0.2"/><pageSetup paperSize="9" orientation="portrait" fitToWidth="1" fitToHeight="1" fitToPage="1"/>${drawingRef}</worksheet>`;

        // ‚îÄ‚îÄ Drawing XML ‚îÄ‚îÄ
        const drawingXml = hasPng ? `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><xdr:wsDr xmlns:xdr="http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing" xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"><xdr:twoCellAnchor editAs="twoCell"><xdr:from><xdr:col>0</xdr:col><xdr:colOff>0</xdr:colOff><xdr:row>4</xdr:row><xdr:rowOff>0</xdr:rowOff></xdr:from><xdr:to><xdr:col>7</xdr:col><xdr:colOff>0</xdr:colOff><xdr:row>5</xdr:row><xdr:rowOff>0</xdr:rowOff></xdr:to><xdr:pic><xdr:nvPicPr><xdr:cNvPr id="2" name="fishbone"/><xdr:cNvPicPr><a:picLocks noChangeAspect="1"/></xdr:cNvPicPr></xdr:nvPicPr><xdr:blipFill><a:blip r:embed="rId1"/><a:stretch><a:fillRect/></a:stretch></xdr:blipFill><xdr:spPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="1" cy="1"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></xdr:spPr></xdr:pic><xdr:clientData/></xdr:twoCellAnchor></xdr:wsDr>` : '';

        // ‚îÄ‚îÄ Other XML parts ‚îÄ‚îÄ
        const workbookXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"><bookViews><workbookView xWindow="0" yWindow="0" windowWidth="20000" windowHeight="15000"/></bookViews><sheets><sheet name="Aksiyon Plan\u0131" sheetId="1" r:id="rId1"/></sheets></workbook>`;
        const relsRoot    = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>`;
        const relsWb      = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/></Relationships>`;
        const relsSheet   = hasPng ? `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing" Target="../drawings/drawing1.xml"/></Relationships>` : '';
        const relsDrawing = hasPng ? `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="../media/image1.png"/></Relationships>` : '';
        const contentTypes = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="xml" ContentType="application/xml"/>${hasPng?'<Default Extension="png" ContentType="image/png"/>' : ''}<Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/><Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/><Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>${hasPng?'<Override PartName="/xl/drawings/drawing1.xml" ContentType="application/vnd.openxmlformats-officedocument.drawing+xml"/>':''}</Types>`;

        // ‚îÄ‚îÄ Assemble ZIP ‚îÄ‚îÄ
        const zipFiles = [
            { name: '[Content_Types].xml',          data: contentTypes },
            { name: '_rels/.rels',                  data: relsRoot },
            { name: 'xl/workbook.xml',              data: workbookXml },
            { name: 'xl/_rels/workbook.xml.rels',   data: relsWb },
            { name: 'xl/styles.xml',                data: stylesXml },
            { name: 'xl/worksheets/sheet1.xml',     data: sheetXml },
        ];
        if (hasPng) {
            zipFiles.push({ name: 'xl/worksheets/_rels/sheet1.xml.rels', data: relsSheet });
            zipFiles.push({ name: 'xl/drawings/drawing1.xml',            data: drawingXml });
            zipFiles.push({ name: 'xl/drawings/_rels/drawing1.xml.rels', data: relsDrawing });
            zipFiles.push({ name: 'xl/media/image1.png',                 data: pngBytes });
        }
        const zipBytes = _buildZip(zipFiles);

        const blob = new Blob([zipBytes], {type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
        const url  = URL.createObjectURL(blob);
        const a    = document.createElement('a');
        a.href = url;
        a.download = 'aksiyon-plani-' + new Date().toISOString().slice(0,10) + '.xlsx';
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        setTimeout(() => URL.revokeObjectURL(url), 1000);
        showNotification('Excel indirildi (' + akcSay + ' sat\u0131r)' + (hasPng ? ' + Diyagram \u2713' : ''), 'success');
    } catch(err) {
        console.error('Export hata:', err);
        showNotification('Export hatas\u0131: ' + err.message, 'error');
    }
}
</script>

</body>
</html>

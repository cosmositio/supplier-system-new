<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uygunsuzluk Analizi</title>
    <link rel="icon" type="image/png" href="assets/favicon.png">
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-sankey@0.12.1/dist/chartjs-chart-sankey.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@sgratzl/chartjs-chart-boxplot@4.4.3/build/index.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-treemap@3.1.0/dist/chartjs-chart-treemap.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
        }
        .header {
            background: linear-gradient(135deg, #4a0a6b 0%, #7b2d8b 50%, #b94fc4 100%);
            color: white;
            padding: 20px 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
            flex-wrap: wrap;
        }
        .header-left { display: flex; flex-direction: column; gap: 4px; }
        .header h1 { font-size: 1.8em; display: flex; align-items: center; gap: 12px; }
        .header p { opacity: 0.85; font-size: 0.9em; margin-left: 4px; margin-top: 4px; }
        .back-btn {
            background: rgba(255,255,255,0.15);
            color: white;
            padding: 10px 18px;
            border-radius: 10px;
            text-decoration: none;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            transition: all 0.3s;
            font-size: 0.95em;
        }
        .back-btn:hover { background: rgba(255,255,255,0.25); transform: scale(1.04); }
        .page-nav { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
        .page-nav .back-btn { font-size: 0.85em; padding: 8px 14px; border-radius: 8px; }
        .page-nav .back-btn.active-page { background: rgba(255,255,255,0.35); font-weight: 700; }

        .container { max-width: 1600px; margin: 0 auto; padding: 24px 20px; }

        /* Upload Area */
        .upload-card {
            background: white;
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
            margin-bottom: 24px;
        }
        .upload-card h2 { font-size: 1.1em; color: #4a0a6b; margin-bottom: 16px; display: flex; align-items: center; gap: 8px; }
        .drop-zone {
            border: 2.5px dashed #b94fc4;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #fdf5ff;
        }
        .drop-zone:hover, .drop-zone.dragover { background: #f3e0ff; border-color: #7b2d8b; }
        .drop-zone .icon { font-size: 2.5em; margin-bottom: 12px; }
        .drop-zone p { color: #555; font-size: 1em; }
        .drop-zone .hint { color: #999; font-size: 0.82em; margin-top: 6px; }
        #fileInput { display: none; }

        /* Stats Row */
        .stats-row {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            margin-bottom: 24px;
        }
        .stat-card {
            flex: 1;
            min-width: 150px;
            background: white;
            border-radius: 14px;
            padding: 20px 24px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.07);
            text-align: center;
            border-top: 4px solid #b94fc4;
        }
        .stat-card .val { font-size: 2em; font-weight: 800; color: #4a0a6b; }
        .stat-card .lbl { font-size: 0.8em; color: #666; margin-top: 4px; }

        /* Filters */
        .filter-card {
            background: white;
            border-radius: 16px;
            padding: 20px 24px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
            margin-bottom: 24px;
        }
        .filter-card h2 { font-size: 1em; color: #4a0a6b; margin-bottom: 14px; display: flex; align-items: center; gap: 8px; }
        .filter-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: flex-end;
        }
        .filter-group { display: flex; flex-direction: column; gap: 5px; min-width: 150px; }
        .filter-group label { font-size: 0.78em; font-weight: 600; color: #555; }
        .filter-group select, .filter-group input {
            padding: 8px 10px;
            border: 1.5px solid #ddd;
            border-radius: 8px;
            font-size: 0.9em;
            background: #fafafa;
            cursor: pointer;
            outline: none;
            transition: border-color 0.2s;
        }
        .filter-group select:focus, .filter-group input:focus { border-color: #b94fc4; }
        /* Custom searchable dropdown */
        .sk-wrap { position:relative; min-width:150px; }
        .sk-trigger {
            display:flex; align-items:center; justify-content:space-between;
            padding:8px 10px; border:1.5px solid #ddd; border-radius:8px;
            font-size:.9em; background:#fafafa; cursor:pointer;
            user-select:none; transition:border-color .2s; white-space:nowrap;
            overflow:hidden; text-overflow:ellipsis; gap:6px;
        }
        .sk-trigger:hover, .sk-trigger.open { border-color:#b94fc4; }
        .sk-trigger .sk-arrow { font-size:.7em; flex-shrink:0; opacity:.6; transition:transform .2s; }
        .sk-trigger.open .sk-arrow { transform:rotate(180deg); }
        .sk-panel {
            display:none; position:absolute; z-index:9999; top:calc(100% + 4px); left:0;
            min-width:100%; background:#fff; border:1.5px solid #ccc;
            border-radius:8px; box-shadow:0 4px 16px rgba(0,0,0,.13);
            overflow:hidden;
        }
        .sk-panel.open { display:block; }
        .sk-search {
            width:100%; box-sizing:border-box;
            padding:8px 10px; border:none; border-bottom:1.5px solid #eee;
            font-size:.85em; outline:none; background:#f8f8f8;
        }
        .sk-search:focus { background:#fff; }
        .sk-list { max-height:210px; overflow-y:auto; }
        .sk-item {
            padding:7px 12px; font-size:.88em; cursor:pointer;
            white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
        }
        .sk-item:hover { background:#f3e8ff; color:#7c3aed; }
        .sk-item.selected { background:#ede9fe; color:#6d28d9; font-weight:700; }
        .sk-item.no-result { color:#aaa; font-style:italic; pointer-events:none; }
        .filter-btn {
            padding: 8px 18px;
            border: none;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }
        .btn-apply { background: linear-gradient(135deg, #7b2d8b, #b94fc4); color: white; }
        .btn-apply:hover { opacity: 0.9; }
        .btn-reset { background: #f0f0f0; color: #444; }
        .btn-reset:hover { background: #e0e0e0; }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0;
            margin-bottom: 0;
            background: white;
            border-radius: 12px 12px 0 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.07);
            overflow: hidden;
        }
        .tab-btn {
            flex: 1;
            padding: 14px;
            background: transparent;
            border: none;
            font-size: 0.95em;
            font-weight: 600;
            color: #888;
            cursor: pointer;
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }
        .tab-btn.active { color: #7b2d8b; border-bottom-color: #b94fc4; background: #fdf5ff; }
        .tab-btn:hover:not(.active) { background: #f8f8f8; color: #555; }

        /* Tab Panels */
        .tab-panel {
            background: white;
            border-radius: 0 0 16px 16px;
            padding: 24px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
            margin-bottom: 24px;
            display: none;
        }
        .tab-panel.active { display: block; }

        /* Pareto Chart */
        .chart-wrapper {
            position: relative;
            width: 100%;
            height: 420px;
        }
        .pareto-options {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 16px;
        }
        .pareto-options label { font-size: 0.82em; font-weight: 600; color: #555; }
        .pareto-options select {
            padding: 7px 10px;
            border: 1.5px solid #ddd;
            border-radius: 8px;
            font-size: 0.88em;
            background: #fafafa;
            outline: none;
            transition: border-color 0.2s;
        }
        .pareto-options select:focus { border-color: #b94fc4; }

        /* Data Table */
        .table-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 14px;
        }
        .table-search {
            padding: 8px 12px;
            border: 1.5px solid #ddd;
            border-radius: 8px;
            font-size: 0.9em;
            min-width: 220px;
            outline: none;
        }
        .table-search:focus { border-color: #b94fc4; }
        .table-info { font-size: 0.82em; color: #666; }
        .table-wrap {
            overflow-x: auto;
            border-radius: 10px;
            border: 1px solid #eee;
            max-height: 480px;
            overflow-y: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.82em;
            min-width: 900px;
        }
        thead th {
            background: linear-gradient(135deg, #4a0a6b, #7b2d8b);
            color: white;
            padding: 10px 12px;
            text-align: left;
            white-space: nowrap;
            position: sticky;
            top: 0;
            z-index: 2;
            cursor: pointer;
            user-select: none;
        }
        thead th:hover { background: linear-gradient(135deg, #5e1280, #9b3dab); }
        thead th .sort-icon { opacity: 0.6; margin-left: 4px; }
        tbody tr:nth-child(even) { background: #fdf5ff; }
        tbody tr:hover { background: #f0d9ff; }
        tbody td { padding: 8px 12px; border-bottom: 1px solid #eee; white-space: nowrap; vertical-align: middle; }
        .badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 0.78em;
            font-weight: 600;
        }
        .badge-red { background: #ffe0e0; color: #b71c1c; }
        .btn-8d-link { font-size:0.78em; padding:3px 8px; border:1px solid #1e3c72; border-radius:4px; background:#eef2ff; color:#1e3c72; cursor:pointer; white-space:nowrap; }
        .btn-8d-link:hover { background:#1e3c72; color:#fff; }
        .badge-orange { background: #fff3e0; color: #e65100; }
        .badge-blue { background: #e3f2fd; color: #0d47a1; }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 6px;
            margin-top: 14px;
            flex-wrap: wrap;
        }
        .page-btn {
            padding: 6px 12px;
            border: 1.5px solid #ddd;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }
        .page-btn:hover { border-color: #b94fc4; color: #7b2d8b; }
        .page-btn.active { background: #b94fc4; color: white; border-color: #b94fc4; }

        /* Hata Tipi Breakdown */
        .breakdown-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 14px;
            margin-top: 16px;
        }
        .breakdown-item {
            background: #fdf5ff;
            border-radius: 10px;
            padding: 14px 16px;
            border-left: 4px solid #b94fc4;
        }
        .breakdown-item .bi-name { font-weight: 700; color: #4a0a6b; font-size: 0.9em; margin-bottom: 6px; }
        .breakdown-item .bi-count { font-size: 1.3em; font-weight: 800; color: #7b2d8b; }
        .breakdown-item .bi-pct { font-size: 0.78em; color: #888; margin-top: 2px; }
        .bi-bar { height: 5px; border-radius: 3px; margin-top: 8px; background: #e0c0f0; }
        .bi-bar-fill { height: 5px; border-radius: 3px; background: linear-gradient(90deg, #b94fc4, #7b2d8b); }
        .breakdown-item.excluded { opacity: 0.38; border-left-color: #ccc; }
        .bi-header { display: flex; align-items: flex-start; justify-content: space-between; gap: 8px; }
        .bi-checkbox { width: 17px; height: 17px; accent-color: #b94fc4; cursor: pointer; flex-shrink: 0; margin-top: 1px; }
        .bi-fishbone-btn {
            margin-top: 10px; width: 100%; padding: 5px 8px;
            font-size: 0.73em; font-weight: 600;
            background: #e8f5f1; color: #1a6b5a;
            border: 1px solid #a8d8cc; border-radius: 6px;
            cursor: pointer; transition: background 0.2s, color 0.2s;
            display: flex; align-items: center; justify-content: center; gap: 5px;
        }
        .bi-fishbone-btn:hover { background: #1a6b5a; color: white; border-color: #1a6b5a; }
        .breakdown-item.excluded .bi-fishbone-btn { display: none; }
        /* Akşiyon badge — breakdown kartta */
        .bi-aksiyon-badge {
            display: inline-flex; align-items: center; gap: 3px;
            background: #d1fae5; color: #065f46; font-size: 0.68em;
            font-weight: 700; padding: 2px 6px; border-radius: 10px;
            margin-left: 5px; vertical-align: middle; white-space: nowrap;
        }
        /* Çoklu seçim */
        .breakdown-item.selected-for-multi {
            border-left-color: #1a6b5a; outline: 2px solid #2ea88a;
            background: #e8f5f1;
        }
        .multi-analyze-bar {
            position: fixed; bottom: 0; left: 0; right: 0; z-index: 9999;
            background: linear-gradient(135deg, #1a6b5a, #2ea88a);
            color: white; padding: 12px 24px;
            display: flex; align-items: center; justify-content: space-between;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.2); font-weight: 600;
        }
        .multi-analyze-bar button {
            background: white; color: #1a6b5a; border: none;
            border-radius: 8px; padding: 8px 18px; font-weight: 700;
            cursor: pointer; font-size: 0.9em;
        }
        .multi-analyze-bar button:hover { background: #d1fae5; }
        .multi-cancel-btn { background: transparent !important; color: white !important; font-size: 0.82em !important; opacity: 0.8; }
        .multi-cancel-btn:hover { opacity: 1 !important; }
        /* Tedarikçi analiz butonu */
        .cari-fishbone-btn {
            margin-top: 6px; width: 100%; padding: 5px 8px;
            font-size: 0.73em; font-weight: 600;
            background: #e8f5f1; color: #1a6b5a;
            border: 1px solid #a8d8cc; border-radius: 6px;
            cursor: pointer; transition: background 0.2s, color 0.2s;
            display: none; align-items: center; justify-content: center; gap: 5px;
        }
        .cari-fishbone-btn:hover { background: #1a6b5a; color: white; border-color: #1a6b5a; }

        /* Custom Cari Dropdown */
        .cari-dropdown { position: relative; }
        .cari-selected {
            border: 1px solid #d0b0e0; border-radius: 8px; padding: 7px 12px;
            background: white; cursor: pointer; font-size: 0.88em; color: #333;
            display: flex; justify-content: space-between; align-items: center;
            min-height: 36px; gap: 6px; user-select: none;
        }
        .cari-selected:hover { border-color: #b94fc4; }
        .cari-selected .cari-sel-text { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; }
        .cari-panel {
            position: absolute; top: calc(100% + 4px); left: 0; width: 440px;
            background: white; border: 1px solid #d0b0e0; border-radius: 10px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.15); z-index: 9999; overflow: hidden;
        }
        .cari-panel-header { padding: 8px 10px; border-bottom: 1px solid #eee; display: flex; align-items: center; gap: 6px; }
        .cari-search-input {
            flex: 1; border: 1px solid #e0c0f0; border-radius: 6px; padding: 6px 10px;
            font-size: 0.85em; outline: none;
        }
        .cari-search-input:focus { border-color: #b94fc4; }
        .cari-legend { font-size: 0.72em; color: #888; white-space: nowrap; }
        .cari-list { max-height: 300px; overflow-y: auto; }
        .cari-list-item {
            display: flex; align-items: center; gap: 8px; padding: 7px 12px;
            cursor: pointer; font-size: 0.83em; color: #333; transition: background 0.12s;
        }
        .cari-list-item:hover { background: #fdf5ff; }
        .cari-list-item.selected { background: #f0e0ff; }
        .cari-list-item.selected .cari-item-name { font-weight: 700; color: #4a0a6b; }
        .cari-musteri-chk { width: 14px; height: 14px; accent-color: #e07000; cursor: pointer; flex-shrink: 0; }
        .cari-item-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .cari-badge { font-size: 0.70em; background: #e07000; color: white; border-radius: 4px; padding: 1px 5px; flex-shrink: 0; }
        .cari-clear-btn { font-size: 0.75em; border: none; background: #f3e0ff; color: #7b2d8b; border-radius: 5px; padding: 2px 8px; cursor: pointer; white-space: nowrap; }

        /* Custom Tespit Yeri Multi-Select */
        .tespit-dropdown { position: relative; }
        .tespit-selected {
            border: 1px solid #d0b0e0; border-radius: 8px; padding: 7px 12px;
            background: white; cursor: pointer; font-size: 0.88em; color: #333;
            display: flex; justify-content: space-between; align-items: center;
            min-height: 36px; gap: 6px; user-select: none;
        }
        .tespit-selected:hover { border-color: #b94fc4; }
        .tespit-sel-text { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; }
        .tespit-panel {
            position: absolute; top: calc(100% + 4px); left: 0; min-width: 220px; width: max-content; max-width: 320px;
            background: white; border: 1px solid #d0b0e0; border-radius: 10px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.15); z-index: 9999; overflow: hidden;
        }
        .tespit-panel-header { padding: 6px 10px; border-bottom: 1px solid #eee; display: flex; align-items: center; justify-content: space-between; }
        .tespit-list { max-height: 260px; overflow-y: auto; }
        .tespit-list-item {
            display: flex; align-items: center; gap: 8px; padding: 7px 12px;
            cursor: pointer; font-size: 0.84em; color: #333; transition: background 0.12s;
        }
        .tespit-list-item:hover { background: #fdf5ff; }
        .tespit-list-item.ty-selected { background: #f0e0ff; font-weight: 600; color: #4a0a6b; }
        .tespit-chk { width: 15px; height: 15px; accent-color: #b94fc4; cursor: pointer; flex-shrink: 0; }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #aaa;
        }
        .empty-state .icon { font-size: 3em; margin-bottom: 12px; }
        .empty-state p { font-size: 1em; }

        /* Export btn */
        .export-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
            background: linear-gradient(135deg, #7b2d8b, #b94fc4);
            color: white;
        }
        .export-btn:hover { opacity: 0.9; }

        .section-title {
            font-size: 1em;
            font-weight: 700;
            color: #4a0a6b;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Loading */
        .loading-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.35);
            z-index: 9999;
            align-items: center;
            justify-content: center;
        }
        .loading-overlay.show { display: flex; }
        .loading-box {
            background: white;
            border-radius: 16px;
            padding: 36px 48px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }
        .spinner {
            width: 48px; height: 48px;
            border: 5px solid #f0d9ff;
            border-top-color: #b94fc4;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 16px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 24px; right: 24px;
            background: #4a0a6b;
            color: white;
            padding: 14px 22px;
            border-radius: 10px;
            font-size: 0.9em;
            font-weight: 600;
            z-index: 10000;
            box-shadow: 0 4px 16px rgba(0,0,0,0.25);
            transform: translateY(80px);
            opacity: 0;
            transition: all 0.35s;
        }
        .toast.show { transform: translateY(0); opacity: 1; }
        .toast.error { background: #b71c1c; }
        .toast.success { background: #2d5a3d; }

        /* ── Snapshot Modal ── */
        #uaSnapModal { display:none; position:fixed; inset:0; z-index:9999; background:rgba(10,15,30,.55); align-items:center; justify-content:center; }
        #uaSnapModal.open { display:flex; }

        /* ── Filter Save Modal ── */
        #uaFiltreModal { display:none; position:fixed; inset:0; z-index:9999; background:rgba(10,15,30,.55); align-items:center; justify-content:center; }
        #uaFiltreModal.open { display:flex; }
        #uaFiltreBox { background:#fff; border-radius:14px; padding:28px 28px 20px; width:min(620px,96vw); max-height:82vh; overflow-y:auto; box-shadow:0 20px 60px rgba(0,0,0,.25); font-family:inherit; }
        #uaFiltreBox h3 { margin:0 0 18px; font-size:1rem; color:#1e2535; }
        .filtre-save-row { display:flex; align-items:center; gap:12px; padding:11px 0; border-bottom:1px solid #f1f5f9; }
        .filtre-save-row:last-child { border-bottom:none; }
        .filtre-save-info { flex:1; }
        .filtre-save-name { font-size:.88rem; font-weight:700; color:#1e2535; margin-bottom:3px; }
        .filtre-save-meta { font-size:.73rem; color:#94a3b8; }
        .filtre-save-btns { display:flex; gap:6px; flex-shrink:0; }
        .btn-filtre-kaydet  { background:linear-gradient(135deg,#059669,#10b981); color:#fff; border:none; border-radius:7px; padding:6px 13px; cursor:pointer; font-size:.75rem; font-weight:700; }
        .btn-filtre-listele { background:linear-gradient(135deg,#0369a1,#0ea5e9); color:#fff; border:none; border-radius:7px; padding:6px 13px; cursor:pointer; font-size:.75rem; font-weight:700; }
        #uaSnapBox { background:#fff; border-radius:14px; padding:28px 28px 20px; width:min(640px,96vw); max-height:82vh; overflow-y:auto; box-shadow:0 20px 60px rgba(0,0,0,.25); font-family:inherit; }
        #uaSnapBox h3 { margin:0 0 18px; font-size:1rem; color:#1e2535; }
        .ua-snap-row { display:flex; align-items:center; gap:12px; padding:12px 0; border-bottom:1px solid #f1f5f9; }
        .ua-snap-row:last-child { border-bottom:none; }
        .ua-snap-info { flex:1; }
        .ua-snap-name { font-size:.88rem; font-weight:700; color:#1e2535; margin-bottom:3px; }
        .ua-snap-meta { font-size:.73rem; color:#94a3b8; }
        .ua-snap-btns { display:flex; gap:6px; flex-shrink:0; }
        .ua-snap-btn  { border:none; border-radius:6px; padding:5px 11px; cursor:pointer; font-size:.75rem; font-weight:600; line-height:1; }
        .ua-snap-load { background:#dbeafe; color:#1e40af; }
        .ua-snap-del  { background:#fee2e2; color:#b91c1c; }

        @media(max-width: 700px) {
            .header { padding: 16px 18px; }
            .header h1 { font-size: 1.3em; }
            .container { padding: 14px 10px; }
        }

        /* ── COHORT TAB ── */
        .cohort-controls {
            display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end;
            padding:14px 16px; background:#f0fdf4; border-radius:10px;
            border:1px solid #bbf7d0; margin-bottom:18px;
        }
        .cohort-ctrl-group { display:flex; flex-direction:column; gap:4px; }
        .cohort-ctrl-group label { font-size:.75rem; font-weight:600; color:#166534; }
        .cohort-ctrl-group select, .cohort-ctrl-group input {
            padding:6px 10px; border:1.5px solid #86efac; border-radius:7px;
            font-size:.88rem; background:#fff; color:#333; outline:none;
        }
        .cohort-ctrl-group select:focus, .cohort-ctrl-group input:focus { border-color:#16a34a; }
        .cohort-table-wrap { overflow-x:auto; overflow-y:auto; max-height:640px; }
        .cohort-table {
            border-collapse:separate; border-spacing:3px;
            font-size:.82em; min-width:max-content;
        }
        .cohort-table th {
            background:#166534; color:#fff; padding:8px 12px;
            font-weight:700; position:sticky; top:0; z-index:5;
            white-space:nowrap; letter-spacing:.3px;
        }
        .cohort-table th:first-child { left:0; z-index:7; min-width:160px; max-width:260px; }
        .cohort-table th:nth-child(2) { left:0; z-index:6; min-width:80px; }
        .cohort-table td:first-child {
            background:#f0fdf4; font-weight:700; color:#166534;
            position:sticky; left:0; z-index:2;
            padding:6px 12px; border-right:2px solid #bbf7d0;
            white-space:nowrap; max-width:260px;
            overflow:hidden; text-overflow:ellipsis;
        }
        .cohort-cell {
            width:68px; height:36px; border-radius:7px;
            text-align:center; vertical-align:middle;
            font-weight:700; font-size:.88em;
            cursor:help; transition:transform .1s, filter .1s;
        }
        .cohort-cell:hover { transform:scale(1.14); filter:brightness(1.08); z-index:10; position:relative; }
        .cohort-cell.c0 { background:#f0fdf4; color:#86efac; font-weight:400; font-size:.75em; }
        .cohort-cell.c1 { background:#bbf7d0; color:#166534; }
        .cohort-cell.c2 { background:#4ade80; color:#14532d; }
        .cohort-cell.c3 { background:#16a34a; color:#fff; }
        .cohort-cell.c4 { background:#166534; color:#fff; }
        .cohort-cell.high { background:#dc2626; color:#fff; }
        .cohort-insight {
            margin-top:16px; padding:12px 18px;
            background:#f0fdf4; border-left:4px solid #16a34a;
            border-radius:0 8px 8px 0; font-size:.88em; color:#166534; line-height:1.7;
        }
        .cohort-mode-bar { display:flex; gap:6px; margin-bottom:10px; flex-wrap:wrap; }
        .cohort-mode-btn {
            padding:5px 14px; border-radius:20px; border:2px solid #16a34a;
            background:#fff; color:#166534; font-size:.82em; font-weight:700;
            cursor:pointer; transition:all .2s;
        }
        .cohort-mode-btn.active { background:#16a34a; color:#fff; }

        /* ── FUNNEL TAB ── */
        .funnel-wrap { padding:16px; }
        .funnel-controls {
            display:flex; flex-wrap:wrap; gap:12px; align-items:flex-end;
            padding:14px 16px; background:#fdf4ff; border-radius:10px;
            border:1px solid #e9d5ff; margin-bottom:18px;
        }
        .funnel-ctrl-group { display:flex; flex-direction:column; gap:4px; }
        .funnel-ctrl-group label { font-size:.75rem; font-weight:600; color:#6b21a8; }
        .funnel-ctrl-group select, .funnel-ctrl-group input {
            padding:6px 10px; border:1.5px solid #d8b4fe; border-radius:7px;
            font-size:.88rem; background:#fff; color:#333; outline:none;
        }
        .funnel-ctrl-group select:focus, .funnel-ctrl-group input:focus { border-color:#a855f7; }
        .funnel-svg-wrap { width:100%; overflow-x:auto; display:flex; justify-content:center; padding:8px 0; min-height:120px; }
        .funnel-legend { display:flex; flex-wrap:wrap; gap:10px 18px; margin-top:16px; justify-content:center; padding:10px 16px; background:#faf5ff; border-radius:10px; border:1px solid #e9d5ff; }
        .funnel-legend-item { display:flex; align-items:center; gap:6px; font-size:.82em; color:#3b0764; }
        .funnel-legend-dot { width:14px; height:14px; border-radius:4px; flex-shrink:0; }
        .funnel-insight {
            background:linear-gradient(135deg,#f3e5f5,#ede7f6);
            border-left:4px solid #b94fc4; border-radius:0 8px 8px 0;
            padding:11px 16px; font-size:.85em; color:#4a0a6b;
            margin-top:14px; line-height:1.7;
        }

        /* ── POLAR AREA TAB ── */
        .polar-wrap { padding:16px; }
        .polar-controls {
            display:flex; flex-wrap:wrap; gap:12px; align-items:flex-end;
            padding:14px 16px; background:#fdf4ff; border-radius:10px;
            border:1px solid #e9d5ff; margin-bottom:18px;
        }
        .polar-ctrl-group { display:flex; flex-direction:column; gap:4px; }
        .polar-ctrl-group label { font-size:.75rem; font-weight:600; color:#6b21a8; }
        .polar-ctrl-group select, .polar-ctrl-group input {
            padding:6px 10px; border:1.5px solid #d8b4fe; border-radius:7px;
            font-size:.88rem; background:#fff; color:#333; outline:none;
        }
        .polar-ctrl-group select:focus, .polar-ctrl-group input:focus { border-color:#a855f7; }
        .polar-chart-area { display:flex; flex-wrap:nowrap; gap:18px; align-items:flex-start; overflow-x:auto; }
        /* Selector panel (left) */
        .polar-sel-panel {
            flex:0 0 210px; border:1.5px solid #e9d5ff; border-radius:12px;
            background:#fff; overflow:hidden; box-shadow:0 2px 8px rgba(168,85,247,.08);
        }
        .polar-sel-title {
            display:flex; align-items:center; justify-content:space-between;
            padding:9px 12px; background:#f5f0ff;
            border-bottom:1px solid #e9d5ff; font-size:.8rem; font-weight:700; color:#4a0a6b;
        }
        .polar-sel-actions { display:flex; gap:5px; }
        .polar-sel-btn {
            padding:2px 8px; border-radius:10px; border:1.5px solid #d8b4fe;
            background:#fff; color:#6b21a8; font-size:.72rem; font-weight:700; cursor:pointer;
        }
        .polar-sel-btn:hover { background:#f3e8ff; }
        .polar-sel-list { max-height:540px; overflow-y:auto; padding:5px 0; }
        .polar-sel-item {
            display:flex; align-items:center; gap:8px; padding:6px 12px;
            cursor:pointer; font-size:.8rem; color:#333; transition:background .12s;
        }
        .polar-sel-item:hover { background:#fdf4ff; }
        .polar-sel-item.psi-active { background:#f3e8ff; }
        .polar-sel-item input[type=checkbox] { width:14px; height:14px; accent-color:#a855f7; flex-shrink:0; }
        .polar-sel-dot { width:11px; height:11px; border-radius:50%; flex-shrink:0; }
        /* Canvas (centre) */
        .polar-canvas-wrap { flex:1 1 560px; min-width:380px; max-width:700px; height:580px; position:relative; }
        .polar-canvas-wrap canvas { width:100% !important; height:100% !important; }
        /* Stats panel (right) */
        .polar-stats-panel {
            flex:0 0 240px; display:flex; flex-direction:column; gap:8px;
            max-height:580px; overflow-y:auto;
        }
        .polar-stat-card {
            background:#fff; border:1.5px solid #e9d5ff; border-radius:12px;
            padding:9px 12px; display:flex; align-items:center; gap:9px;
            box-shadow:0 2px 8px rgba(168,85,247,.06); cursor:default;
        }
        .polar-stat-dot { width:14px; height:14px; border-radius:50%; flex-shrink:0; }
        .polar-stat-info { display:flex; flex-direction:column; gap:2px; min-width:0; }
        .polar-stat-name { font-size:.76rem; font-weight:700; color:#4a0a6b; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
        .polar-stat-val  { font-size:.86rem; font-weight:800; color:#2e1065; }
        .polar-stat-pct  { font-size:.74rem; color:#a855f7; font-weight:600; }
        .polar-insight {
            background:linear-gradient(135deg,#f3e5f5,#ede7f6);
            border-left:4px solid #b94fc4; border-radius:0 8px 8px 0;
            padding:11px 16px; font-size:.85em; color:#4a0a6b;
            margin-top:14px; line-height:1.7;
        }

        /* ── CHORD TAB ── */
        .chord-wrap { padding:16px; }
        .chord-controls {
            display:flex; flex-wrap:wrap; gap:12px; align-items:flex-end;
            padding:14px 16px; background:#fdf4ff; border-radius:10px;
            border:1px solid #e9d5ff; margin-bottom:18px;
        }
        .chord-ctrl-group { display:flex; flex-direction:column; gap:4px; }
        .chord-ctrl-group label { font-size:.75rem; font-weight:600; color:#6b21a8; }
        .chord-ctrl-group select, .chord-ctrl-group input {
            padding:6px 10px; border:1.5px solid #d8b4fe; border-radius:7px;
            font-size:.88rem; background:#fff; color:#333; outline:none;
        }
        .chord-ctrl-group select:focus { border-color:#a855f7; }
        .chord-body { display:flex; flex-wrap:wrap; gap:20px; align-items:flex-start; justify-content:center; }
        .chord-svg-wrap { flex:1 1 560px; max-width:680px; overflow:visible; }
        .chord-legend-wrap {
            flex:0 0 220px; display:flex; flex-direction:column; gap:6px;
            max-height:620px; overflow-y:auto;
        }
        .chord-leg-item { display:flex; align-items:center; gap:7px; font-size:.8rem; color:#3b0764; padding:4px 0; }
        .chord-leg-dot { width:14px; height:14px; border-radius:4px; flex-shrink:0; }
        .chord-insight {
            background:linear-gradient(135deg,#f3e5f5,#ede7f6);
            border-left:4px solid #b94fc4; border-radius:0 8px 8px 0;
            padding:11px 16px; font-size:.85em; color:#4a0a6b;
            margin-top:14px; line-height:1.7;
        }
        .chord-tooltip {
            position:fixed; background:rgba(30,5,50,.92); color:#fff;
            padding:8px 12px; border-radius:8px; font-size:.8rem; line-height:1.6;
            pointer-events:none; z-index:9999; display:none;
            box-shadow:0 4px 18px rgba(0,0,0,.35);
        }

        /* ── BEESWARM TAB ── */
        .bsw-wrap { padding:16px; }
        .bsw-controls {
            display:flex; flex-wrap:wrap; gap:12px; align-items:flex-end;
            padding:14px 16px; background:#fdf4ff; border-radius:10px;
            border:1px solid #e9d5ff; margin-bottom:18px;
        }
        .bsw-ctrl-group { display:flex; flex-direction:column; gap:4px; }
        .bsw-ctrl-group label { font-size:.75rem; font-weight:600; color:#6b21a8; }
        .bsw-ctrl-group select, .bsw-ctrl-group input {
            padding:6px 10px; border:1.5px solid #d8b4fe; border-radius:7px;
            font-size:.88rem; background:#fff; color:#333; outline:none;
        }
        .bsw-ctrl-group select:focus, .bsw-ctrl-group input:focus { border-color:#a855f7; }
        .bsw-body { display:flex; gap:14px; align-items:flex-start; }
        .bsw-sel-panel {
            flex:0 0 195px; border:1.5px solid #e9d5ff; border-radius:12px;
            background:#fff; overflow:hidden; box-shadow:0 2px 8px rgba(168,85,247,.08);
        }
        .bsw-sel-title {
            display:flex; align-items:center; justify-content:space-between;
            padding:9px 12px; background:#f5f0ff;
            border-bottom:1px solid #e9d5ff; font-size:.8rem; font-weight:700; color:#4a0a6b;
        }
        .bsw-sel-actions { display:flex; gap:5px; }
        .bsw-sel-btn {
            padding:2px 8px; border-radius:10px; border:1.5px solid #d8b4fe;
            background:#fff; color:#6b21a8; font-size:.72rem; font-weight:700; cursor:pointer;
        }
        .bsw-sel-btn:hover { background:#f3e8ff; }
        .bsw-sel-list { max-height:520px; overflow-y:auto; padding:5px 0; }
        .bsw-sel-item {
            display:flex; align-items:center; gap:7px; padding:5px 10px;
            cursor:pointer; font-size:.78rem; color:#333; transition:background .12s;
        }
        .bsw-sel-item:hover { background:#fdf4ff; }
        .bsw-sel-item.bsi-active { background:#f3e8ff; }
        .bsw-sel-item input[type=checkbox] { width:13px; height:13px; accent-color:#a855f7; flex-shrink:0; }
        .bsw-sel-dot { width:10px; height:10px; border-radius:50%; flex-shrink:0; }
        .bsw-chart-wrap { flex:1 1 0; min-width:0; overflow-x:auto; }
        .bsw-svg-wrap { width:100%; }
        .bsw-insight {
            background:linear-gradient(135deg,#f3e5f5,#ede7f6);
            border-left:4px solid #b94fc4; border-radius:0 8px 8px 0;
            padding:11px 16px; font-size:.85em; color:#4a0a6b;
            margin-top:14px; line-height:1.7;
        }
        .bsw-tooltip {
            position:fixed; background:rgba(30,5,50,.92); color:#fff;
            padding:8px 12px; border-radius:8px; font-size:.8rem; line-height:1.6;
            pointer-events:none; z-index:9999; display:none;
            box-shadow:0 4px 18px rgba(0,0,0,.35);
        }

        /* ── RADAR TAB ── */
        .radar-header { margin-bottom:14px; }
        .radar-controls {
            display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end;
            padding:14px 16px; background:#faf5ff; border-radius:10px;
            border:1px solid #e9d5ff;
        }
        .radar-ctrl-group { display:flex; flex-direction:column; gap:4px; }
        .radar-ctrl-group label { font-size:.75rem; font-weight:600; color:#6b21a8; }
        .radar-ctrl-group select {
            padding:6px 10px; border:1.5px solid #d8b4fe; border-radius:7px;
            font-size:.84rem; background:#fff; outline:none; color:#3b0764;
        }
        .radar-ctrl-group select:focus { border-color:#a855f7; }
        .radar-selector-panel {
            width:260px; flex-shrink:0; border:1.5px solid #e9d5ff;
            border-radius:12px; background:#fff; overflow:hidden;
            box-shadow:0 2px 8px rgba(168,85,247,.08);
        }
        .radar-sel-title {
            display:flex; align-items:center; justify-content:space-between;
            padding:10px 14px; background:#f5f0ff;
            border-bottom:1px solid #e9d5ff; font-size:.82rem; font-weight:700; color:#4a0a6b;
        }
        .radar-sel-title small { font-size:.7rem; color:#a78bfa; font-weight:400; }
        .radar-group-list { max-height:440px; overflow-y:auto; padding:6px 0; }
        .radar-group-item {
            display:flex; align-items:center; gap:9px; padding:7px 14px;
            cursor:pointer; font-size:.82rem; color:#333; transition:background .12s;
        }
        .radar-group-item:hover { background:#fdf4ff; }
        .radar-group-item.rgi-selected { background:#f3e8ff; }
        .radar-group-item input[type=checkbox] { width:15px; height:15px; accent-color:#a855f7; flex-shrink:0; }
        .radar-group-item .rgi-label { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
        .radar-group-item .rgi-val { font-size:.73rem; color:#94a3b8; flex-shrink:0; }
        .radar-group-item.rgi-selected .rgi-label { font-weight:700; color:#6b21a8; }
        .radar-sel-btn {
            padding:5px 12px; border:1.5px solid #d8b4fe; border-radius:6px;
            background:#fff; color:#7c3aed; font-size:.75rem; font-weight:600;
            cursor:pointer; transition:all .15s;
        }
        .radar-sel-btn:hover { background:#ede9fe; }
        .radar-sel-btn-clear { border-color:#fca5a5; color:#dc2626; }
        .radar-sel-btn-clear:hover { background:#fee2e2; }
        .radar-chart-wrap { position:relative; width:100%; height:480px; }
        .radar-color-dot {
            width:12px; height:12px; border-radius:50%; flex-shrink:0;
        }

        /* ── HEATMAP TAB ── */
        .hm-controls {
            display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end;
            padding:14px 16px; background:#f0f8ff; border-radius:10px;
            border:1px solid #bae6fd;
        }
        .hm-ctrl-group { display:flex; flex-direction:column; gap:4px; }
        .hm-ctrl-group label { font-size:.75rem; font-weight:600; color:#0369a1; }
        .hm-ctrl-group select {
            padding:6px 10px; border:1.5px solid #7dd3fc; border-radius:7px;
            font-size:.84rem; background:#fff; outline:none; color:#0c4a6e;
        }
        .hm-ctrl-group select:focus { border-color:#0ea5e9; }
        .hm-legend-row {
            display:flex; align-items:center; gap:10px; margin-top:14px;
        }
        .hm-legend-bar {
            flex:1; max-width:220px; height:12px; border-radius:6px;
        }
        .hm-legend-max { font-size:.72rem; color:#64748b; }
        /* The actual heatmap table */
        .hm-table { border-collapse:collapse; font-size:.75rem; }
        .hm-table th {
            padding:6px 10px; white-space:nowrap; max-width:160px;
            overflow:hidden; text-overflow:ellipsis;
            background:#f8fafc; position:sticky; top:0; z-index:2;
            font-weight:700; color:#334155; border:1px solid #e2e8f0;
        }
        .hm-table th.hm-row-hdr {
            left:0; z-index:3; text-align:left; min-width:130px; max-width:200px;
        }
        .hm-table td {
            padding:5px 8px; border:1px solid #e2e8f0; text-align:center;
            white-space:nowrap; transition:opacity .15s; cursor:default;
            min-width:56px;
        }
        .hm-table td:first-child {
            position:sticky; left:0; z-index:1; background:#f8fafc !important;
            font-weight:700; color:#334155; text-align:left; max-width:200px;
            overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
        }
        .hm-table td:hover, .hm-table tr:hover td { filter:brightness(.9); }
        .hm-cell-val { font-size:.72rem; font-weight:700; }
        .hm-total-row td { background:#f1f5f9 !important; font-weight:700; color:#334155; }
        .hm-total-col { background:#f1f5f9 !important; font-weight:700; color:#334155; }
        /* Heatmap picker panels — always visible side-by-side */
        .hm-pick-panels-row { display:flex; gap:14px; margin-top:14px; flex-wrap:wrap; }
        .hm-pick-panel { flex:1; min-width:220px; background:#f0f8ff; border:1.5px solid #7dd3fc; border-radius:10px; padding:10px 14px; display:flex; flex-direction:column; }
        .hm-pp-header { display:flex; align-items:center; gap:7px; flex-wrap:wrap; margin-bottom:8px; }
        .hm-pp-header b { font-size:.82rem; color:#0369a1; }
        .hm-pp-header small { font-size:.73rem; color:#888; background:#dbeafe; padding:1px 8px; border-radius:20px; }
        .hm-pp-header input { padding:4px 9px; border:1.5px solid #7dd3fc; border-radius:7px; font-size:.79rem; flex:1; min-width:110px; outline:none; background:#fff; }
        .hm-pp-header button { padding:3px 9px; border:1.5px solid #bae6fd; border-radius:7px; background:#fff; color:#0369a1; font-size:.76rem; cursor:pointer; }
        .hm-pp-header button:hover { background:#e0f4ff; }
        .hm-pick-list { display:flex; flex-direction:column; gap:2px; max-height:200px; overflow-y:auto; padding:2px 0; }
        .hm-pick-item { display:flex; align-items:center; gap:8px; padding:5px 9px; border-radius:7px; border:none; background:transparent; font-size:.79rem; cursor:pointer; user-select:none; color:#334155; transition:background .12s; }
        .hm-pick-item:hover { background:#e0f4ff; }
        .hm-pick-item.hpi-sel { background:#dbeafe; color:#0369a1; font-weight:600; }
        .hm-pick-item input[type=checkbox] { width:14px; height:14px; accent-color:#0369a1; flex-shrink:0; pointer-events:none; }
        .hm-pick-item .hm-pick-val { font-size:.71rem; color:#94a3b8; margin-left:auto; flex-shrink:0; }
        /* Bubble Chart */
        .bb-controls { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end; padding:14px 16px; background:#f5f3ff; border-radius:10px; border:1px solid #ddd6fe; }
        .bb-ctrl-group { display:flex; flex-direction:column; gap:4px; }
        .bb-ctrl-group label { font-size:.75rem; font-weight:600; color:#5b21b6; }
        .bb-ctrl-group select { padding:6px 10px; border:1.5px solid #c4b5fd; border-radius:7px; font-size:.84rem; background:#fff; outline:none; color:#3b0764; }
        .bb-ctrl-group select:focus { border-color:#7c3aed; }
        .bb-chart-area { position:relative; height:480px; margin-top:18px; }
        .bb-insight { margin-top:14px; padding:12px 16px; background:#f3e8ff; border-radius:10px; font-size:0.83em; color:#4a0a6b; border-left:4px solid #9333ea; }
        .bb-pick-panel { margin-top:14px; background:#faf5ff; border:1px solid #e9d5ff; border-radius:10px; padding:10px 14px; }
        .bb-pick-header { display:flex; align-items:center; gap:8px; margin-bottom:8px; flex-wrap:wrap; }
        .bb-pick-header label { font-size:.75rem; font-weight:700; color:#6d28d9; white-space:nowrap; }
        .bb-pick-search { flex:1; min-width:120px; padding:5px 9px; border:1.5px solid #c4b5fd; border-radius:7px; font-size:.8rem; outline:none; }
        .bb-pick-search:focus { border-color:#7c3aed; }
        .bb-pick-hint { font-size:.72rem; color:#7c3aed; font-weight:600; white-space:nowrap; }
        .bb-pick-list { display:flex; flex-wrap:wrap; gap:4px; max-height:180px; overflow-y:auto; padding-top:2px; }
        .bb-pick-item { display:flex; align-items:center; gap:5px; padding:4px 10px; border-radius:20px; border:1.5px solid #ddd6fe; background:#fff; font-size:.79rem; cursor:pointer; user-select:none; color:#4c1d95; transition:background .12s,border-color .12s; }
        .bb-pick-item:hover { background:#ede9fe; border-color:#a78bfa; }
        .bb-pick-item.bpi-sel { background:#7c3aed; border-color:#6d28d9; color:#fff; font-weight:600; }
        .bb-pick-item input[type=checkbox] { width:13px; height:13px; accent-color:#7c3aed; flex-shrink:0; pointer-events:none; }
        .bb-pick-val { font-size:.7rem; opacity:.72; margin-left:2px; }
        /* Scatter Plot */
        .sc-controls { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end; padding:14px 16px; background:#fff7ed; border-radius:10px; border:1px solid #fed7aa; }
        .sc-ctrl-group { display:flex; flex-direction:column; gap:4px; }
        .sc-ctrl-group label { font-size:.75rem; font-weight:600; color:#c2410c; }
        .sc-ctrl-group select { padding:6px 10px; border:1.5px solid #fdba74; border-radius:7px; font-size:.84rem; background:#fff; outline:none; color:#7c2d12; }
        .sc-ctrl-group select:focus { border-color:#ea580c; }
        .sc-chart-area { position:relative; height:500px; margin-top:18px; }
        .sc-insight { margin-top:14px; padding:12px 16px; background:#ffedd5; border-radius:10px; font-size:0.83em; color:#7c2d12; border-left:4px solid #ea580c; }
        /* Treemap */
        .tm-controls { display:flex; flex-wrap:wrap; gap:12px; align-items:flex-end; margin-bottom:14px; background:#f0f9ff; border:1px solid #bae6fd; border-radius:10px; padding:12px 16px; }
        .tm-ctrl-group { display:flex; flex-direction:column; gap:4px; min-width:130px; }
        .tm-ctrl-group label { font-size:.73rem; font-weight:700; color:#0369a1; }
        .tm-ctrl-group select { padding:6px 10px; border:1.5px solid #7dd3fc; border-radius:7px; font-size:.83rem; outline:none; background:#fff; }
        .tm-ctrl-group select:focus { border-color:#0369a1; }
        .tm-chart-area { width:100%; height:480px; }
        .tm-insight { margin-top:14px; padding:12px 16px; background:#e0f2fe; border-radius:10px; font-size:0.83em; color:#0c4a6e; border-left:4px solid #0369a1; }
        .tm-pick-panel { margin-top:14px; background:#f0f9ff; border:1px solid #bae6fd; border-radius:10px; padding:10px 14px; }
        .tm-pick-header { display:flex; align-items:center; gap:8px; margin-bottom:8px; flex-wrap:wrap; }
        .tm-pick-header label { font-size:.75rem; font-weight:700; color:#0369a1; white-space:nowrap; }
        .tm-pick-search { flex:1; min-width:120px; padding:5px 9px; border:1.5px solid #7dd3fc; border-radius:7px; font-size:.8rem; outline:none; }
        .tm-pick-search:focus { border-color:#0369a1; }
        .tm-pick-hint { font-size:.72rem; color:#0369a1; font-weight:600; white-space:nowrap; }
        .tm-pick-list { display:flex; flex-wrap:wrap; gap:4px; max-height:160px; overflow-y:auto; padding-top:2px; }
        .tm-pick-item { display:flex; align-items:center; gap:5px; padding:4px 10px; border-radius:20px; border:1.5px solid #bae6fd; background:#fff; font-size:.79rem; cursor:pointer; user-select:none; color:#0c4a6e; transition:background .12s,border-color .12s; }
        .tm-pick-item:hover { background:#e0f2fe; border-color:#38bdf8; }
        .tm-pick-item.tmpi-sel { background:#0369a1; border-color:#075985; color:#fff; font-weight:600; }
        .tm-pick-item input[type=checkbox] { width:13px; height:13px; accent-color:#0369a1; flex-shrink:0; pointer-events:none; }
        .tm-pick-val { font-size:.7rem; opacity:.72; margin-left:2px; }

        /* Calendar Heatmap */
        .cal-controls { display:flex; flex-wrap:wrap; gap:12px; align-items:flex-end; margin-bottom:14px; background:#fafafa; border:1px solid #e2e8f0; border-radius:10px; padding:12px 16px; }
        .cal-ctrl-group { display:flex; flex-direction:column; gap:4px; min-width:120px; }
        .cal-ctrl-group label { font-size:.73rem; font-weight:700; color:#475569; }
        .cal-ctrl-group select { padding:6px 10px; border:1.5px solid #cbd5e1; border-radius:7px; font-size:.83rem; outline:none; background:#fff; }
        .cal-ctrl-group select:focus { border-color:#6366f1; }
        #calContainer { overflow-x:auto; padding-bottom:8px; }
        #calSvg { display:block; min-width:600px; }
        .cal-insight { margin-top:14px; padding:12px 16px; background:#eef2ff; border-radius:10px; font-size:0.83em; color:#312e81; border-left:4px solid #6366f1; }
        .cal-legend { display:flex; align-items:center; gap:5px; margin-top:12px; font-size:.76rem; color:#64748b; flex-wrap:wrap; }
        .cal-legend-box { width:14px; height:14px; border-radius:3px; flex-shrink:0; }
        .sc-pick-panel { margin-top:14px; background:#fff7ed; border:1px solid #fed7aa; border-radius:10px; padding:10px 14px; }
        .sc-pick-header { display:flex; align-items:center; gap:8px; margin-bottom:8px; flex-wrap:wrap; }
        .sc-pick-header label { font-size:.75rem; font-weight:700; color:#c2410c; white-space:nowrap; }
        .sc-pick-search { flex:1; min-width:120px; padding:5px 9px; border:1.5px solid #fdba74; border-radius:7px; font-size:.8rem; outline:none; }
        .sc-pick-search:focus { border-color:#ea580c; }
        .sc-pick-hint { font-size:.72rem; color:#ea580c; font-weight:600; white-space:nowrap; }
        .sc-pick-list { display:flex; flex-wrap:wrap; gap:4px; max-height:160px; overflow-y:auto; padding-top:2px; }
        .sc-pick-item { display:flex; align-items:center; gap:5px; padding:4px 10px; border-radius:20px; border:1.5px solid #fed7aa; background:#fff; font-size:.79rem; cursor:pointer; user-select:none; color:#7c2d12; transition:background .12s,border-color .12s; }
        .sc-pick-item:hover { background:#ffedd5; border-color:#fb923c; }
        .sc-pick-item.scpi-sel { background:#ea580c; border-color:#c2410c; color:#fff; font-weight:600; }
        .sc-pick-item input[type=checkbox] { width:13px; height:13px; accent-color:#ea580c; flex-shrink:0; pointer-events:none; }
        .sc-pick-dot { width:9px; height:9px; border-radius:50%; flex-shrink:0; }
        .sc-pick-val { font-size:.7rem; opacity:.72; margin-left:2px; }
        /* Box Plot */
        .bp-controls { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end; padding:14px 16px; background:#f0fdfa; border-radius:10px; border:1px solid #99f6e4; }
        .bp-ctrl-group { display:flex; flex-direction:column; gap:4px; }
        .bp-ctrl-group label { font-size:.75rem; font-weight:600; color:#0f766e; }
        .bp-ctrl-group select { padding:6px 10px; border:1.5px solid #5eead4; border-radius:7px; font-size:.84rem; background:#fff; outline:none; color:#134e4a; }
        .bp-ctrl-group select:focus { border-color:#0d9488; }
        .bp-chart-area { position:relative; margin-top:18px; }
        .bp-insight { margin-top:14px; padding:12px 16px; background:#ccfbf1; border-radius:10px; font-size:0.83em; color:#134e4a; border-left:4px solid #0d9488; }
        .bp-pick-panel { margin-top:14px; background:#f0fdfa; border:1px solid #99f6e4; border-radius:10px; padding:10px 14px; }
        .bp-pick-header { display:flex; align-items:center; gap:8px; margin-bottom:8px; flex-wrap:wrap; }
        .bp-pick-header label { font-size:.75rem; font-weight:700; color:#0f766e; white-space:nowrap; }
        .bp-pick-search { flex:1; min-width:120px; padding:5px 9px; border:1.5px solid #5eead4; border-radius:7px; font-size:.8rem; outline:none; }
        .bp-pick-search:focus { border-color:#0d9488; }
        .bp-pick-hint { font-size:.72rem; color:#0d9488; font-weight:600; white-space:nowrap; }
        .bp-pick-list { display:flex; flex-wrap:wrap; gap:4px; max-height:160px; overflow-y:auto; padding-top:2px; }
        .bp-pick-item { display:flex; align-items:center; gap:5px; padding:4px 10px; border-radius:20px; border:1.5px solid #99f6e4; background:#fff; font-size:.79rem; cursor:pointer; user-select:none; color:#134e4a; transition:background .12s,border-color .12s; }
        .bp-pick-item:hover { background:#ccfbf1; border-color:#2dd4bf; }
        .bp-pick-item.bppi-sel { background:#0d9488; border-color:#0f766e; color:#fff; font-weight:600; }
        .bp-pick-item input[type=checkbox] { width:13px; height:13px; accent-color:#0d9488; flex-shrink:0; pointer-events:none; }
        .bp-pick-val { font-size:.7rem; opacity:.72; margin-left:2px; }
        .bp-stats-table { margin-top:14px; width:100%; border-collapse:collapse; font-size:.8rem; }
        .bp-stats-table th { background:#0d9488; color:#fff; padding:6px 10px; text-align:left; font-weight:600; }
        .bp-stats-table td { padding:5px 10px; border-bottom:1px solid #e2e8f0; }
        .bp-stats-table tr:hover td { background:#f0fdfa; }
        /* Sankey Diyagramı */
        .sk-controls { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end; padding:14px 16px; background:#fffbeb; border-radius:10px; border:1px solid #fde68a; }
        .sk-ctrl-group { display:flex; flex-direction:column; gap:4px; }
        .sk-ctrl-group label { font-size:.75rem; font-weight:600; color:#92400e; }
        .sk-ctrl-group select { padding:6px 10px; border:1.5px solid #fbbf24; border-radius:7px; font-size:.84rem; background:#fff; outline:none; color:#78350f; }
        .sk-ctrl-group select:focus { border-color:#d97706; }
        .sk-chart-area { position:relative; margin-top:18px; }
        .sk-insight { margin-top:14px; padding:12px 16px; background:#fef3c7; border-radius:10px; font-size:0.83em; color:#78350f; border-left:4px solid #d97706; }
        .sk-legend { display:flex; flex-wrap:wrap; gap:8px; margin-top:12px; }
        .sk-legend-item { display:flex; align-items:center; gap:5px; font-size:.78rem; color:#444; }
        .sk-legend-dot { width:12px; height:12px; border-radius:50%; flex-shrink:0; }
        /* Grouped/Stacked Bar */
        .gb-controls { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end; padding:14px 16px; background:#f0fdf4; border-radius:10px; border:1px solid #bbf7d0; }
        .gb-ctrl-group { display:flex; flex-direction:column; gap:4px; }
        .gb-ctrl-group label { font-size:.75rem; font-weight:600; color:#15803d; }
        .gb-ctrl-group select, .gb-ctrl-group input[type=range] { padding:6px 10px; border:1.5px solid #86efac; border-radius:7px; font-size:.84rem; background:#fff; outline:none; color:#14532d; }
        .gb-ctrl-group select:focus { border-color:#16a34a; }
        .gb-chart-area { position:relative; height:500px; margin-top:18px; }
        .gb-insight { margin-top:14px; padding:12px 16px; background:#dcfce7; border-radius:10px; font-size:0.83em; color:#14532d; border-left:4px solid #16a34a; }

        /* ── CHART PICKER MODAL ── */
        #chartPickerModal { position:fixed; inset:0; background:rgba(0,0,0,.55); z-index:9999; display:flex; align-items:center; justify-content:center; opacity:0; pointer-events:none; transition:opacity .2s; }
        #chartPickerModal.open { opacity:1; pointer-events:all; }
        .cpm-box { background:#fff; border-radius:16px; width:min(620px,95vw); max-height:88vh; display:flex; flex-direction:column; box-shadow:0 8px 40px rgba(0,0,0,.28); overflow:hidden; }
        .cpm-head { display:flex; align-items:center; justify-content:space-between; padding:14px 20px; background:linear-gradient(135deg,#1e3a8a,#2563eb); color:#fff; flex-shrink:0; }
        .cpm-head h3 { font-size:.95rem; font-weight:700; margin:0; }
        .cpm-head .cpm-close { background:none; border:none; color:#fff; font-size:1.4rem; cursor:pointer; line-height:1; padding:0 4px; border-radius:4px; }
        .cpm-head .cpm-close:hover { background:rgba(255,255,255,.2); }
        .cpm-all-row { display:flex; gap:8px; padding:6px 18px; border-bottom:1px solid #f1f5f9; flex-shrink:0; }
        .cpm-all-btn { padding:3px 12px; border-radius:8px; border:1.5px solid #d1d5db; background:#fff; font-size:.76rem; font-weight:700; cursor:pointer; color:#374151; }
        .cpm-all-btn:hover { background:#f8fafc; }
        .cpm-body { overflow-y:auto; padding:12px 16px; display:grid; grid-template-columns:1fr 1fr; gap:8px; }
        .cpm-item { display:flex; align-items:center; gap:8px; padding:9px 12px; border:1.5px solid #e2e8f0; border-radius:10px; cursor:pointer; user-select:none; transition:all .12s; }
        .cpm-item:hover { border-color:#93c5fd; background:#f8fbff; }
        .cpm-item.cpm-selected { border-color:#2563eb; background:#dbeafe; }
        .cpm-item input[type=checkbox] { width:14px; height:14px; accent-color:#2563eb; cursor:pointer; flex-shrink:0; pointer-events:none; }
        .cpm-lbl { font-size:.82rem; font-weight:600; color:#1e2535; }
        .cpm-foot { padding:12px 20px; border-top:1px solid #e2e8f0; display:flex; justify-content:space-between; align-items:center; gap:10px; flex-shrink:0; }
        .cpm-sel-count { font-size:.78rem; color:#64748b; }
        .cpm-btns { display:flex; gap:8px; }
        .cpm-btn { padding:8px 18px; border-radius:9px; border:none; font-size:.85rem; font-weight:700; cursor:pointer; }
        .cpm-btn-cancel { background:#f1f5f9; color:#64748b; }
        .cpm-btn-cancel:hover { background:#e2e8f0; }

        /* Pareto bar selection chips */
        #paretoSelChips { margin-top:10px; padding:8px 12px; background:#fdf5ff; border-radius:8px; border:1px dashed #d0a0e0; min-height:36px; display:flex; flex-wrap:wrap; align-items:center; gap:6px; }
        .psc-hint { font-size:0.82em; color:#a070c0; font-style:italic; }
        .psc-chip { display:inline-flex; align-items:center; gap:4px; background:#7b2d8b; color:#fff; border-radius:20px; padding:3px 10px 3px 12px; font-size:0.82em; font-weight:600; }
        .psc-chip button { background:none; border:none; color:#fff; cursor:pointer; font-size:1em; line-height:1; padding:0 0 0 2px; opacity:.75; }
        .psc-chip button:hover { opacity:1; }
        .psc-clear { background:#f1e8f7; color:#7b2d8b; border:1px solid #d0a0e0; border-radius:20px; padding:3px 12px; font-size:0.82em; font-weight:600; cursor:pointer; margin-left:auto; }
        .psc-clear:hover { background:#e8d0f5; }
        .psc-label { font-size:0.8em; color:#7b2d8b; font-weight:700; white-space:nowrap; }
        .cpm-btn-ok { background:linear-gradient(135deg,#1e3a8a,#2563eb); color:#fff; }
        .cpm-btn-ok:hover { filter:brightness(1.1); }
        .cpm-btn-ok:disabled { opacity:.45; cursor:not-allowed; }
    </style>
</head>
<body>

<div class="header">
    <div class="header-left">
        <h1>🔍 Uygunsuzluk Analizi</h1>
        <p>Pareto Analizi · Hata Tipi Dağılımı</p>
    </div>
    <div class="page-nav">
        <a href="index.html"              class="back-btn">🏠 Ana Sayfa</a>
        <a href="coa-arsiv.html"          class="back-btn">📄 COA</a>
        <a href="balik-kilcigi.html"      class="back-btn">🐟 Balık Kılçığı</a>
        <a href="8d-rapor.html"        class="back-btn">📋 8D</a>
    </div>
</div>

<div class="loading-overlay" id="loadingOverlay">
    <div class="loading-box">
        <div class="spinner"></div>
        <p style="color:#4a0a6b;font-weight:700;">Excel Yükleniyor...</p>
    </div>
</div>

<div class="toast" id="toast"></div>

<div class="container">

    <!-- Upload -->
    <div class="upload-card">
        <h2>📂 Excel Dosyası Yükle</h2>
        <div class="drop-zone" id="dropZone" onclick="document.getElementById('fileInput').click()">
            <div class="icon">📊</div>
            <p><strong>Excel dosyanızı sürükleyip bırakın veya tıklayın</strong></p>
            <p class="hint">Desteklenen formatlar: .xlsx, .xls</p>
        </div>
        <input type="file" id="fileInput" accept=".xlsx,.xls">
        <div id="fileInfo" style="margin-top:12px;font-size:0.88em;color:#555;display:none;"></div>
    </div>

    <!-- Stats -->
    <div class="stats-row" id="statsRow" style="display:none;">
        <div class="stat-card">
            <div class="val" id="statTotal">0</div>
            <div class="lbl">Toplam Kayıt</div>
        </div>
        <div class="stat-card" style="border-top-color:#e65100;">
            <div class="val" id="statHataliMiktar">0</div>
            <div class="lbl">Toplam Hatalı Miktar</div>
        </div>
        <div class="stat-card" style="border-top-color:#0d47a1;">
            <div class="val" id="statHataTipi">0</div>
            <div class="lbl">Farklı Hata Tipi</div>
        </div>
        <div class="stat-card" style="border-top-color:#2d5a3d;">
            <div class="val" id="statCari">0</div>
            <div class="lbl">Farklı Tedarikçi</div>
        </div>
        <div class="stat-card" style="border-top-color:#b71c1c;">
            <div class="val" id="statPPM">0</div>
            <div class="lbl">PPM (Hatalı/Parti Hacmi)</div>
        </div>
    </div>

    <!-- Filters -->
    <div class="filter-card" id="filterCard" style="display:none;">
        <h2>🔎 Filtreler</h2>
        <div class="filter-grid">
            <div class="filter-group">
                <label>Tarih Başlangıç</label>
                <input type="date" id="fDateStart">
            </div>
            <div class="filter-group">
                <label>Tarih Bitiş</label>
                <input type="date" id="fDateEnd">
            </div>
            <div class="filter-group">
                <label>Tipi</label>
                <select id="fTipi"><option value="">Tümü</option></select>
            </div>
            <div class="filter-group">
                <label>Hata Tipi</label>
                <select id="fHataTipi"><option value="">Tümü</option></select>
            </div>
            <div class="filter-group">
                <label>Hata Kaynağı</label>
                <select id="fHataKaynagi"><option value="">Tümü</option></select>
            </div>
            <div class="filter-group">
                <label>Uygunsuzluk Türü</label>
                <select id="fUygunsuzlukTuru"><option value="">Tümü</option></select>
            </div>
            <div class="filter-group" style="position:relative;">
                <label>Tespit Yeri</label>
                <div class="tespit-dropdown" id="tespitDropdown">
                    <div class="tespit-selected" onclick="toggleTespitDropdown()">
                        <span class="tespit-sel-text" id="tespitSelectedText">Tümü</span>
                        <span style="color:#b94fc4;font-size:0.85em;">&#9660;</span>
                    </div>
                    <div class="tespit-panel" id="tespitPanel" style="display:none;">
                        <div class="tespit-panel-header">
                            <span style="font-size:0.78em;color:#888;">Çoklu seçim yapılabilir</span>
                            <button onclick="resetTespitYeri()" style="font-size:0.75em;border:none;background:#f3e0ff;color:#7b2d8b;border-radius:5px;padding:2px 8px;cursor:pointer;">Temizle</button>
                        </div>
                        <div class="tespit-list" id="tespitList"></div>
                    </div>
                </div>
            </div>
            <div class="filter-group">
                <label>Makine</label>
                <select id="fMakine"><option value="">Tümü</option></select>
            </div>
            <div class="filter-group">
                <label>Cari Tipi</label>
                <select id="fCariTip">
                    <option value="">Tümü</option>
                    <option value="musteri">★ Müşteri</option>
                    <option value="tedarikci">Tedarikçi</option>
                </select>
            </div>
            <div class="filter-group" style="position:relative;">
                <label>Cari (Tedarikçi / Müşteri)</label>
                <div class="cari-dropdown" id="cariDropdown">
                    <div class="cari-selected" onclick="toggleCariDropdown()">
                        <span class="cari-sel-text" id="cariSelectedText">Tümü</span>
                        <span style="color:#b94fc4;font-size:0.85em;">&#9660;</span>
                    </div>
                    <div class="cari-panel" id="cariPanel" style="display:none;">
                        <div class="cari-panel-header">
                            <input class="cari-search-input" id="cariSearch" placeholder="🔍 Cari ara..." oninput="filterCariList()" autocomplete="off">
                            <span class="cari-legend">★ = Müşteri</span>
                            <button class="cari-clear-btn" onclick="selectCari('')">Temizle</button>
                        </div>
                        <div class="cari-list" id="cariList"></div>
                    </div>
                </div>
                <button id="cariAnalyzeBtn" class="cari-fishbone-btn" onclick="openFishboneTedarikci()">🐟 Bu Tedarikçiyi Analiz Et</button>
            </div>
            <div class="filter-group">
                <label>Stok Kodu</label>
                <div class="sk-wrap" id="skWrap">
                    <div class="sk-trigger" id="skTrigger" onclick="_skToggle()">
                        <span id="skLabel">Tümü</span>
                        <span class="sk-arrow">▼</span>
                    </div>
                    <div class="sk-panel" id="skPanel">
                        <input class="sk-search" id="skSearch" type="text" placeholder="🔍 Ara..."
                            autocomplete="off" oninput="_skFilter(this.value)">
                        <div class="sk-list" id="skList"></div>
                    </div>
                </div>
                <!-- hidden select keeps value for existing JS -->
                <select id="fStokKodu" style="display:none"><option value="">Tümü</option></select>
            </div>
            <div class="filter-group" style="flex-direction: row; gap: 8px; align-items: flex-end; flex-wrap:wrap;">
                <button class="filter-btn btn-apply" onclick="applyFilters()">✔ Uygula</button>
                <button class="filter-btn btn-reset" onclick="resetFilters()">↺ Sıfırla</button>
                <button class="btn-filtre-kaydet" onclick="saveCurrentFilter()" title="Mevcut filtreyi kaydet">💾 Filtreyi Kaydet</button>
                <button class="btn-filtre-listele" onclick="openSavedFiltersModal()" title="Kayıtlı filtreleri listele">📂 Kayıtlı Filtreler</button>
            </div>
        </div>
    </div>

    <!-- Tabs -->
    <div id="mainContent" style="display:none;">
        <div class="tabs" style="flex-wrap:wrap;gap:4px;">
            <button class="tab-btn active" onclick="switchTab('pareto')">📊 Pareto Analizi</button>
            <button class="tab-btn" onclick="switchTab('breakdown')">📋 Hata Tipi Dağılımı</button>
            <button class="tab-btn" onclick="switchTab('table')">📄 Veri Tablosu</button>
            <button class="tab-btn" onclick="switchTab('radar')">🕷️ Radar Analizi</button>
            <button class="tab-btn" onclick="switchTab('heatmap')">🌡️ Isı Haritası</button>
            <button class="tab-btn" onclick="switchTab('bubble')">🫧 Kabarcık Grafiği</button>
            <button class="tab-btn" onclick="switchTab('bar')">📦 Gruplu / Yigilmis Bar</button>
            <button class="tab-btn" onclick="switchTab('sankey')">🌊 Sankey Diyagramı</button>
            <button class="tab-btn" onclick="switchTab('boxplot')">📦 Kutu Grafik (Box Plot)</button>
            <button class="tab-btn" onclick="switchTab('scatter')">📀 Dağılım (Scatter)</button>
            <button class="tab-btn" onclick="switchTab('treemap')">🗺️ Treemap</button>
            <button class="tab-btn" onclick="switchTab('calendar')">🔥 Takvim Isı Haritası</button>
            <button class="tab-btn" onclick="switchTab('cohort')">🔄 Cohort Analizi</button>
            <button class="tab-btn" onclick="switchTab('funnel')">🔺 Funnel Grafiği</button>
            <button class="tab-btn" onclick="switchTab('polar')">🌐 Polar Alan</button>
            <button class="tab-btn" onclick="switchTab('chord')">🕷️ Chord Diyagramı</button>
            <button class="tab-btn" onclick="switchTab('beeswarm')">🟣 Beeswarm / Dot Plot</button>
            <button class="tab-btn" onclick="openChartPickerModal()" style="margin-left:auto;background:linear-gradient(135deg,#1e3a8a,#2563eb);color:#fff;font-weight:700;border:none;" title="Filtrelenmiş veriyi ve seçilen grafikleri kapsamlı rapora ekler">📑 Kapsamlı Rapora Ekle</button>
            <button class="tab-btn" onclick="temizleKapsamliRapor()" style="background:linear-gradient(135deg,#7f1d1d,#dc2626);color:#fff;font-weight:700;border:none;" title="Birikmiş rapor verisini sil ve yeniden başla">🗑 Raporu Sıfırla</button>
            <button class="tab-btn" onclick="uaOpenSnapshotModal()" style="background:linear-gradient(135deg,#4f46e5,#7c3aed);color:#fff;font-weight:700;border:none;" title="Kayıtlı kapsamlı raporları listele">📁 Kayıtlı Raporlar</button>
        </div>

        <!-- Pareto Tab -->
        <div class="tab-panel active" id="tab-pareto">
            <div class="pareto-options">
                <div>
                    <label>Analiz Kriteri: </label>
                    <select id="paretoMetric" onchange="renderPareto()">
                        <option value="hataliMiktar">Hatalı Miktar</option>
                        <option value="kayitSayisi">Kayıt Sayısı</option>
                    </select>
                </div>
                <div>
                    <label>Göster (Top): </label>
                    <select id="paretoTop" onchange="renderPareto()">
                        <option value="10">İlk 10</option>
                        <option value="15" selected>İlk 15</option>
                        <option value="20">İlk 20</option>
                        <option value="999">Tümü</option>
                    </select>
                </div>
                <div>
                    <label>Eşik: </label>
                    <select id="paretoThreshold" onchange="renderPareto()">
                        <option value="60">60/40</option>
                        <option value="70">70/30</option>
                        <option value="80" selected>80/20</option>
                        <option value="90">90/10</option>
                    </select>
                </div>
                <div>
                    <label>Grupla: </label>
                    <select id="paretoGroup" onchange="renderPareto()">
                        <option value="hataTipi">Hata Tipi</option>
                        <option value="hataKaynagi">Hata Kaynağı</option>
                        <option value="uygunsuzlukTuru">Uygunsuzluk Türü</option>
                        <option value="tespitYeri">Tespit Yeri</option>
                        <option value="cariAdi">Cari Adı</option>
                        <option value="stokAdi">Stok Adı</option>
                    </select>
                </div>
                <div style="display:flex;align-items:center;gap:6px;">
                    <input type="checkbox" id="paretoGroupOthers" onchange="renderPareto()" style="width:16px;height:16px;accent-color:#b94fc4;cursor:pointer;">
                    <label for="paretoGroupOthers" style="cursor:pointer;font-size:0.88em;color:#4a0a6b;white-space:nowrap;">Eşiküstü 'Diğer'</label>
                </div>
                <div style="display:flex;align-items:center;gap:6px;">
                    <input type="checkbox" id="paretoShowLabels" onchange="renderPareto()" style="width:16px;height:16px;accent-color:#b94fc4;cursor:pointer;">
                    <label for="paretoShowLabels" style="cursor:pointer;font-size:0.88em;color:#4a0a6b;white-space:nowrap;">Değerleri Göster</label>
                </div>
                <div style="display:flex;align-items:center;gap:6px;position:relative;">
                    <label style="font-size:0.88em;color:#4a0a6b;white-space:nowrap;">Renk:</label>
                    <select id="paretoColorScheme" onchange="onParetoColorSchemeChange()" style="font-size:0.82em;border:1px solid #d0b0e0;border-radius:6px;padding:3px 6px;color:#4a0a6b;cursor:pointer;">
                        <option value="default">Mor Gradient</option>
                        <option value="blue">Mavi Gradient</option>
                        <option value="green">Yeşil Gradient</option>
                        <option value="orange">Turuncu Gradient</option>
                        <option value="red">Kırmızı Gradient</option>
                        <option value="rainbow">Gökkuaşağı</option>
                        <option value="custom">Özel Renk...</option>
                    </select>
                    <div id="paretoCustomColors" style="display:none;align-items:center;gap:4px;">
                        <input type="color" id="paretoColor1" value="#b94fc4" title="Başlangıç rengi" onchange="renderPareto()" style="width:28px;height:28px;border:none;padding:0;cursor:pointer;border-radius:4px;">
                        <span style="font-size:0.8em;color:#888;">&#8594;</span>
                        <input type="color" id="paretoColor2" value="#3b82f6" title="Bitiş rengi" onchange="renderPareto()" style="width:28px;height:28px;border:none;padding:0;cursor:pointer;border-radius:4px;">
                    </div>
                </div>
                <button class="export-btn" onclick="downloadChartPNG()">⬇ PNG İndir</button>
            </div>
            <div class="chart-wrapper">
                <canvas id="paretoChart"></canvas>
            </div>
            <div id="paretoInsight" style="margin-top:14px;padding:12px 16px;background:#fdf5ff;border-radius:10px;font-size:0.85em;color:#4a0a6b;border-left:4px solid #b94fc4;"></div>
            <div id="paretoSelChips"><span class="psc-hint">💡 Bara tıklayarak seçin — seçilenler kapsamlı rapora dahil edilir. Seçim yoksa tüm filtreli veri gider.</span></div>
        </div>

        <!-- Breakdown Tab -->
        <div class="tab-panel" id="tab-breakdown">
            <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:12px;flex-wrap:wrap;">
                <div class="section-title" style="margin-bottom:0;">📋 Hata Tipi Bazında Hatalı Miktar Dağılımı</div>
                <div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
                    <button onclick="toggleBreakdownAll()" style="background:#7b2d8b;color:#fff;border:none;border-radius:8px;padding:6px 14px;font-size:0.82em;font-weight:600;cursor:pointer;">✅ Tümünü Seç</button>
                    <button onclick="toggleBreakdownClear()" style="background:#f1f5f9;color:#64748b;border:1px solid #cbd5e1;border-radius:8px;padding:6px 14px;font-size:0.82em;font-weight:600;cursor:pointer;">🔲 Tümünü Temizle</button>
                    <button id="multiAnalyzeToggleBtn" onclick="toggleMultiAnalyze()" style="background:#e8f5f1;color:#1a6b5a;border:1px solid #a8d8cc;border-radius:8px;padding:6px 14px;font-size:0.82em;font-weight:600;cursor:pointer;">📊 Çoklu Analiz</button>
                </div>
            </div>
            <div class="breakdown-grid" id="breakdownGrid"></div>
        </div>

        <!-- Table Tab -->
        <div class="tab-panel" id="tab-table">
            <div class="table-controls">
                <input type="text" class="table-search" id="tableSearch" placeholder="🔍 Tabloda ara..." oninput="onTableSearch()">
                <div style="display:flex;gap:8px;align-items:center;">
                    <span class="table-info" id="tableInfo"></span>
                    <button class="export-btn" onclick="exportTableExcel()">⬇ Excel İndir</button>
                </div>
            </div>
            <div class="table-wrap">
                <table id="dataTable">
                    <thead id="tableHead"></thead>
                    <tbody id="tableBody"></tbody>
                </table>
            </div>
            <div class="pagination" id="pagination"></div>
        </div>

        <!-- Radar Tab -->
        <div class="tab-panel" id="tab-radar">
            <div class="radar-header">
                <div style="font-size:1.05rem;font-weight:800;color:#4a0a6b;display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
                    🕷️ Radar / Örümcek Karşılaştırma Analizi
                    <span style="font-size:.75rem;font-weight:400;color:#888;background:#f3e8ff;padding:2px 10px;border-radius:20px;">Her eksen bir boyutu, her çizgi bir grubu temsil eder</span>
                    <span id="radarDateInfo" style="font-size:.76rem;font-weight:600;color:#0369a1;background:#e0f2fe;padding:3px 12px;border-radius:20px;display:none;">📅 </span>
                </div>
            </div>
            <div class="radar-controls">
                <div class="radar-ctrl-group">
                    <label>Karşılaştırma Kriteri</label>
                    <select id="radarGroupBy" onchange="radarBuildSelector()">
                        <option value="cariAdi">Cari Adı (Tedarikçi/Müşteri)</option>
                        <option value="hataTipi">Hata Tipi</option>
                        <option value="hataKaynagi">Hata Kaynağı</option>
                        <option value="tespitYeri">Tespit Yeri</option>
                        <option value="stokAdi">Stok Adı</option>
                    </select>
                </div>
                <div class="radar-ctrl-group">
                    <label>Eksen Boyutu</label>
                    <select id="radarAxesBy" onchange="radarBuildSelector()">
                        <option value="hataTipi">Hata Tipi</option>
                        <option value="hataKaynagi">Hata Kaynağı</option>
                        <option value="tespitYeri">Tespit Yeri</option>
                        <option value="stokAdi">Stok Adı</option>
                        <option value="uygunsuzlukTuru">Uygunsuzluk Türü</option>
                    </select>
                </div>
                <div class="radar-ctrl-group">
                    <label>Metrik</label>
                    <select id="radarMetric" onchange="renderRadar()">
                        <option value="hataliMiktar">Hatalı Miktar</option>
                        <option value="kayitSayisi">Kayıt Sayısı</option>
                    </select>
                </div>
                <div class="radar-ctrl-group">
                    <label>Max Eksen (Top)</label>
                    <select id="radarAxesTop" onchange="radarBuildSelector()">
                        <option value="5">5</option>
                        <option value="7" selected>7</option>
                        <option value="10">10</option>
                        <option value="12">12</option>
                    </select>
                </div>
                <div class="radar-ctrl-group">
                    <label>Normalize</label>
                    <select id="radarNorm" onchange="renderRadar()">
                        <option value="1">Evet — 0 ile 100 arası</option>
                        <option value="0">Hayır — Gerçek Değer</option>
                    </select>
                </div>
                <button class="export-btn" onclick="downloadRadarPNG()">⬇ PNG İndir</button>
            </div>

            <div style="display:flex;gap:20px;flex-wrap:wrap;margin-top:18px;">
                <!-- Group selector panel -->
                <div class="radar-selector-panel">
                    <div class="radar-sel-title">
                        <span>📋 Karşılaştırılacak Gruplar</span>
                        <small id="radarSelHint">Seçilecek: 2–10</small>
                    </div>
                    <div style="padding:6px 10px;border-bottom:1px solid #f1f5f9;">
                        <input id="radarGroupSearch" type="text" placeholder="🔍 Ara..." oninput="_radarFilterList()"
                            style="width:100%;padding:5px 9px;border:1.5px solid #d8b4fe;border-radius:7px;font-size:.81rem;outline:none;">
                    </div>
                    <div id="radarGroupList" class="radar-group-list"></div>
                    <div style="padding:8px 12px;border-top:1px solid #f1f5f9;display:flex;gap:8px;">
                        <button class="radar-sel-btn" onclick="radarSelectAll()">Tümü</button>
                        <button class="radar-sel-btn" onclick="radarSelectTop5()">Top 5</button>
                        <button class="radar-sel-btn radar-sel-btn-clear" onclick="radarClearAll()">Temizle</button>
                    </div>
                </div>

                <!-- Chart area -->
                <div style="flex:1;min-width:300px;">
                    <div id="radarNoData" style="display:none;text-align:center;padding:60px 20px;color:#aaa;">
                        <div style="font-size:2.5em;margin-bottom:12px;">🕷️</div>
                        <p>En az 2 grup ve en az 2 eksen değeri seçin.</p>
                    </div>
                    <div class="radar-chart-wrap" id="radarChartWrap">
                        <canvas id="radarChart"></canvas>
                    </div>
                </div>
            </div>

            <div id="radarInsight" style="margin-top:16px;padding:12px 16px;background:#fdf5ff;border-radius:10px;font-size:0.83em;color:#4a0a6b;border-left:4px solid #b94fc4;display:none;"></div>
        </div>

        <!-- Heatmap Tab -->
        <div class="tab-panel" id="tab-heatmap">
            <div style="font-size:1.05rem;font-weight:800;color:#0f4c81;display:flex;align-items:center;gap:8px;margin-bottom:14px;">
                🌡️ Isı Haritası
                <span style="font-size:.75rem;font-weight:400;color:#888;background:#e0f0ff;padding:2px 10px;border-radius:20px;">Satır × Sütun kesişimindeki yoğunluğu renk ile gösterir</span>
            </div>
            <div class="hm-controls">
                <div class="hm-ctrl-group">
                    <label>Satır (Y ekseni)</label>
                    <select id="hmRowBy" onchange="_hmResetFilter('row');_hmResetFilter('col');renderHeatmap()">
                        <option value="cariAdi">Cari Adı</option>
                        <option value="hataTipi">Hata Tipi</option>
                        <option value="hataKaynagi">Hata Kaynağı</option>
                        <option value="tespitYeri">Tespit Yeri</option>
                        <option value="stokAdi">Stok Adı</option>
                        <option value="uygunsuzlukTuru">Uyg. Türü</option>
                        <option value="tipi">Tipi</option>
                        <option value="makine">Makine</option>
                        <option value="cariTipi">Cari Tipi</option>
                    </select>
                </div>
                <div class="hm-ctrl-group">
                    <label>Sütun (X ekseni)</label>
                    <select id="hmColBy" onchange="_hmResetFilter('row');_hmResetFilter('col');renderHeatmap()">
                        <option value="hataTipi">Hata Tipi</option>
                        <option value="hataKaynagi">Hata Kaynağı</option>
                        <option value="tespitYeri">Tespit Yeri</option>
                        <option value="cariAdi">Cari Adı</option>
                        <option value="stokAdi">Stok Adı</option>
                        <option value="uygunsuzlukTuru">Uyg. Türü</option>
                        <option value="tipi">Tipi</option>
                        <option value="makine">Makine</option>
                        <option value="cariTipi">Cari Tipi</option>
                    </select>
                </div>
                <div class="hm-ctrl-group">
                    <label>Metrik</label>
                    <select id="hmMetric" onchange="renderHeatmap()">
                        <option value="hataliMiktar">Hatalı Miktar</option>
                        <option value="kayitSayisi">Kayıt Sayısı</option>
                    </select>
                </div>
                <div class="hm-ctrl-group">
                    <label>Başlangıç Satır</label>
                    <select id="hmTopRow" onchange="_hmResetFilter('row');renderHeatmap()">
                        <option value="10">10</option>
                        <option value="15" selected>15</option>
                        <option value="20">20</option>
                        <option value="30">30</option>
                        <option value="99999">Tümü</option>
                    </select>
                </div>
                <div class="hm-ctrl-group">
                    <label>Başlangıç Sütun</label>
                    <select id="hmTopCol" onchange="_hmResetFilter('col');renderHeatmap()">
                        <option value="8">8</option>
                        <option value="12" selected>12</option>
                        <option value="16">16</option>
                        <option value="20">20</option>
                        <option value="99999">Tümü</option>
                    </select>
                </div>
                <div class="hm-ctrl-group">
                    <label>Renk Skalası</label>
                    <select id="hmColorScale" onchange="renderHeatmap()">
                        <option value="blue">Mavi (soğuk→sıcak)</option>
                        <option value="red">Kırmızı</option>
                        <option value="green">Yeşil</option>
                        <option value="purple">Mor</option>
                        <option value="orange">Turuncu</option>
                    </select>
                </div>
                <div class="hm-ctrl-group">
                    <label>Değer Göster</label>
                    <select id="hmShowVal" onchange="renderHeatmap()">
                        <option value="1">Evet</option>
                        <option value="0">Hayır</option>
                    </select>
                </div>
            </div>

            <!-- Picker panels row — always visible -->
            <div class="hm-pick-panels-row">
                <div class="hm-pick-panel" id="hmRowPanel">
                    <div class="hm-pp-header">
                        <b>↕ Satır (Y)</b>
                        <small id="hmRowPickHint"></small>
                        <input id="hmRowSearch" type="text" placeholder="🔍 Ara..." oninput="_hmFilterPanel('row')">
                        <button onclick="_hmPickAll('row')">Tümü</button>
                        <button onclick="_hmPickClear('row')">Temizle</button>
                    </div>
                    <div id="hmRowList" class="hm-pick-list"></div>
                </div>
                <div class="hm-pick-panel" id="hmColPanel">
                    <div class="hm-pp-header">
                        <b>↔ Sütun (X)</b>
                        <small id="hmColPickHint"></small>
                        <input id="hmColSearch" type="text" placeholder="🔍 Ara..." oninput="_hmFilterPanel('col')">
                        <button onclick="_hmPickAll('col')">Tümü</button>
                        <button onclick="_hmPickClear('col')">Temizle</button>
                    </div>
                    <div id="hmColList" class="hm-pick-list"></div>
                </div>
            </div>

            <div class="hm-legend-row" id="hmLegendRow">
                <span style="font-size:.73rem;color:#64748b;">Düşük</span>
                <div class="hm-legend-bar" id="hmLegendBar"></div>
                <span style="font-size:.73rem;color:#64748b;">Yüksek</span>
                <span class="hm-legend-max" id="hmLegendMax"></span>
            </div>

            <div style="overflow:auto;margin-top:12px;">
                <div id="hmTableWrap"></div>
            </div>
            <div id="hmInsight" style="margin-top:14px;padding:12px 16px;background:#e0f0ff;border-radius:10px;font-size:0.83em;color:#0f4c81;border-left:4px solid #2196f3;display:none;"></div>
        </div>

        <!-- Bubble Chart Tab -->
        <div class="tab-panel" id="tab-bubble">
            <div style="font-size:1.05rem;font-weight:800;color:#5b21b6;display:flex;align-items:center;gap:8px;margin-bottom:14px;">
                🫧 Kabarcık Grafiği
                <span style="font-size:.75rem;font-weight:400;color:#888;background:#f3e8ff;padding:2px 10px;border-radius:20px;">Her kabarcık bir grubu temsil eder — X, Y ve boyut farklı metriklerle belirlenir</span>
            </div>
            <div class="bb-controls">
                <div class="bb-ctrl-group">
                    <label>Gruplama (Kabarcık)</label>
                    <select id="bbGroupBy" onchange="_bbGroupByChange()">
                        <option value="cariAdi">Cari Adı</option>
                        <option value="hataTipi">Hata Tipi</option>
                        <option value="hataKaynagi">Hata Kaynağı</option>
                        <option value="tespitYeri">Tespit Yeri</option>
                        <option value="stokAdi">Stok Adı</option>
                        <option value="makine">Makine</option>
                        <option value="tipi">Tipi</option>
                        <option value="uygunsuzlukTuru">Uyg. Türü</option>
                    </select>
                </div>
                <div class="bb-ctrl-group">
                    <label>X Ekseni</label>
                    <select id="bbXAxis" onchange="renderBubble()">
                        <option value="kayitSayisi">Kayıt Sayısı</option>
                        <option value="hataliMiktar">Hatalı Miktar</option>
                        <option value="ortHataliMiktar">Ort. Hatalı Miktar</option>
                        <option value="hataOrani">Hata Oranı %</option>
                        <option value="hataTipiSayisi">Farklı Hata Tipi Sayısı</option>
                    </select>
                </div>
                <div class="bb-ctrl-group">
                    <label>Y Ekseni</label>
                    <select id="bbYAxis" onchange="renderBubble()">
                        <option value="hataliMiktar">Hatalı Miktar</option>
                        <option value="kayitSayisi">Kayıt Sayısı</option>
                        <option value="ortHataliMiktar">Ort. Hatalı Miktar</option>
                        <option value="hataOrani">Hata Oranı %</option>
                        <option value="hataTipiSayisi">Farklı Hata Tipi Sayısı</option>
                    </select>
                </div>
                <div class="bb-ctrl-group">
                    <label>Kabarcık Boyutu</label>
                    <select id="bbRAxis" onchange="renderBubble()">
                        <option value="hataliMiktar">Hatalı Miktar</option>
                        <option value="kayitSayisi">Kayıt Sayısı</option>
                        <option value="ortHataliMiktar">Ort. Hatalı Miktar</option>
                        <option value="hataOrani">Hata Oranı %</option>
                        <option value="hataTipiSayisi">Farklı Hata Tipi Sayısı</option>
                    </select>
                </div>
                <div class="bb-ctrl-group">
                    <label>Top N Grup</label>
                    <select id="bbTopN" onchange="renderBubble()">
                        <option value="10">10</option>
                        <option value="15">15</option>
                        <option value="20" selected>20</option>
                        <option value="30">30</option>
                        <option value="99999">Tümü</option>
                    </select>
                </div>
                <button class="export-btn" onclick="downloadBubblePNG()" style="align-self:flex-end;">⬇ PNG İndir</button>
            </div>
            <div id="bubbleNoData" style="display:none;padding:30px;text-align:center;color:#aaa;">⚠️ En az bir veri gerekli — filtre uygulayın.</div>
            <div class="bb-chart-area" id="bubbleChartWrap" style="display:none;">
                <canvas id="bubbleChart"></canvas>
            </div>
            <div id="bubbleInsight" class="bb-insight" style="display:none;"></div>
            <div id="bbPickerPanel" class="bb-pick-panel">
                <div class="bb-pick-header">
                    <label>🔍 Grupları Seç / Filtrele</label>
                    <input type="text" class="bb-pick-search" id="bbPickSearch" placeholder="Ara..." oninput="_bbFilterPicker()">
                    <button style="background:#7c3aed;color:#fff;border:none;border-radius:7px;padding:4px 11px;font-size:.76rem;cursor:pointer;" onclick="_bbPickAll()">Tümü</button>
                    <button style="background:#f1f5f9;color:#64748b;border:1px solid #cbd5e1;border-radius:7px;padding:4px 11px;font-size:.76rem;cursor:pointer;" onclick="_bbPickClear()">Temizle</button>
                    <span class="bb-pick-hint" id="bbPickHint">—</span>
                </div>
                <div class="bb-pick-list" id="bbPickList"></div>
            </div>
        </div>

        <!-- Grouped/Stacked Bar Tab -->
        <div class="tab-panel" id="tab-bar">
            <div style="font-size:1.05rem;font-weight:800;color:#15803d;display:flex;align-items:center;gap:8px;margin-bottom:14px;">
                📦 Gruplu / Yığılmış Bar Grafiği
                <span style="font-size:.75rem;font-weight:400;color:#888;background:#dcfce7;padding:2px 10px;border-radius:20px;">Ana grubu renkli katmanlara bölerek hem toplamı hem dağılımı göster</span>
            </div>
            <div class="gb-controls">
                <div class="gb-ctrl-group">
                    <label>Ana Grup (X ekseni)</label>
                    <select id="gbGroupBy" onchange="renderGroupedBar()">
                        <option value="cariAdi">Cari Adı</option>
                        <option value="hataTipi">Hata Tipi</option>
                        <option value="hataKaynagi">Hata Kaynağı</option>
                        <option value="tespitYeri">Tespit Yeri</option>
                        <option value="stokAdi">Stok Adı</option>
                        <option value="makine">Makine</option>
                        <option value="tipi">Tipi</option>
                        <option value="uygunsuzlukTuru">Uyg. Türü</option>
                    </select>
                </div>
                <div class="gb-ctrl-group">
                    <label>Katman (Renk Boyutu)</label>
                    <select id="gbStackBy" onchange="renderGroupedBar()">
                        <option value="hataTipi">Hata Tipi</option>
                        <option value="hataKaynagi">Hata Kaynağı</option>
                        <option value="tespitYeri">Tespit Yeri</option>
                        <option value="cariAdi">Cari Adı</option>
                        <option value="stokAdi">Stok Adı</option>
                        <option value="makine">Makine</option>
                        <option value="tipi">Tipi</option>
                        <option value="uygunsuzlukTuru">Uyg. Türü</option>
                    </select>
                </div>
                <div class="gb-ctrl-group">
                    <label>Metrik</label>
                    <select id="gbMetric" onchange="renderGroupedBar()">
                        <option value="hataliMiktar">Hatalı Miktar</option>
                        <option value="kayitSayisi">Kayıt Sayısı</option>
                    </select>
                </div>
                <div class="gb-ctrl-group">
                    <label>Mod</label>
                    <select id="gbMode" onchange="renderGroupedBar()">
                        <option value="stacked">📊 Yığılmış (Stacked)</option>
                        <option value="grouped">📦 Yan Yana (Grouped)</option>
                        <option value="percent">📈 % Yığılmış (100%)</option>
                    </select>
                </div>
                <div class="gb-ctrl-group">
                    <label>Sıralama</label>
                    <select id="gbSort" onchange="renderGroupedBar()">
                        <option value="desc">Toplama Göre ↓</option>
                        <option value="asc">Toplama Göre ↑</option>
                        <option value="alpha">Alfabetik</option>
                    </select>
                </div>
                <div class="gb-ctrl-group">
                    <label>Top Grup</label>
                    <select id="gbTopGroup" onchange="renderGroupedBar()">
                        <option value="10">10</option>
                        <option value="15" selected>15</option>
                        <option value="20">20</option>
                        <option value="30">30</option>
                        <option value="99999">Tümü</option>
                    </select>
                </div>
                <div class="gb-ctrl-group">
                    <label>Top Katman</label>
                    <select id="gbTopStack" onchange="renderGroupedBar()">
                        <option value="5">5</option>
                        <option value="8" selected>8</option>
                        <option value="10">10</option>
                        <option value="15">15</option>
                        <option value="99999">Tümü</option>
                    </select>
                </div>
                <div class="gb-ctrl-group">
                    <label>Yön</label>
                    <select id="gbDir" onchange="renderGroupedBar()">
                        <option value="vertical">Dikey (↕)</option>
                        <option value="horizontal">Yatay (↔)</option>
                    </select>
                </div>
                <button class="export-btn" onclick="downloadBarPNG()" style="align-self:flex-end;background:#16a34a;border-color:#15803d;">⬇ PNG İndir</button>
            </div>
            <div id="barNoData" style="display:none;padding:30px;text-align:center;color:#aaa;">⚠️ Veri yok — filtre uygulayın.</div>
            <div class="gb-chart-area" id="barChartWrap" style="display:none;">
                <canvas id="barChart"></canvas>
            </div>
            <div id="barInsight" class="gb-insight" style="display:none;"></div>
        </div>
    </div>

        <!-- Sankey Tab -->
        <div class="tab-panel" id="tab-sankey">
            <div style="font-size:1.05rem;font-weight:800;color:#92400e;display:flex;align-items:center;gap:8px;margin-bottom:14px;">
                🌊 Sankey Diyagramı
                <span style="font-size:.75rem;font-weight:400;color:#888;background:#fef3c7;padding:2px 10px;border-radius:20px;">Bir boyuttan diğerine olan akışları ve oranları görselleştirir</span>
            </div>
            <div class="sk-controls">
                <div class="sk-ctrl-group">
                    <label>Sol (Kaynak)</label>
                    <select id="skFrom" onchange="renderSankey()">
                        <option value="cariAdi">Cari Adı</option>
                        <option value="hataKaynagi">Hata Kaynağı</option>
                        <option value="tipi">Tipi</option>
                        <option value="makine">Makine</option>
                        <option value="uygunsuzlukTuru">Uyg. Türü</option>
                        <option value="tespitYeri">Tespit Yeri</option>
                    </select>
                </div>
                <div class="sk-ctrl-group">
                    <label>Sağ (Hedef)</label>
                    <select id="skTo" onchange="renderSankey()">
                        <option value="hataTipi">Hata Tipi</option>
                        <option value="tespitYeri">Tespit Yeri</option>
                        <option value="hataKaynagi">Hata Kaynağı</option>
                        <option value="cariAdi">Cari Adı</option>
                        <option value="stokAdi">Stok Adı</option>
                        <option value="uygunsuzlukTuru">Uyg. Türü</option>
                    </select>
                </div>
                <div class="sk-ctrl-group">
                    <label>Metrik</label>
                    <select id="skMetric" onchange="renderSankey()">
                        <option value="hataliMiktar">Hatalı Miktar</option>
                        <option value="kayitSayisi">Kayıt Sayısı</option>
                    </select>
                </div>
                <div class="sk-ctrl-group">
                    <label>Top Akış</label>
                    <select id="skTopN" onchange="renderSankey()">
                        <option value="15">15</option>
                        <option value="20" selected>20</option>
                        <option value="30">30</option>
                        <option value="50">50</option>
                        <option value="99999">Tümü</option>
                    </select>
                </div>
                <div class="sk-ctrl-group">
                    <label>Min Değer (Eşik)</label>
                    <select id="skMinVal" onchange="renderSankey()">
                        <option value="0">Tümü</option>
                        <option value="1">≥ 1</option>
                        <option value="5">≥ 5</option>
                        <option value="10">≥ 10</option>
                        <option value="20">≥ 20</option>
                        <option value="50">≥ 50</option>
                    </select>
                </div>
                <div class="sk-ctrl-group">
                    <label>Renk Modu</label>
                    <select id="skColorMode" onchange="renderSankey()">
                        <option value="gradient">Gradient</option>
                        <option value="from">Kaynaktan</option>
                        <option value="to">Hedefe</option>
                    </select>
                </div>
                <button class="export-btn" onclick="downloadSankeyPNG()" style="align-self:flex-end;background:#d97706;border-color:#b45309;">⬇ PNG İndir</button>
            </div>
            <div id="sankeyNoData" style="display:none;padding:30px;text-align:center;color:#aaa;">⚠️ Veri yok — filtre uygulayın veya farklı alanlar seçin.</div>
            <div class="sk-chart-area" id="sankeyChartWrap" style="display:none;">
                <canvas id="sankeyChart"></canvas>
            </div>
            <div id="sankeyLegend" class="sk-legend" style="display:none;"></div>
            <div id="sankeyInsight" class="sk-insight" style="display:none;"></div>
        </div>

        <!-- Box Plot Tab -->
        <div class="tab-panel" id="tab-boxplot">
            <div style="font-size:1.05rem;font-weight:800;color:#0f766e;display:flex;align-items:center;gap:8px;margin-bottom:14px;">
                📦 Kutu Grafik (Box Plot)
                <span style="font-size:.75rem;font-weight:400;color:#888;background:#ccfbf1;padding:2px 10px;border-radius:20px;">Her grubun dağılımını, medyanını ve aykırı değerlerini gösterir</span>
            </div>
            <div class="bp-controls">
                <div class="bp-ctrl-group">
                    <label>Gruplama</label>
                    <select id="bpGroupBy" onchange="_bpGroupByChange()">
                        <option value="hataTipi">Hata Tipi</option>
                        <option value="cariAdi">Cari Adı</option>
                        <option value="hataKaynagi">Hata Kaynağı</option>
                        <option value="tespitYeri">Tespit Yeri</option>
                        <option value="stokAdi">Stok Adı</option>
                        <option value="makine">Makine</option>
                        <option value="tipi">Tipi</option>
                        <option value="uygunsuzlukTuru">Uyg. Türü</option>
                    </select>
                </div>
                <div class="bp-ctrl-group">
                    <label>Metrik</label>
                    <select id="bpMetric" onchange="renderBoxPlot()">
                        <option value="hataliMiktar">Hatalı Miktar</option>
                        <option value="kontrolMiktar">Kontrol Miktar</option>
                    </select>
                </div>
                <div class="bp-ctrl-group">
                    <label>Sıralama</label>
                    <select id="bpSort" onchange="renderBoxPlot()">
                        <option value="median">Medyana Göre ↓</option>
                        <option value="q3">Q3'e Göre ↓</option>
                        <option value="mean">Ortalamaya Göre ↓</option>
                        <option value="count">Kayıt Sayısı ↓</option>
                        <option value="alpha">Alfabetik</option>
                    </select>
                </div>
                <div class="bp-ctrl-group">
                    <label>Top N Grup</label>
                    <select id="bpTopN" onchange="renderBoxPlot()">
                        <option value="10">10</option>
                        <option value="15" selected>15</option>
                        <option value="20">20</option>
                        <option value="30">30</option>
                        <option value="99999">Tümü</option>
                    </select>
                </div>
                <div class="bp-ctrl-group">
                    <label>Yön</label>
                    <select id="bpDir" onchange="renderBoxPlot()">
                        <option value="vertical">Dikey</option>
                        <option value="horizontal">Yatay</option>
                    </select>
                </div>
                <div class="bp-ctrl-group">
                    <label>Aykırı Değer</label>
                    <select id="bpOutliers" onchange="renderBoxPlot()">
                        <option value="1">Göster</option>
                        <option value="0">Gizle</option>
                    </select>
                </div>
                <button class="export-btn" onclick="downloadBoxPlotPNG()" style="align-self:flex-end;background:#0d9488;border-color:#0f766e;">⬇ PNG İndir</button>
            </div>
            <div id="bpNoData" style="display:none;padding:30px;text-align:center;color:#aaa;">⚠️ Veri yok — filtre uygulayın.</div>
            <div class="bp-chart-area" id="bpChartWrap" style="display:none;">
                <canvas id="bpChart"></canvas>
            </div>
            <div id="bpInsight" class="bp-insight" style="display:none;"></div>
            <div id="bpStatsWrap" style="display:none;overflow-x:auto;margin-top:6px;">
                <table class="bp-stats-table" id="bpStatsTable">
                    <thead><tr><th>Grup</th><th>N</th><th>Min</th><th>Q1</th><th>Medyan</th><th>Ort.</th><th>Q3</th><th>Maks</th><th>IQR</th></tr></thead>
                    <tbody id="bpStatsTbody"></tbody>
                </table>
            </div>
            <div id="bpPickerPanel" class="bp-pick-panel">
                <div class="bp-pick-header">
                    <label>🔍 Grupları Seç</label>
                    <input type="text" class="bp-pick-search" id="bpPickSearch" placeholder="Ara..." oninput="_bpFilterPicker()">
                    <button style="background:#0d9488;color:#fff;border:none;border-radius:7px;padding:4px 11px;font-size:.76rem;cursor:pointer;" onclick="_bpPickAll()">Tümü</button>
                    <button style="background:#f1f5f9;color:#64748b;border:1px solid #cbd5e1;border-radius:7px;padding:4px 11px;font-size:.76rem;cursor:pointer;" onclick="_bpPickClear()">Temizle</button>
                    <span class="bp-pick-hint" id="bpPickHint">—</span>
                </div>
                <div class="bp-pick-list" id="bpPickList"></div>
            </div>
        </div>

        <!-- Scatter Plot Tab -->
        <div class="tab-panel" id="tab-scatter">
            <div style="font-size:1.05rem;font-weight:800;color:#c2410c;display:flex;align-items:center;gap:8px;margin-bottom:14px;">
                📀 Dağılım Grafiği (Scatter Plot)
                <span style="font-size:.75rem;font-weight:400;color:#888;background:#ffedd5;padding:2px 10px;border-radius:20px;">Her nokta bir kayıdı temsil eder — iki metrik arasındaki ilişkiyi gösterir</span>
            </div>
            <div class="sc-controls">
                <div class="sc-ctrl-group">
                    <label>X Ekseni</label>
                    <select id="scXAxis" onchange="renderScatter()">
                        <option value="hataliMiktar">Hatalı Miktar</option>
                        <option value="kontrolMiktar">Kontrol Miktar</option>
                        <option value="hataOrani">Hata Oranı %</option>
                    </select>
                </div>
                <div class="sc-ctrl-group">
                    <label>Y Ekseni</label>
                    <select id="scYAxis" onchange="renderScatter()">
                        <option value="kontrolMiktar">Kontrol Miktar</option>
                        <option value="hataliMiktar">Hatalı Miktar</option>
                        <option value="hataOrani">Hata Oranı %</option>
                    </select>
                </div>
                <div class="sc-ctrl-group">
                    <label>Renk Grupla</label>
                    <select id="scColorBy" onchange="_scColorByChange()">
                        <option value="hataTipi">Hata Tipi</option>
                        <option value="cariAdi">Cari Adı</option>
                        <option value="hataKaynagi">Hata Kaynağı</option>
                        <option value="tespitYeri">Tespit Yeri</option>
                        <option value="makine">Makine</option>
                        <option value="tipi">Tipi</option>
                        <option value="uygunsuzlukTuru">Uyg. Türü</option>
                    </select>
                </div>
                <div class="sc-ctrl-group">
                    <label>Top N Renk</label>
                    <select id="scTopColor" onchange="renderScatter()">
                        <option value="8">8</option>
                        <option value="12" selected>12</option>
                        <option value="16">16</option>
                        <option value="99999">Tümü</option>
                    </select>
                </div>
                <div class="sc-ctrl-group">
                    <label>Maks Nokta</label>
                    <select id="scMaxPts" onchange="renderScatter()">
                        <option value="300">300</option>
                        <option value="500" selected>500</option>
                        <option value="1000">1000</option>
                        <option value="99999">Tümü</option>
                    </select>
                </div>
                <div class="sc-ctrl-group">
                    <label>Nokta Boyutu</label>
                    <select id="scPointSize" onchange="renderScatter()">
                        <option value="4">Küçük</option>
                        <option value="6" selected>Orta</option>
                        <option value="9">Büyük</option>
                    </select>
                </div>
                <div class="sc-ctrl-group">
                    <label>Log Ölçek</label>
                    <select id="scLogScale" onchange="renderScatter()">
                        <option value="0">Kapalı</option>
                        <option value="1">Açık</option>
                    </select>
                </div>
                <div class="sc-ctrl-group">
                    <label>Eğim Çizgisi</label>
                    <select id="scTrendline" onchange="renderScatter()">
                        <option value="0">Kapalı</option>
                        <option value="1">Açık</option>
                    </select>
                </div>
                <button class="export-btn" onclick="downloadScatterPNG()" style="align-self:flex-end;background:#ea580c;border-color:#c2410c;">⬇ PNG İndir</button>
            </div>
            <div id="scNoData" style="display:none;padding:30px;text-align:center;color:#aaa;">⚠️ Veri yok — filtre uygulayın.</div>
            <div class="sc-chart-area" id="scChartWrap" style="display:none;">
                <canvas id="scChart"></canvas>
            </div>
            <div id="scInsight" class="sc-insight" style="display:none;"></div>
            <div id="scPickerPanel" class="sc-pick-panel">
                <div class="sc-pick-header">
                    <label>🔍 Renk Gruplarını Seç</label>
                    <input type="text" class="sc-pick-search" id="scPickSearch" placeholder="Ara..." oninput="_scFilterPicker()">
                    <button style="background:#ea580c;color:#fff;border:none;border-radius:7px;padding:4px 11px;font-size:.76rem;cursor:pointer;" onclick="_scPickAll()">Tümü</button>
                    <button style="background:#f1f5f9;color:#64748b;border:1px solid #cbd5e1;border-radius:7px;padding:4px 11px;font-size:.76rem;cursor:pointer;" onclick="_scPickClear()">Temizle</button>
                    <span class="sc-pick-hint" id="scPickHint">—</span>
                </div>
                <div class="sc-pick-list" id="scPickList"></div>
            </div>
        </div>
    </div>

        <!-- Treemap Tab -->
        <div class="tab-panel" id="tab-treemap">
            <div style="font-size:1.05rem;font-weight:800;color:#0369a1;display:flex;align-items:center;gap:8px;margin-bottom:14px;">
                🗺️ Treemap
                <span style="font-size:.75rem;font-weight:400;color:#888;background:#e0f2fe;padding:2px 10px;border-radius:20px;">Alan büyüklüğü seçili metriği temsil eder</span>
            </div>
            <div class="tm-controls">
                <div class="tm-ctrl-group">
                    <label>Gruplama</label>
                    <select id="tmGroupBy" onchange="_tmGroupByChange()">
                        <option value="hataTipi">Hata Tipi</option>
                        <option value="cariAdi">Cari Adı</option>
                        <option value="hataKaynagi">Hata Kaynağı</option>
                        <option value="tespitYeri">Tespit Yeri</option>
                        <option value="stokAdi">Stok Adı</option>
                        <option value="makine">Makine</option>
                        <option value="tipi">Tipi</option>
                        <option value="uygunsuzlukTuru">Uyg. Türü</option>
                    </select>
                </div>
                <div class="tm-ctrl-group">
                    <label>Metrik</label>
                    <select id="tmMetric" onchange="renderTreemap()">
                        <option value="hataliMiktar">Hatalı Miktar</option>
                        <option value="kontrolMiktar">Kontrol Miktar</option>
                        <option value="kayitSayisi">Kayıt Sayısı</option>
                    </select>
                </div>
                <div class="tm-ctrl-group">
                    <label>Top N</label>
                    <select id="tmTopN" onchange="renderTreemap()">
                        <option value="15">15</option>
                        <option value="20" selected>20</option>
                        <option value="30">30</option>
                        <option value="50">50</option>
                        <option value="99999">Tümü</option>
                    </select>
                </div>
                <button class="export-btn" onclick="downloadTreemapPNG()" style="align-self:flex-end;background:#0369a1;border-color:#075985;">⬇ PNG İndir</button>
            </div>
            <div id="tmNoData" style="display:none;padding:30px;text-align:center;color:#aaa;">⚠️ Veri yok — filtre uygulayın.</div>
            <div class="tm-chart-area" id="tmChartWrap" style="display:none;">
                <canvas id="tmChart"></canvas>
            </div>
            <div id="tmInsight" class="tm-insight" style="display:none;"></div>
            <div id="tmPickerPanel" class="tm-pick-panel">
                <div class="tm-pick-header">
                    <label>🔍 Grupları Seç</label>
                    <input type="text" class="tm-pick-search" id="tmPickSearch" placeholder="Ara..." oninput="_tmFilterPicker()">
                    <button style="background:#0369a1;color:#fff;border:none;border-radius:7px;padding:4px 11px;font-size:.76rem;cursor:pointer;" onclick="_tmPickAll()">Tümü</button>
                    <button style="background:#f1f5f9;color:#64748b;border:1px solid #cbd5e1;border-radius:7px;padding:4px 11px;font-size:.76rem;cursor:pointer;" onclick="_tmPickClear()">Temizle</button>
                    <span class="tm-pick-hint" id="tmPickHint">—</span>
                </div>
                <div class="tm-pick-list" id="tmPickList"></div>
            </div>
        </div>

        </div>

        <!-- Calendar Heatmap Tab -->
        <div class="tab-panel" id="tab-calendar">
            <div style="font-size:1.05rem;font-weight:800;color:#4f46e5;display:flex;align-items:center;gap:8px;margin-bottom:14px;">
                🔥 Takvim Isı Haritası
                <span style="font-size:.75rem;font-weight:400;color:#888;background:#eef2ff;padding:2px 10px;border-radius:20px;">Günlük uygunsuzluk yoğunluğunu takvim üzerinde gösterir</span>
            </div>
            <div class="cal-controls">
                <div class="cal-ctrl-group">
                    <label>Yıl</label>
                    <select id="calYear" onchange="renderCalendar()"></select>
                </div>
                <div class="cal-ctrl-group">
                    <label>Metrik</label>
                    <select id="calMetric" onchange="renderCalendar()">
                        <option value="hataliMiktar">Hatalı Miktar</option>
                        <option value="kayitSayisi">Kayıt Sayısı</option>
                    </select>
                </div>
                <div class="cal-ctrl-group">
                    <label>Renk Tema</label>
                    <select id="calTheme" onchange="renderCalendar()">
                        <option value="indigo">Indigo (Varsayılan)</option>
                        <option value="orange">Turuncu</option>
                        <option value="green">Yeşil</option>
                        <option value="red">Kırmızı</option>
                        <option value="purple">Mor</option>
                    </select>
                </div>
            </div>
            <div id="calNoData" style="display:none;padding:30px;text-align:center;color:#aaa;">⚠️ Tarih verisi bulunamadı — filtre uygulayın.</div>
            <div id="calContainer">
                <svg id="calSvg"></svg>
            </div>
            <div class="cal-legend" id="calLegend"></div>
            <div id="calInsight" class="cal-insight" style="display:none;"></div>
        </div>

        <!-- ── COHORT TAB ── -->
        <div class="tab-panel" id="tab-cohort">
            <div style="font-size:1.05rem;font-weight:800;color:#166534;display:flex;align-items:center;gap:8px;margin-bottom:14px;">
                🔄 Cohort Analizi
                <span style="font-size:.75rem;font-weight:400;color:#888;background:#f0fdf4;padding:2px 10px;border-radius:20px;">Grubun ilk uygunsuzluk ayından itibaren sonraki aylardaki hata tekrar örüntüsü</span>
            </div>

            <div class="cohort-controls">
                <div class="cohort-ctrl-group">
                    <label>Cohort Grubu</label>
                    <select id="cohortGroupBy" onchange="renderCohort()">
                        <option value="cariAdi">Tedarikçi (Cari)</option>
                        <option value="hataTipi">Hata Tipi</option>
                        <option value="tespitYeri">Tespit Yeri</option>
                        <option value="hataKaynagi">Hata Kaynağı</option>
                    </select>
                </div>
                <div class="cohort-ctrl-group">
                    <label>Metrik</label>
                    <select id="cohortMetric" onchange="renderCohort()">
                        <option value="hataliMiktar">Hatalı Miktar</option>
                        <option value="kayitSayisi">Kayıt Sayısı</option>
                    </select>
                </div>
                <div class="cohort-ctrl-group">
                    <label>Gösterim</label>
                    <select id="cohortDisplay" onchange="renderCohort()">
                        <option value="absolute">Mutlak Değer</option>
                        <option value="percent">% (Ay 0'a göre)</option>
                        <option value="cumulative">Kümülatif</option>
                    </select>
                </div>
                <div class="cohort-ctrl-group">
                    <label>Max Ay Offseti</label>
                    <input type="number" id="cohortMaxOffset" value="11" min="1" max="23" style="width:70px" onchange="renderCohort()">
                </div>
                <div class="cohort-ctrl-group">
                    <label>Min Ay-0 Değeri</label>
                    <input type="number" id="cohortMinBase" value="0" min="0" step="1" style="width:80px" onchange="renderCohort()">
                </div>
            </div>

            <div class="cohort-mode-bar">
                <span style="font-size:.82em;color:#555;font-weight:600;align-self:center;">Renk skalası:</span>
                <button class="cohort-mode-btn active" id="cohortScaleGlobal" onclick="setCohortScale('global')">Global</button>
                <button class="cohort-mode-btn" id="cohortScaleRow" onclick="setCohortScale('row')">Satır Bazlı</button>
                <button class="cohort-mode-btn" id="cohortScaleCol" onclick="setCohortScale('col')">Sütun Bazlı</button>
            </div>

            <div id="cohortNoData" style="display:none;padding:30px;text-align:center;color:#aaa;">⚠️ Tarih ve grup verisi bulunamadı. Filtreleri kontrol edin.</div>
            <div class="cohort-table-wrap" id="cohortTableWrap">
                <table class="cohort-table" id="cohortTable"></table>
            </div>
            <div class="cohort-insight" id="cohortInsight" style="display:none;"></div>
        </div>

        <!-- Funnel Tab -->
        <div class="tab-panel" id="tab-funnel">
            <div class="funnel-wrap">
                <h3 style="margin:0 0 14px;color:#4a0a6b;">🔺 Funnel (Huni) Grafiği</h3>
                <div class="funnel-controls">
                    <div class="funnel-ctrl-group">
                        <label>Boyut:</label>
                        <select id="funnelGroupBy" onchange="renderFunnel()">
                            <option value="hataTipi">Hata Tipi</option>
                            <option value="tespitYeri">Tespit Yeri</option>
                            <option value="hataKaynagi">Hata Kaynağı</option>
                            <option value="cariAdi">Tedarikçi</option>
                        </select>
                    </div>
                    <div class="funnel-ctrl-group">
                        <label>Metrik:</label>
                        <select id="funnelMetric" onchange="renderFunnel()">
                            <option value="hataliMiktar">Hatalı Miktar</option>
                            <option value="count">Kayıt Sayısı</option>
                        </select>
                    </div>
                    <div class="funnel-ctrl-group">
                        <label>Top N:</label>
                        <input type="number" id="funnelTopN" value="8" min="2" max="20" style="width:65px" onchange="renderFunnel()">
                    </div>
                    <div class="funnel-ctrl-group">
                        <label>Etiket:</label>
                        <select id="funnelLabel" onchange="renderFunnel()">
                            <option value="both">Değer + %</option>
                            <option value="value">Sadece Değer</option>
                            <option value="pct">Sadece %</option>
                        </select>
                    </div>
                </div>
                <div id="funnelNoData" style="display:none;padding:30px;text-align:center;color:#aaa;">⚠️ Veri bulunamadı.</div>
                <div class="funnel-svg-wrap" id="funnelSvgWrap"></div>
                <div class="funnel-legend" id="funnelLegend"></div>
                <div class="funnel-insight" id="funnelInsight" style="display:none;"></div>
            </div>
        </div>

        <!-- Polar Area Tab -->
        <div class="tab-panel" id="tab-polar">
            <div class="polar-wrap">
                <h3 style="margin:0 0 14px;color:#4a0a6b;">🌐 Polar Alan Grafiği</h3>
                <div class="polar-controls">
                    <div class="polar-ctrl-group">
                        <label>Boyut:</label>
                        <select id="polarGroupBy" onchange="renderPolarArea()">
                            <option value="hataTipi">Hata Tipi</option>
                            <option value="tespitYeri">Tespit Yeri</option>
                            <option value="hataKaynagi">Hata Kaynağı</option>
                            <option value="cariAdi">Tedarikçi</option>
                        </select>
                    </div>
                    <div class="polar-ctrl-group">
                        <label>Metrik:</label>
                        <select id="polarMetric" onchange="renderPolarArea()">
                            <option value="hataliMiktar">Hatalı Miktar</option>
                            <option value="count">Kayıt Sayısı</option>
                        </select>
                    </div>
                    <div class="polar-ctrl-group">
                        <label>Top N:</label>
                        <input type="number" id="polarTopN" value="10" min="2" max="20" style="width:65px" onchange="renderPolarArea()">
                    </div>
                    <div class="polar-ctrl-group">
                        <label>İkincil Boyut:</label>
                        <select id="polarSecondary" onchange="renderPolarArea()">
                            <option value="none">Yok</option>
                            <option value="hataTipi">Hata Tipi</option>
                            <option value="tespitYeri">Tespit Yeri</option>
                            <option value="hataKaynagi">Hata Kaynağı</option>
                            <option value="cariAdi">Tedarikçi</option>
                        </select>
                    </div>
                </div>
                <div id="polarNoData" style="display:none;padding:30px;text-align:center;color:#aaa;">⚠️ Veri bulunamadı.</div>
                <div class="polar-chart-area">
                    <!-- Selector panel -->
                    <div class="polar-sel-panel" id="polarSelPanel">
                        <div class="polar-sel-title">
                            <span>Kategoriler</span>
                            <div class="polar-sel-actions">
                                <button class="polar-sel-btn" onclick="_polarSelectAll(true)">Tümü</button>
                                <button class="polar-sel-btn" onclick="_polarSelectAll(false)">Temizle</button>
                            </div>
                        </div>
                        <div class="polar-sel-list" id="polarSelList"></div>
                    </div>
                    <!-- Chart -->
                    <div class="polar-canvas-wrap"><canvas id="polarChart"></canvas></div>
                    <!-- Stats panel -->
                    <div class="polar-stats-panel" id="polarStatsPanel"></div>
                </div>
                <div class="polar-insight" id="polarInsight" style="display:none;"></div>
            </div>
        </div>

        <!-- Chord Tab -->
        <div class="tab-panel" id="tab-chord">
            <div class="chord-wrap">
                <h3 style="margin:0 0 14px;color:#4a0a6b;">🕷️ Chord Diyagramı — Boyutlar Arası Akış</h3>
                <div class="chord-controls">
                    <div class="chord-ctrl-group">
                        <label>1. Boyut:</label>
                        <select id="chordDim1" onchange="renderChord()">
                            <option value="hataTipi">Hata Tipi</option>
                            <option value="tespitYeri">Tespit Yeri</option>
                            <option value="hataKaynagi">Hata Kaynağı</option>
                            <option value="cariAdi">Tedarikçi</option>
                        </select>
                    </div>
                    <div class="chord-ctrl-group">
                        <label>2. Boyut:</label>
                        <select id="chordDim2" onchange="renderChord()">
                            <option value="tespitYeri">Tespit Yeri</option>
                            <option value="hataTipi">Hata Tipi</option>
                            <option value="hataKaynagi">Hata Kaynağı</option>
                            <option value="cariAdi">Tedarikçi</option>
                        </select>
                    </div>
                    <div class="chord-ctrl-group">
                        <label>Metrik:</label>
                        <select id="chordMetric" onchange="renderChord()">
                            <option value="hataliMiktar">Hatalı Miktar</option>
                            <option value="count">Kayıt Sayısı</option>
                        </select>
                    </div>
                    <div class="chord-ctrl-group">
                        <label>Top N (1. Boyut):</label>
                        <input type="number" id="chordTopN" value="8" min="2" max="16" style="width:65px" onchange="renderChord()">
                    </div>
                </div>
                <div id="chordNoData" style="display:none;padding:30px;text-align:center;color:#aaa;">⚠️ Veri bulunamadı.</div>
                <div class="chord-body">
                    <div class="chord-svg-wrap" id="chordSvgWrap"></div>
                    <div class="chord-legend-wrap" id="chordLegend"></div>
                </div>
                <div class="chord-insight" id="chordInsight" style="display:none;"></div>
            </div>
        </div>
        <div class="chord-tooltip" id="chordTooltip"></div>

        <!-- Beeswarm Tab -->
        <div class="tab-panel" id="tab-beeswarm">
            <div class="bsw-wrap">
                <h3 style="margin:0 0 14px;color:#4a0a6b;">🟣 Beeswarm / Dot Plot — Bireysel Kayıt Dağılımı</h3>
                <div class="bsw-controls">
                    <div class="bsw-ctrl-group">
                        <label>Grup (X-Ekseni):</label>
                        <select id="bswGroupBy" onchange="renderBeeswarm()">
                            <option value="hataTipi">Hata Tipi</option>
                            <option value="tespitYeri">Tespit Yeri</option>
                            <option value="hataKaynagi">Hata Kaynağı</option>
                            <option value="cariAdi">Tedarikçi</option>
                        </select>
                    </div>
                    <div class="bsw-ctrl-group">
                        <label>Değer (Y-Ekseni):</label>
                        <select id="bswMetric" onchange="renderBeeswarm()">
                            <option value="hataliMiktar">Hatalı Miktar</option>
                            <option value="partiHacmi">Parti Hacmi</option>
                        </select>
                    </div>
                    <div class="bsw-ctrl-group">
                        <label>Renk:</label>
                        <select id="bswColor" onchange="renderBeeswarm()">
                            <option value="group">Gruba Göre</option>
                            <option value="hataTipi">Hata Tipi</option>
                            <option value="tespitYeri">Tespit Yeri</option>
                            <option value="hataKaynagi">Hata Kaynağı</option>
                        </select>
                    </div>
                    <div class="bsw-ctrl-group">
                        <label>Top N (Grup):</label>
                        <input type="number" id="bswTopN" value="8" min="1" max="20" style="width:65px" onchange="renderBeeswarm()">
                    </div>
                    <div class="bsw-ctrl-group">
                        <label>Y-Log Skala:</label>
                        <select id="bswYScale" onchange="renderBeeswarm()">
                            <option value="linear">Lineer</option>
                            <option value="log">Logaritmik</option>
                        </select>
                    </div>
                    <div class="bsw-ctrl-group">
                        <label>Nokta R:</label>
                        <input type="number" id="bswRadius" value="5" min="2" max="10" style="width:55px" onchange="renderBeeswarm()">
                    </div>
                </div>
                <div id="bswNoData" style="display:none;padding:30px;text-align:center;color:#aaa;">⚠️ Veri bulunamadı.</div>
                <div class="bsw-body">
                    <div class="bsw-sel-panel" id="bswSelPanel">
                        <div class="bsw-sel-title">
                            <span>Gruplar</span>
                            <div class="bsw-sel-actions">
                                <button class="bsw-sel-btn" onclick="_bswSelectAll(true)">Tümü</button>
                                <button class="bsw-sel-btn" onclick="_bswSelectAll(false)">Sıfırla</button>
                            </div>
                        </div>
                        <div class="bsw-sel-list" id="bswSelList"></div>
                    </div>
                    <div class="bsw-chart-wrap">
                        <div class="bsw-svg-wrap" id="bswSvgWrap"></div>
                    </div>
                </div>
                <div class="bsw-insight" id="bswInsight" style="display:none;"></div>
            </div>
        </div>
        <div class="bsw-tooltip" id="bswTooltip"></div>

    <!-- Empty state -->
    <div class="empty-state" id="emptyState">
        <div class="icon">📥</div>
        <p>Henüz dosya yüklenmedi. Yukarıdan bir Excel dosyası seçin.</p>
    </div>

</div>

<script>
// ─── State ───────────────────────────────────────────────────────────────────
let allData = [];         // raw parsed rows
let filteredData = [];    // after filters
let tableSearchData = []; // after table search
let currentPage = 1;
const PAGE_SIZE = 50;
let sortCol = -1;
let sortAsc = true;
let paretoChartInst = null;
let _paretoSelected = new Set(); // Pareto bar seçimleri (kapsamlı rapor filtresi)
let radarChartInst  = null;
let _radarSelected  = new Set();
let excludedHataTipleri = new Set(); // breakdown'dan dışlananlar

// Tüm grafiklere uygulanacak etkili veri (breakdown tiıklarına göre filtrelenmiş)
function _effectiveData() {
    return excludedHataTipleri.size > 0
        ? filteredData.filter(r => !excludedHataTipleri.has(r.hataTipi || '(Belirtilmemiş)'))
        : filteredData;
}

function _refreshAllCharts() {
    renderPareto();
    renderTable(undefined);
    renderRadar();
    renderHeatmap();
    renderBubble();
    renderGroupedBar();
    renderSankey();
    renderBoxPlot();
    renderScatter();
    renderTreemap();
    renderCalendar();
    renderCohort();
    renderFunnel();
    renderPolarArea();
    renderChord();
    renderBeeswarm();
}

function toggleBreakdownAll() {
    // Tüm tipleri seç (excluded kümesini temizle)
    excludedHataTipleri.clear();
    document.querySelectorAll('.breakdown-item').forEach(el => {
        el.classList.remove('excluded');
    });
    document.querySelectorAll('.bi-checkbox').forEach(cb => { cb.checked = true; });
    _refreshAllCharts();
}

function toggleBreakdownClear() {
    // Tüm tipleri dışla
    document.querySelectorAll('.bi-checkbox').forEach(cb => {
        const key = cb.getAttribute('data-key');
        if (key) excludedHataTipleri.add(key);
        cb.checked = false;
    });
    document.querySelectorAll('.breakdown-item').forEach(el => {
        el.classList.add('excluded');
    });
    _refreshAllCharts();
}
let selectedCari = '';            // custom cari dropdown seçili değer
let musteriSet = new Set();       // müşteri olarak işaretlenmiş cariler
let _cariAllList = [];            // cari dropdown listesi
let selectedTespitYeriSet = new Set(); // tespit yeri çoklu seçim
let _tespitYeriAllList = [];      // tespit yeri dropdown listesi
let multiAnalyzeMode = false;    // çoklu analiz modu
let selectedForMulti = new Set(); // çoklu analiz seçilenleri

// Column map: internal key → possible Excel header variants (case-insensitive)
const COL_MAP = {
    uygunsuzlukSeri:    ['uygunsuzluk seri', 'uyg seri', 'seri'],
    uygunsuzlukSira:    ['uygunsuzluk sira', 'uyg sira', 'sıra', 'sira'],
    uygunsuzlukTarih:   ['uygunsuzluk tarih', 'tarih', 'date'],
    tipi:               ['tipi', 'tip'],
    tespitYeri:         ['tespit yeri', 'tespityeri'],
    makine:             ['makine'],
    stokKodu:           ['stok kodu', 'stokkodu', 'stok_kodu'],
    stokAdi:            ['stok adı', 'stok adi', 'stokadi', 'stok_adi'],
    yarimamulKodu:      ['yarimamul kodu', 'yarı mamul kodu', 'yarimamulkodu'],
    yarimamulAdi:       ['yarimamul adi', 'yarı mamul adı', 'yarimamuladi'],
    cariKodu:           ['cari kodu', 'carikodu', 'cari_kodu'],
    cariAdi:            ['cari adı', 'cari adi', 'cariadi', 'cari_adi'],
    partiHacmi:         ['parti hacmi', 'partihacmi'],
    kontrolMiktar:      ['kontrol miktar', 'kontrol miktarı', 'kontrolmiktar'],
    hataliMiktar:       ['hatali miktar', 'hatalı miktar', 'hatalimiktar', 'hata miktar'],
    birim:              ['birim'],
    uygunsuzlukTuru:    ['uygunsuzluk turu', 'uygunsuzluk türü', 'uygunsuzlukturu'],
    hataTipi:           ['hata tipi', 'hatatp', 'hata_tipi'],
    hataKaynagi:        ['hata kaynagi', 'hata kaynağı', 'hatakaynagi'],
    tarif:              ['tarif'],
    karar:              ['karar'],
    kapatmaTarihi:      ['kapatma tarihi', 'kapatmatarihi'],
    sonuc:              ['sonuç', 'sonuc'],
    stokHarSeri:        ['stok hareketi seri', 'stokhar seri'],
    stokHarSira:        ['stok hareketi sıra', 'stok hareketi sira', 'stokhar sira'],
    isEmriKodu:         ['iş emri kodu', 'is emri kodu', 'isemrikodu'],
    uretimKaydi:        ['üretim kaydı', 'uretim kaydi', 'üretimkaydı'],
};

const COL_LABELS = {
    uygunsuzlukSeri: 'Uyg. Seri',
    uygunsuzlukSira: 'Uyg. Sıra',
    uygunsuzlukTarih: 'Tarih',
    tipi: 'Tipi',
    tespitYeri: 'Tespit Yeri',
    makine: 'Makine',
    stokKodu: 'Stok Kodu',
    stokAdi: 'Stok Adı',
    yarimamulKodu: 'Yarımamul Kodu',
    yarimamulAdi: 'Yarımamul Adı',
    cariKodu: 'Cari Kodu',
    cariAdi: 'Cari Adı',
    partiHacmi: 'Parti Hacmi',
    kontrolMiktar: 'Kontrol Miktar',
    hataliMiktar: 'Hatalı Miktar',
    birim: 'Birim',
    uygunsuzlukTuru: 'Uyg. Türü',
    hataTipi: 'Hata Tipi',
    hataKaynagi: 'Hata Kaynağı',
    tarif: 'Tarif',
    karar: 'Karar',
    kapatmaTarihi: 'Kapatma Tarihi',
    sonuc: 'Sonuç',
    stokHarSeri: 'Stok Har. Seri',
    stokHarSira: 'Stok Har. Sıra',
    isEmriKodu: 'İş Emri Kodu',
    uretimKaydi: 'Üretim Kaydı',
};

const TABLE_COLS = Object.keys(COL_MAP);

// ─── Drop Zone ───────────────────────────────────────────────────────────────
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');

dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    const file = e.dataTransfer.files[0];
    if (file) processFile(file);
});
fileInput.addEventListener('change', e => { if (e.target.files[0]) processFile(e.target.files[0]); });

// ─── File Processing ──────────────────────────────────────────────────────────
function processFile(file) {
    if (!file.name.match(/\.(xlsx|xls)$/i)) {
        showToast('Lütfen .xlsx veya .xls dosyası seçin!', 'error'); return;
    }
    showLoading(true);
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const wb = XLSX.read(e.target.result, { type: 'array', cellDates: true });
            const ws = wb.Sheets[wb.SheetNames[0]];
            const raw = XLSX.utils.sheet_to_json(ws, { defval: '', raw: false });
            allData = mapColumns(raw);
            filteredData = [...allData];
            showFileInfo(file.name, wb.SheetNames[0], allData.length, false);
            saveToStorage(file.name, wb.SheetNames[0]);
            initUI();
            showLoading(false);
            showToast(`${allData.length} kayıt başarıyla yüklendi!`, 'success');
        } catch(err) {
            showLoading(false);
            showToast('Excel okuma hatası: ' + err.message, 'error');
        }
    };
    reader.readAsArrayBuffer(file);
}

function normalizeHeader(h) {
    return String(h).toLowerCase().trim()
        .replace(/[_\-]/g, ' ')
        .replace(/ğ/g,'g').replace(/ü/g,'u').replace(/ş/g,'s')
        .replace(/ı/g,'i').replace(/ö/g,'o').replace(/ç/g,'c');
}

function mapColumns(raw) {
    if (!raw.length) return [];
    const headers = Object.keys(raw[0]);
    // Build lookup: normalized header → original key
    const normToOrig = {};
    headers.forEach(h => { normToOrig[normalizeHeader(h)] = h; });

    // For each internal key, find the matching column
    const keyMap = {};
    for (const [intKey, variants] of Object.entries(COL_MAP)) {
        for (const v of variants) {
            const norm = normalizeHeader(v);
            if (normToOrig[norm]) { keyMap[intKey] = normToOrig[norm]; break; }
        }
        // fuzzy: try contains
        if (!keyMap[intKey]) {
            for (const v of variants) {
                const norm = normalizeHeader(v);
                const found = Object.keys(normToOrig).find(h => h.includes(norm) || norm.includes(h));
                if (found) { keyMap[intKey] = normToOrig[found]; break; }
            }
        }
    }

    return raw.map(row => {
        const obj = {};
        for (const intKey of TABLE_COLS) {
            const origCol = keyMap[intKey];
            let val = origCol ? row[origCol] : '';
            if (val === null || val === undefined) val = '';
            // Parse numeric fields
            if (intKey === 'hataliMiktar' || intKey === 'kontrolMiktar' || intKey === 'partiHacmi') {
                const n = parseFloat(String(val).replace(',', '.'));
                val = isNaN(n) ? 0 : n;
            }
            obj[intKey] = val;
        }
        return obj;
    }).filter(r => r.hataTipi !== '' || r.uygunsuzlukSeri !== '' || r.stokKodu !== '');
}

// ─── Init UI ───────────────────────────────────────────────────────────────
function initUI() {
    populateFilters();
    updateStats();
    renderPareto();
    renderBreakdown();
    renderTable();
    document.getElementById('statsRow').style.display = 'flex';
    document.getElementById('filterCard').style.display = 'block';
    document.getElementById('mainContent').style.display = 'block';
    document.getElementById('emptyState').style.display = 'none';
}

function populateFilters() {
    const selFields = {
        fTipi: 'tipi',
        fHataTipi: 'hataTipi',
        fHataKaynagi: 'hataKaynagi',
        fUygunsuzlukTuru: 'uygunsuzlukTuru',
        fMakine: 'makine',
        fStokKodu: 'stokKodu',
    };
    for (const [selId, field] of Object.entries(selFields)) {
        const sel = document.getElementById(selId);
        const current = sel.value;
        const vals = [...new Set(allData.map(r => r[field]).filter(v => v !== '' && v !== 0))].sort();
        sel.innerHTML = '<option value="">Tümü</option>' + vals.map(v => `<option value="${v}">${v}</option>`).join('');
        if (vals.includes(current)) sel.value = current;
        if (selId === 'fStokKodu') {
            window._stokOptions = vals;
            // sync custom dropdown label
            const _lbl = document.getElementById('skLabel');
            if (_lbl) _lbl.textContent = sel.value ? sel.value : 'Tümü';
            _skBuild();
        }
    }
    populateTespitYeriDropdown();
    populateCariDropdown();
    // Date range
    const dates = allData.map(r => r.uygunsuzlukTarih).filter(Boolean).sort();
    if (dates.length) {
        document.getElementById('fDateStart').value = '';
        document.getElementById('fDateEnd').value = '';
    }
}

// ─── Filters ─────────────────────────────────────────────────────────────────
function applyFilters() {
    const tipi          = document.getElementById('fTipi').value;
    const hataTipi      = document.getElementById('fHataTipi').value;
    const hataKaynagi   = document.getElementById('fHataKaynagi').value;
    const uyTuru        = document.getElementById('fUygunsuzlukTuru').value;
    const makine        = document.getElementById('fMakine').value;
    const stokKodu      = document.getElementById('fStokKodu').value;
    const dateStart     = document.getElementById('fDateStart').value;
    const dateEnd       = document.getElementById('fDateEnd').value;
    const cariTip       = document.getElementById('fCariTip').value;

    filteredData = allData.filter(r => {
        if (tipi        && r.tipi        !== tipi)        return false;
        if (hataTipi    && r.hataTipi    !== hataTipi)    return false;
        if (hataKaynagi && r.hataKaynagi !== hataKaynagi) return false;
        if (uyTuru      && r.uygunsuzlukTuru !== uyTuru)  return false;
        if (selectedTespitYeriSet.size > 0 && !selectedTespitYeriSet.has(r.tespitYeri)) return false;
        if (makine      && r.makine      !== makine)       return false;
        if (selectedCari && r.cariAdi    !== selectedCari) return false;
        if (cariTip === 'musteri'   && !musteriSet.has(r.cariAdi)) return false;
        if (cariTip === 'tedarikci' &&  musteriSet.has(r.cariAdi)) return false;
        if (stokKodu    && r.stokKodu    !== stokKodu)    return false;
        if (dateStart || dateEnd) {
            const d = parseDateStr(r.uygunsuzlukTarih);
            if (dateStart && d && d < dateStart) return false;
            if (dateEnd   && d && d > dateEnd)   return false;
        }
        return true;
    });
    updateStats();
    renderPareto();
    renderBreakdown();
    currentPage = 1;
    renderTable();
    _radarSelected.clear();
    radarBuildSelector();
    if (document.getElementById('tab-heatmap').classList.contains('active')) renderHeatmap();
    if (document.getElementById('tab-bubble').classList.contains('active'))  renderBubble();
    if (document.getElementById('tab-bar').classList.contains('active'))     renderGroupedBar();
    if (document.getElementById('tab-sankey').classList.contains('active'))  renderSankey();
    if (document.getElementById('tab-boxplot').classList.contains('active')) renderBoxPlot();
    if (document.getElementById('tab-scatter').classList.contains('active')) renderScatter();
    showToast(`${filteredData.length} kayıt filtrelendi`, 'success');
}

function resetFilters() {
    document.getElementById('fTipi').value = '';
    document.getElementById('fHataTipi').value = '';
    document.getElementById('fHataKaynagi').value = '';
    document.getElementById('fUygunsuzlukTuru').value = '';
    resetTespitYeri();
    document.getElementById('fMakine').value = '';
    document.getElementById('fCariTip').value = '';
    document.getElementById('fStokKodu').value = '';
    _skSelect('');
    _skBuild();
    document.getElementById('fDateStart').value = '';
    document.getElementById('fDateEnd').value = '';
    selectCari('');
    filteredData = [...allData];
    updateStats();
    renderPareto();
    renderBreakdown();
    currentPage = 1;
    renderTable();
    _radarSelected.clear();
    radarBuildSelector();
    if (document.getElementById('tab-heatmap').classList.contains('active')) renderHeatmap();
    if (document.getElementById('tab-bubble').classList.contains('active'))  renderBubble();
    if (document.getElementById('tab-bar').classList.contains('active'))     renderGroupedBar();
    if (document.getElementById('tab-sankey').classList.contains('active'))  renderSankey();
    if (document.getElementById('tab-boxplot').classList.contains('active')) renderBoxPlot();
    if (document.getElementById('tab-scatter').classList.contains('active')) renderScatter();
    showToast('Filtreler sıfırlandı');
}

// ─── Custom Tespit Yeri Multi-Select ─────────────────────────────────────
function filterStokKodu(term) {
    // legacy compat — no-op, _skFilter used now
    _skFilter(term);
}

// ── Custom searchable stok kodu dropdown ──
function _skBuild() {
    _skFilter('');
}
function _skToggle() {
    const panel  = document.getElementById('skPanel');
    const trigger = document.getElementById('skTrigger');
    if (!panel) return;
    const opening = !panel.classList.contains('open');
    // close all other dropdowns if any
    panel.classList.toggle('open', opening);
    trigger.classList.toggle('open', opening);
    if (opening) {
        const inp = document.getElementById('skSearch');
        if (inp) { inp.value = ''; _skFilter(''); setTimeout(() => inp.focus(), 60); }
    }
}
function _skFilter(term) {
    const list = document.getElementById('skList');
    if (!list) return;
    const cur  = document.getElementById('fStokKodu').value;
    const opts = window._stokOptions || [];
    const q    = term.trim().toLowerCase();
    const filtered = q === '' ? opts : opts.filter(v => String(v).toLowerCase().includes(q));
    if (!filtered.length) {
        list.innerHTML = '<div class="sk-item no-result">Sonuç bulunamadı</div>';
        return;
    }
    list.innerHTML = ['', ...filtered].map(v => {
        const label = v === '' ? 'Tümü' : v;
        return `<div class="sk-item${v === cur ? ' selected' : ''}" onclick="_skSelect(${JSON.stringify(v)})">${label}</div>`;
    }).join('');
}
function _skSelect(val) {
    const sel = document.getElementById('fStokKodu');
    if (sel) sel.value = val;
    document.getElementById('skLabel').textContent = val === '' ? 'Tümü' : val;
    const panel  = document.getElementById('skPanel');
    const trigger = document.getElementById('skTrigger');
    if (panel)  panel.classList.remove('open');
    if (trigger) trigger.classList.remove('open');
}
document.addEventListener('click', e => {
    const wrap = document.getElementById('skWrap');
    if (wrap && !wrap.contains(e.target)) {
        const panel  = document.getElementById('skPanel');
        const trigger = document.getElementById('skTrigger');
        if (panel)  panel.classList.remove('open');
        if (trigger) trigger.classList.remove('open');
    }
});

function populateTespitYeriDropdown() {
    _tespitYeriAllList = [...new Set(allData.map(r => r.tespitYeri).filter(v => v !== '' && v !== undefined && v !== null))].sort();
    _buildTespitYeriItems();
}

function _buildTespitYeriItems() {
    const container = document.getElementById('tespitList');
    if (!container) return;
    container.innerHTML = '';
    if (!_tespitYeriAllList.length) {
        container.innerHTML = '<div style="padding:10px 12px;color:#aaa;font-size:0.83em;">Veri yok</div>';
        return;
    }
    _tespitYeriAllList.forEach(val => {
        const isSelected = selectedTespitYeriSet.has(val);
        const row = document.createElement('div');
        row.className = 'tespit-list-item' + (isSelected ? ' ty-selected' : '');
        row.onclick = () => toggleTespitYeriItem(val);

        const chk = document.createElement('input');
        chk.type = 'checkbox';
        chk.className = 'tespit-chk';
        chk.checked = isSelected;
        chk.addEventListener('click', e => e.stopPropagation());
        chk.addEventListener('change', () => toggleTespitYeriItem(val));

        const lbl = document.createElement('span');
        lbl.style.flex = '1';
        lbl.textContent = val;

        row.appendChild(chk);
        row.appendChild(lbl);
        container.appendChild(row);
    });
}

function toggleTespitYeriItem(val) {
    if (selectedTespitYeriSet.has(val)) selectedTespitYeriSet.delete(val);
    else selectedTespitYeriSet.add(val);
    _updateTespitYeriLabel();
    _buildTespitYeriItems();
}

function _updateTespitYeriLabel() {
    const el = document.getElementById('tespitSelectedText');
    if (!el) return;
    if (selectedTespitYeriSet.size === 0) {
        el.textContent = 'Tümü';
    } else if (selectedTespitYeriSet.size === 1) {
        el.textContent = [...selectedTespitYeriSet][0];
    } else {
        el.textContent = `${selectedTespitYeriSet.size} seçili`;
    }
}

function toggleTespitDropdown() {
    const panel = document.getElementById('tespitPanel');
    if (!panel) return;
    panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
    if (panel.style.display === 'block') _buildTespitYeriItems();
}

function resetTespitYeri() {
    selectedTespitYeriSet.clear();
    _updateTespitYeriLabel();
    _buildTespitYeriItems();
}

// ─── Custom Cari Dropdown ─────────────────────────────────────────────────
function populateCariDropdown() {
    _cariAllList = [...new Set(allData.map(r => r.cariAdi).filter(v => v))].sort();
    _buildCariItems(_cariAllList);
}

function filterCariList() {
    const q = (document.getElementById('cariSearch').value || '').toLowerCase();
    const filtered = q ? _cariAllList.filter(c => c.toLowerCase().includes(q)) : _cariAllList;
    _buildCariItems(filtered);
}

function _buildCariItems(list) {
    const container = document.getElementById('cariList');
    container.innerHTML = '';
    if (!list.length) {
        container.innerHTML = '<div style="padding:12px;color:#aaa;text-align:center;font-size:0.85em;">Sonuç yok</div>';
        return;
    }
    list.forEach(c => {
        const isMusteri = musteriSet.has(c);
        const isSelected = selectedCari === c;
        const row = document.createElement('div');
        row.className = 'cari-list-item' + (isSelected ? ' selected' : '');

        const chk = document.createElement('input');
        chk.type = 'checkbox';
        chk.className = 'cari-musteri-chk';
        chk.title = 'Müşteri olarak işaretle';
        chk.checked = isMusteri;
        chk.addEventListener('change', e => { e.stopPropagation(); toggleMusteriMark(c, e.target.checked); });

        const star = document.createElement('span');
        star.style.cssText = 'font-size:0.78em;color:#e07000;flex-shrink:0;';
        star.textContent = '★';
        star.title = 'Müşteri olarak işaretle';
        star.style.cursor = 'pointer';
        star.addEventListener('click', e => { e.stopPropagation(); chk.click(); });

        const nameSp = document.createElement('span');
        nameSp.className = 'cari-item-name';
        nameSp.textContent = c;
        nameSp.addEventListener('click', () => {
            selectCari(selectedCari === c ? '' : c);
            document.getElementById('cariPanel').style.display = 'none';
        });

        row.appendChild(chk);
        row.appendChild(star);
        row.appendChild(nameSp);

        if (isMusteri) {
            const badge = document.createElement('span');
            badge.className = 'cari-badge';
            badge.textContent = 'Müşteri';
            row.appendChild(badge);
        }
        container.appendChild(row);
    });
}

function toggleCariDropdown() {
    const panel = document.getElementById('cariPanel');
    if (panel.style.display === 'block') {
        panel.style.display = 'none';
    } else {
        panel.style.display = 'block';
        document.getElementById('cariSearch').value = '';
        document.getElementById('cariSearch').focus();
        _buildCariItems(_cariAllList);
    }
}

function selectCari(val) {
    selectedCari = val;
    document.getElementById('cariSelectedText').textContent = val || 'Tümü';
    // Tedarikçi analiz butonunu göster/gizle
    const ab = document.getElementById('cariAnalyzeBtn');
    if (ab) ab.style.display = val ? 'flex' : 'none';
    // Rebuild visible list to update selected highlight
    const q = (document.getElementById('cariSearch')?.value || '').toLowerCase();
    const filtered = q ? _cariAllList.filter(c => c.toLowerCase().includes(q)) : _cariAllList;
    _buildCariItems(filtered);
}

function toggleMusteriMark(cariAdi, isMus) {
    if (isMus) musteriSet.add(cariAdi);
    else musteriSet.delete(cariAdi);
    const arr = [...musteriSet];
    // localStorage (birincil - hızlı ve güvenilir)
    try { localStorage.setItem('uyg_musteriSet', JSON.stringify(arr)); } catch(e) {}
    // IndexedDB (yedek)
    dbSet('musteriSet', arr);
    const q = (document.getElementById('cariSearch')?.value || '').toLowerCase();
    const filtered = q ? _cariAllList.filter(c => c.toLowerCase().includes(q)) : _cariAllList;
    _buildCariItems(filtered);
}

// Dropdown dışına tıklayınca kapat
document.addEventListener('click', e => {
    const dd = document.getElementById('cariDropdown');
    if (dd && !dd.contains(e.target)) {
        const panel = document.getElementById('cariPanel');
        if (panel) panel.style.display = 'none';
    }
    const tdd = document.getElementById('tespitDropdown');
    if (tdd && !tdd.contains(e.target)) {
        const tpanel = document.getElementById('tespitPanel');
        if (tpanel) tpanel.style.display = 'none';
    }
});

function parseDateStr(val) {
    if (!val) return null;
    // Try yyyy-mm-dd or dd.mm.yyyy or dd/mm/yyyy
    let m;
    if ((m = String(val).match(/^(\d{4})-(\d{2})-(\d{2})/))) return `${m[1]}-${m[2]}-${m[3]}`;
    if ((m = String(val).match(/^(\d{2})[.\/](\d{2})[.\/](\d{4})/))) return `${m[3]}-${m[2]}-${m[1]}`;
    return null;
}

// ─── Stats ───────────────────────────────────────────────────────────────────
function updateStats() {
    const total = filteredData.length;
    const hatali = filteredData.reduce((s, r) => s + (Number(r.hataliMiktar) || 0), 0);
    const partiHacmi = filteredData.reduce((s, r) => s + (Number(r.partiHacmi) || 0), 0);
    const hataTipleri = new Set(filteredData.map(r => r.hataTipi).filter(Boolean)).size;
    const cariler = new Set(filteredData.map(r => r.cariAdi).filter(Boolean)).size;
    const ppm = partiHacmi > 0 ? Math.round((hatali / partiHacmi) * 1_000_000) : 0;
    document.getElementById('statTotal').textContent = total.toLocaleString('tr');
    document.getElementById('statHataliMiktar').textContent = hatali.toLocaleString('tr', {maximumFractionDigits:1});
    document.getElementById('statHataTipi').textContent = hataTipleri;
    document.getElementById('statCari').textContent = cariler;
    document.getElementById('statPPM').textContent = ppm.toLocaleString('tr');
}

// ─── Pareto ───────────────────────────────────────────────────────────────────
function renderPareto() {
    const metric      = document.getElementById('paretoMetric').value;
    const topN        = parseInt(document.getElementById('paretoTop').value);
    const groupKey    = document.getElementById('paretoGroup').value;
    const threshold   = parseInt(document.getElementById('paretoThreshold').value);
    const groupOthers = document.getElementById('paretoGroupOthers').checked;

    // Aggregate (excluded hataTipleri hariç)
    const paretoSource = excludedHataTipleri.size > 0
        ? filteredData.filter(r => !excludedHataTipleri.has(r.hataTipi || '(Belirtilmemiş)'))
        : filteredData;

    const agg = {};
    paretoSource.forEach(r => {
        const key = r[groupKey] || '(Belirtilmemiş)';
        if (!agg[key]) agg[key] = { count: 0, hatali: 0 };
        agg[key].count++;
        agg[key].hatali += Number(r.hataliMiktar) || 0;
    });

    let allEntries = Object.entries(agg).map(([k, v]) => ({
        label: k,
        value: metric === 'hataliMiktar' ? v.hatali : v.count,
        count: v.count,
        hatali: v.hatali,
    })).sort((a, b) => b.value - a.value);

    let entries;
    if (groupOthers) {
        // Önce topN uygula (Tümü = 999 ise tüm liste)
        const topSlice = topN < allEntries.length ? allEntries.slice(0, topN) : allEntries;
        // Eşik yüzdesine göre kesim noktası bul
        const totalVal = topSlice.reduce((s, e) => s + e.value, 0);
        let cum2 = 0;
        let threshCut = topSlice.length; // varsayılan: hepsi ana
        for (let i = 0; i < topSlice.length; i++) {
            cum2 += topSlice[i].value;
            if ((cum2 / (totalVal || 1)) * 100 >= threshold) {
                threshCut = i + 1;
                break;
            }
        }
        const mainEntries = topSlice.slice(0, threshCut);
        // topN sınırı dışındaki + eşik üstündeki tüm girişleri "Diğer"e ekle
        const restEntries = [
            ...topSlice.slice(threshCut),
            ...(topN < allEntries.length ? allEntries.slice(topN) : []),
        ];
        if (restEntries.length > 0) {
            const restVal = restEntries.reduce((s, e) => s + e.value, 0);
            mainEntries.push({
                label: `Diğer (${restEntries.length} kategori)`,
                value: restVal,
                count: restEntries.reduce((s, e) => s + e.count, 0),
                hatali: restEntries.reduce((s, e) => s + e.hatali, 0),
                isOther: true,
            });
        }
        entries = mainEntries;
    } else {
        entries = topN < allEntries.length ? allEntries.slice(0, topN) : allEntries;
    }

    const total = entries.reduce((s, e) => s + e.value, 0);
    let cum = 0;
    const cumPct = entries.map(e => { cum += e.value; return +(cum / total * 100).toFixed(1); });

    // Insight
    const threshIdx = cumPct.findIndex(p => p >= threshold);
    const insightEl = document.getElementById('paretoInsight');
    if (threshIdx >= 0 && entries.length > 0) {
        const mainCount = entries[threshIdx].isOther ? threshIdx : threshIdx + 1;
        insightEl.innerHTML = `📌 <strong>Pareto Kuralı:</strong> İlk <strong>${mainCount}</strong> kategori (toplam ${entries.filter(e=>!e.isOther).length} içinden), tüm ${metric === 'hataliMiktar' ? 'hatalı miktarın' : 'kaydın'} <strong>%${threshold}</strong>'${threshold===80?'i':threshold===70?'i':threshold===60?'sı':'u'} oluşturmaktadır. Bu kategorilere odaklanmak en büyük iyileştirmeyi sağlar.`;
    } else {
        insightEl.innerHTML = '';
    }

    const labels = entries.map(e => e.label);
    const values = entries.map(e => e.value);

    // Colors: normal bars = seçilen renk şeması, 'Diğer' bar = gri; seçilmeyenler soluk
    const _baseColors = getParetoBarColors(entries);
    const barColors = _baseColors.map((c, i) =>
        (_paretoSelected.size > 0 && !_paretoSelected.has(entries[i].label))
            ? 'rgba(180,180,180,0.22)'
            : c
    );

    if (paretoChartInst) { paretoChartInst.destroy(); paretoChartInst = null; }

    // Data labels plugin — draws values on top of each bar
    const _showLabels = document.getElementById('paretoShowLabels').checked;
    const _metric = metric;
    const pluginDataLabels = {
        id: 'barDataLabels',
        afterDatasetsDraw(chart) {
            if (!_showLabels) return;
            const { ctx, data, scales } = chart;
            const barDs = chart.data.datasets.findIndex(ds => ds.type === 'bar');
            if (barDs < 0) return;
            const meta = chart.getDatasetMeta(barDs);
            ctx.save();
            ctx.font = 'bold 11px Segoe UI, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            meta.data.forEach((bar, i) => {
                const val = data.datasets[barDs].data[i];
                if (val == null || val === 0) return;
                const formatted = Number(val) >= 1000
                    ? Number(val).toLocaleString('tr', { maximumFractionDigits: 0 })
                    : Number(val).toLocaleString('tr', { maximumFractionDigits: 1 });
                const x = bar.x;
                const y = bar.y - 4;
                // shadow for readability
                ctx.fillStyle = 'rgba(255,255,255,0.75)';
                ctx.fillText(formatted, x + 1, y + 1);
                ctx.fillStyle = '#4a0a6b';
                ctx.fillText(formatted, x, y);
            });
            ctx.restore();
        }
    };

    // Threshold reference line — inline plugin (closure captures current threshold)
    const _thresholdVal = threshold;
    const plugin80 = {
        id: 'line80',
        afterDraw(chart) {
            const { ctx, scales } = chart;
            if (!scales.y2) return;
            const y = scales.y2.getPixelForValue(_thresholdVal);
            ctx.save();
            ctx.setLineDash([6, 4]);
            ctx.strokeStyle = 'rgba(185,79,196,0.55)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(scales.x.left, y);
            ctx.lineTo(scales.x.right, y);
            ctx.stroke();
            ctx.restore();
        }
    };

    const ctx = document.getElementById('paretoChart').getContext('2d');
    paretoChartInst = new Chart(ctx, {
        plugins: [pluginDataLabels, plugin80],
        data: {
            labels,
            datasets: [
                {
                    type: 'bar',
                    label: metric === 'hataliMiktar' ? 'Hatalı Miktar' : 'Kayıt Sayısı',
                    data: values,
                    backgroundColor: barColors,
                    borderColor: barColors.map(c => c.replace('0.82', '1')),
                    borderWidth: 1,
                    yAxisID: 'y',
                    order: 2,
                },
                {
                    type: 'line',
                    label: 'Kümülatif %',
                    data: cumPct,
                    borderColor: '#4a0a6b',
                    backgroundColor: 'rgba(74,10,107,0.08)',
                    borderWidth: 2.5,
                    pointBackgroundColor: '#b94fc4',
                    pointRadius: 4,
                    tension: 0.3,
                    yAxisID: 'y2',
                    fill: false,
                    order: 1,
                },
            ],
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false },
            onClick: (evt, els) => {
                const barEl = els && els.find(e => e.datasetIndex === 0);
                if (!barEl) return;
                const lbl = labels[barEl.index];
                if (_paretoSelected.has(lbl)) _paretoSelected.delete(lbl);
                else _paretoSelected.add(lbl);
                _updateParetoSelChips();
                renderPareto();
            },
            onHover: (evt, els) => {
                const barEl = els && els.find(e => e.datasetIndex === 0);
                if (evt.native && evt.native.target)
                    evt.native.target.style.cursor = barEl ? 'pointer' : 'default';
            },
            plugins: {
                legend: { position: 'top', labels: { font: { size: 12 }, color: '#333' } },
                tooltip: {
                    callbacks: {
                        label: (ctx) => {
                            if (ctx.datasetIndex === 1) {
                                return `Kümülatif: %${ctx.parsed.y}`;
                            }
                            const val = Number(ctx.parsed.y);
                            const formatted = val >= 1000
                                ? val.toLocaleString('tr', { maximumFractionDigits: 0 })
                                : val.toLocaleString('tr', { maximumFractionDigits: 2 });
                            return `${ctx.dataset.label}: ${formatted}`;
                        }
                    }
                },
                annotation: {
                    // 80% line approximation via dataset
                },
            },
            scales: {
                x: {
                    ticks: {
                        maxRotation: 45,
                        minRotation: 30,
                        font: { size: 11 },
                        callback: function(val, idx) {
                            const lbl = labels[idx];
                            return lbl.length > 22 ? lbl.substring(0, 20) + '…' : lbl;
                        }
                    },
                    grid: { display: false },
                },
                y: {
                    type: 'linear',
                    position: 'left',
                    title: {
                        display: true,
                        text: metric === 'hataliMiktar' ? 'Hatalı Miktar' : 'Kayıt Sayısı',
                        color: '#555',
                    },
                    grid: { color: '#eee' },
                },
                y2: {
                    type: 'linear',
                    position: 'right',
                    min: 0, max: 100,
                    title: { display: true, text: 'Kümülatif (%)', color: '#4a0a6b' },
                    grid: { display: false },
                    ticks: {
                        callback: v => v + '%',
                        color: '#4a0a6b',
                    },
                },
            },
        },
    });

}

// ─── Pareto Color Helpers ─────────────────────────────────────────────────────
function onParetoColorSchemeChange() {
    const scheme = document.getElementById('paretoColorScheme').value;
    const customDiv = document.getElementById('paretoCustomColors');
    customDiv.style.display = scheme === 'custom' ? 'flex' : 'none';
    renderPareto();
}

function hexToRgb(hex) {
    const r = parseInt(hex.slice(1,3),16);
    const g = parseInt(hex.slice(3,5),16);
    const b = parseInt(hex.slice(5,7),16);
    return {r, g, b};
}

function lerpColor(c1, c2, t) {
    return {
        r: Math.round(c1.r + (c2.r - c1.r) * t),
        g: Math.round(c1.g + (c2.g - c1.g) * t),
        b: Math.round(c1.b + (c2.b - c1.b) * t),
    };
}

function getParetoBarColors(entries) {
    const scheme = (document.getElementById('paretoColorScheme') || {}).value || 'default';
    const n = entries.length;
    return entries.map((e, i) => {
        if (e.isOther) return 'rgba(160,160,160,0.65)';
        const t = n > 1 ? i / (n - 1) : 0;
        let c;
        if (scheme === 'default') {
            const r = Math.max(60, 185 - i * 8);
            return `rgba(${r}, 50, ${Math.min(180, 100 + i * 6)}, 0.82)`;
        } else if (scheme === 'blue') {
            c = lerpColor({r:29,g:78,b:216}, {r:147,g:197,b:253}, t);
        } else if (scheme === 'green') {
            c = lerpColor({r:21,g:128,b:61}, {r:134,g:239,b:172}, t);
        } else if (scheme === 'orange') {
            c = lerpColor({r:194,g:65,b:12}, {r:253,g:186,b:116}, t);
        } else if (scheme === 'red') {
            c = lerpColor({r:185,g:28,b:28}, {r:252,g:165,b:165}, t);
        } else if (scheme === 'rainbow') {
            const hue = Math.round(t * 300);
            return `hsla(${hue}, 80%, 50%, 0.82)`;
        } else if (scheme === 'custom') {
            const h1 = (document.getElementById('paretoColor1') || {}).value || '#b94fc4';
            const h2 = (document.getElementById('paretoColor2') || {}).value || '#3b82f6';
            c = lerpColor(hexToRgb(h1), hexToRgb(h2), t);
        } else {
            const r2 = Math.max(60, 185 - i * 8);
            return `rgba(${r2}, 50, ${Math.min(180, 100 + i * 6)}, 0.82)`;
        }
        return `rgba(${c.r},${c.g},${c.b},0.85)`;
    });
}

// ─── Pareto Selection Chip Helpers ──────────────────────────────────────────
function _updateParetoSelChips() {
    const wrap = document.getElementById('paretoSelChips');
    if (!wrap) return;
    if (_paretoSelected.size === 0) {
        wrap.innerHTML = '<span class="psc-hint">💡 Bara tıklayarak seçin — seçilenler kapsamlı rapora dahil edilir. Seçim yoksa tüm filtreli veri gider.</span>';
        return;
    }
    const chips = [..._paretoSelected].map(lbl => {
        const safeL = lbl.replace(/\\/g,'\\\\').replace(/'/g,"\\'");
        return `<span class="psc-chip">${lbl}<button onclick="_paretoToggleSel('${safeL}')" title="Kaldır">×</button></span>`;
    }).join('');
    wrap.innerHTML = `<span class="psc-label">📌 Seçili (${_paretoSelected.size}):</span>${chips}<button class="psc-clear" onclick="_paretoClearSel()">✕ Seçimi Temizle</button>`;
}
function _paretoToggleSel(lbl) {
    if (_paretoSelected.has(lbl)) _paretoSelected.delete(lbl);
    else _paretoSelected.add(lbl);
    _updateParetoSelChips();
    renderPareto();
}
function _paretoClearSel() {
    _paretoSelected.clear();
    _updateParetoSelChips();
    renderPareto();
}

function downloadChartPNG() {
    if (!paretoChartInst) return;
    const src = paretoChartInst.canvas;
    const tmp = document.createElement('canvas');
    tmp.width  = src.width;
    tmp.height = src.height;
    const ctx2 = tmp.getContext('2d');
    ctx2.fillStyle = '#ffffff';
    ctx2.fillRect(0, 0, tmp.width, tmp.height);
    ctx2.drawImage(src, 0, 0);
    const a = document.createElement('a');
    a.href = tmp.toDataURL('image/png', 1);
    a.download = 'pareto-analizi.png';
    a.click();
}

// ─── Breakdown ────────────────────────────────────────────────────────────────
function renderBreakdown() {
    const agg = {};
    const totalHatali = filteredData.reduce((s, r) => s + (Number(r.hataliMiktar) || 0), 0);
    filteredData.forEach(r => {
        const k = r.hataTipi || '(Belirtilmemiş)';
        if (!agg[k]) agg[k] = { count: 0, hatali: 0 };
        agg[k].count++;
        agg[k].hatali += Number(r.hataliMiktar) || 0;
    });
    const sorted = Object.entries(agg).sort((a, b) => b[1].hatali - a[1].hatali);
    const maxHatali = sorted[0] ? sorted[0][1].hatali : 1;
    // Özellik 3: Aksiyon geri besleme
    let aksiyonlar = {};
    try { aksiyonlar = JSON.parse(localStorage.getItem('fishbone_aksiyonlar') || '{}'); } catch(e) {}

    const grid = document.getElementById('breakdownGrid');
    if (!sorted.length) { grid.innerHTML = '<p style="color:#aaa;font-size:0.9em;">Veri yok</p>'; return; }
    grid.innerHTML = sorted.map(([k, v]) => {
        const pct = totalHatali > 0 ? (v.hatali / totalHatali * 100).toFixed(1) : 0;
        const barW = maxHatali > 0 ? (v.hatali / maxHatali * 100).toFixed(1) : 0;
        const isExcluded = excludedHataTipleri.has(k);
        const isSelectedMulti = selectedForMulti.has(k);
        const safeKey = k.replace(/"/g, '&quot;');
        const aksiyon = aksiyonlar[k] || 0;
        const aksiyonBadge = aksiyon > 0 ? `<span class="bi-aksiyon-badge">📋 ${aksiyon} aksiyon</span>` : '';
        const multiAttr = multiAnalyzeMode ? `onclick="toggleMultiSelect('${safeKey}')" style="cursor:pointer;"` : '';
        return `<div class="breakdown-item${isExcluded ? ' excluded' : ''}${isSelectedMulti ? ' selected-for-multi' : ''}" id="bdi-${btoa(encodeURIComponent(k)).replace(/=/g,'')}" ${multiAttr}>
            <div class="bi-header">
                <div class="bi-name">${k}${aksiyonBadge}</div>
                <input type="checkbox" class="bi-checkbox" data-key="${safeKey}" title="Tüm grafiklere dahil et" ${isExcluded ? '' : 'checked'} onchange="toggleHataTipi('${safeKey}', this.checked)" ${multiAnalyzeMode ? 'style="pointer-events:none;"' : ''}>
            </div>
            <div class="bi-count">${v.hatali.toLocaleString('tr', {maximumFractionDigits:1})}</div>
            <div class="bi-pct">%${pct} · ${v.count} kayıt</div>
            <div class="bi-bar"><div class="bi-bar-fill" style="width:${barW}%"></div></div>
            <button class="bi-fishbone-btn" onclick="openFishbone('${safeKey}', ${v.count}, ${v.hatali}, '${pct}')" title="Bu hatayı balık kılçığı diyagramında analiz et">🐟 Balık Kılçığı'nda Analiz Et</button>
        </div>`;
    }).join('');
}

function toggleHataTipi(key, checked) {
    if (checked) {
        excludedHataTipleri.delete(key);
    } else {
        excludedHataTipleri.add(key);
    }
    // Kart görünümünü güncelle
    const safeId = 'bdi-' + btoa(encodeURIComponent(key)).replace(/=/g,'');
    const card = document.getElementById(safeId);
    if (card) card.classList.toggle('excluded', !checked);
    // Sadece Pareto grafiğini güncelle
    renderPareto();
}

// ─── Yardımcı: bir alan için en sık N değeri döndür ───────────────────────────
function topNField(rows, field, n = 5) {
    const cnt = {};
    rows.forEach(r => { const v = (r[field] || '').trim(); if (v) cnt[v] = (cnt[v] || 0) + 1; });
    return Object.entries(cnt).sort((a, b) => b[1] - a[1]).slice(0, n).map(e => e[0]);
}

// Contribution oranıyla birlikte top-N — hatali miktar bazlı
function topNFieldWithContrib(rows, field, n = 5) {
    const agg = {};
    const totalHatali = rows.reduce((s, r) => s + (Number(r.hataliMiktar) || 0), 0) || 1;
    rows.forEach(r => {
        const v = (r[field] || '').trim();
        if (!v) return;
        if (!agg[v]) agg[v] = { count: 0, hatali: 0 };
        agg[v].count++;
        agg[v].hatali += Number(r.hataliMiktar) || 0;
    });
    return Object.entries(agg)
        .sort((a, b) => b[1].hatali - a[1].hatali)
        .slice(0, n)
        .map(([name, v]) => {
            const pct = (v.hatali / totalHatali * 100).toFixed(1);
            return { name, displayName: `${name} (%${pct})`, pct: Number(pct), count: v.count, hatali: v.hatali };
        });
}

// 6M anahtar kelime sınıflandırıcı
// hataKaynagi değerlerini içeriklerine göre 6 kemiğe dağıtır
function classify6M(rows) {
    const RULES = [
        { bone: 'insan',   kws: ['işçi','işcilik','iscilik','operatör','operator','personel','eğitim','egitim','dikkatsiz','ihmal','çalışan','calisan','insan','adam','yorgun','tecrübe','tecrubesiz'] },
        { bone: 'malzeme', kws: ['hammadde','ham madde','malzeme kalite','malzeme','tedarikçi','tedarikci','hammad','kalitesiz','stok','yar mamul','yarı mamul'] },
        { bone: 'metot',   kws: ['hatalı talimat','hatali talimat','prosedür','prosedur','yöntem','yontem','süreç','surec','standart','talimat','instruks','uygulama hatası'] },
        { bone: 'makine',  kws: ['makine','ekipman','kalibrasyon','arıza','ariza','bakım','bakim','tertibat','aparat','kalıp','kalip','pres','hidrolik'] },
        { bone: 'olcum',   kws: ['ölçüm','olcum','muayene','kontrol','test','ölçme','tolerans'] },
        { bone: 'ortam',   kws: ['sevkiyat','depolama','nakliye','çevre','cevre','sıcaklık','sicaklik','nem','ortam','ambalaj'] },
    ];

    const totalHatali = rows.reduce((s, r) => s + (Number(r.hataliMiktar) || 0), 0) || 1;
    const agg = {};
    rows.forEach(r => {
        const v = (r.hataKaynagi || '').trim();
        if (!v) return;
        if (!agg[v]) agg[v] = { count: 0, hatali: 0 };
        agg[v].count++;
        agg[v].hatali += Number(r.hataliMiktar) || 0;
    });

    const result = { insan: [], malzeme: [], metot: [], makine: [], olcum: [], ortam: [] };
    Object.entries(agg).forEach(([name, v]) => {
        const lower = name.toLowerCase();
        let bone = null; // eşleşme yoksa null — sınıflandırılamayan
        for (const rule of RULES) {
            if (rule.kws.some(kw => lower.includes(kw))) { bone = rule.bone; break; }
        }
        if (!bone) return; // sınıflandırılamayanları atlıyoruz (diyagramı kirletmesin)
        const pct = (v.hatali / totalHatali * 100).toFixed(1);
        result[bone].push({ name, displayName: `${name} (%${pct})`, pct: Number(pct), count: v.count, hatali: v.hatali });
    });
    for (const k of Object.keys(result)) result[k].sort((a, b) => b.hatali - a.hatali);
    return result;
}

function openFishbone(hataTipi, count, hatali, pct) {
    const fTarih1 = (document.getElementById('fDateStart') || {}).value || '';
    const fTarih2 = (document.getElementById('fDateEnd')   || {}).value || '';
    const fCariTip = (document.getElementById('fCariTip')  || {}).value || '';
    const tarihBilgi = (fTarih1 || fTarih2) ? `\n• Tarih aralığı: ${fTarih1 || '—'} / ${fTarih2 || '—'}` : '';
    const cariBilgi = fCariTip && fCariTip !== 'tumu' ? `\n• Cari tipi: ${fCariTip}` : '';

    // Özellik 4: Trend tespiti (son 90 gün vs önceki 90 gün)
    const relRows = filteredData.filter(r => r.hataTipi === hataTipi);
    const now = new Date();
    const d90  = new Date(now.getTime() - 90  * 86400000);
    const d180 = new Date(now.getTime() - 180 * 86400000);
    let trendBilgi = '';
    try {
        const currH = relRows.filter(r => { const d = parseDateStr(r.uygunsuzlukTarih); return d && d >= d90; })
                             .reduce((s,r)=>s+(Number(r.hataliMiktar)||0),0);
        const prevH = relRows.filter(r => { const d = parseDateStr(r.uygunsuzlukTarih); return d && d >= d180 && d < d90; })
                             .reduce((s,r)=>s+(Number(r.hataliMiktar)||0),0);
        if (prevH > 0 && currH > 0) {
            const delta = Math.round((currH - prevH) / prevH * 100);
            if (delta >= 20)  trendBilgi = `\n⚠️ Yükselen trend: son 90 günde +%${delta} artış`;
            else if (delta <= -20) trendBilgi = `\n📉 Düşen trend: son 90 günde %${Math.abs(delta)} azalış`;
        }
    } catch(e) {}

    const desc = `Uygunsuzluk Analizi verilerinden aktarıldı.\n• Hatalı miktar: ${Number(hatali).toLocaleString('tr', {maximumFractionDigits:1})} adet (%${pct})\n• Kayıt sayısı: ${count}${tarihBilgi}${cariBilgi}${trendBilgi}`;

    // Özellik 2: 6M kemikleri — hataKaynagi anahtar kelimeye göre otomatik sınıflandırılır
    const BONE_COLORS = ['#ef4444','#f59e0b','#3b82f6','#8b5cf6','#06b6d4','#22c55e'];
    let _nid = 1; const mkId = () => _nid++;
    const mkChildren = (items, color) => (items||[]).slice(0,6).map(item => ({
        id:mkId(),
        name: item.displayName || item.name || item,
        color, children:[], collapsed:false,
        offsetX:0, offsetY:0,
        _contrib: item.pct || null
    }));

    // hataKaynagi -> 6M anahtar kelime sınıflandırması
    const cls = classify6M(relRows);

    // Diğer alanlarda da katkı oranı
    const causes = [
        { name:'👤 İnsan',   desc:'Hata kaynağı → insan kaynaklı',        color:BONE_COLORS[0], side:'top',
          children: mkChildren(cls.insan, BONE_COLORS[0]) },
        { name:'⚙️ Makine',  desc:'Makine/ekipman kaynaklı',         color:BONE_COLORS[1], side:'bottom',
          children: mkChildren(cls.makine, BONE_COLORS[1]) },
        { name:'📦 Malzeme', desc:'Etkilenen stoklar + malzeme kaynaklı', color:BONE_COLORS[2], side:'top',
          children: [
            ...mkChildren(topNFieldWithContrib(relRows,'stokAdi',3), BONE_COLORS[2]),
            ...mkChildren(topNFieldWithContrib(relRows,'cariAdi',2), BONE_COLORS[2]),
            ...mkChildren(cls.malzeme, BONE_COLORS[2])
          ].slice(0,6) },
        { name:'📋 Metot',   desc:'Metot / süreç kaynaklı',            color:BONE_COLORS[3], side:'bottom',
          children: mkChildren(cls.metot, BONE_COLORS[3]) },
        { name:'📐 Ölçüm',  desc:'Ölçüm / muayene kaynaklı',          color:BONE_COLORS[4], side:'top',
          children: mkChildren(cls.olcum, BONE_COLORS[4]) },
        { name:'🌡️ Ortam',  desc:'Tespit yeri + ortam kaynaklı',      color:BONE_COLORS[5], side:'bottom',
          children: [
            ...mkChildren(topNFieldWithContrib(relRows,'tespitYeri',3), BONE_COLORS[5]),
            ...mkChildren(cls.ortam, BONE_COLORS[5])
          ].slice(0,6) },
    ].map(b => ({ ...b, id:mkId(), collapsed:false, offsetX:0, offsetY:0, baseOffsetX:0, baseOffsetY:0 }));

    localStorage.setItem('fishbone_incoming', JSON.stringify({
        problem: hataTipi, problemDesc: desc,
        source: 'uygunsuzluk-analizi',
        causes, nextId: _nid,
        meta: { hataTipi, count, hatali, pct }
    }));
    localStorage.setItem('fishbone_source', 'uygunsuzluk-analizi');
    window.open('balik-kilcigi.html', '_blank');
}

// Kapsamlı Rapor — IndexedDB üzerinden iletim
const _RIDB = { name:'KaliteRaporDB', store:'payloads', key:'rapor_payload', ver:1 };
function _rIdbOpen() {
    return new Promise((res, rej) => {
        const r = indexedDB.open(_RIDB.name, _RIDB.ver);
        r.onupgradeneeded = e => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains(_RIDB.store))
                db.createObjectStore(_RIDB.store);
        };
        r.onsuccess = e => res(e.target.result);
        r.onerror   = () => rej(r.error);
        r.onblocked = () => console.warn('IDB blocked — başka bir sekme kapatılmayı bekliyor');
    });
}
function _rIdbSave(data) {
    return _rIdbOpen().then(db => new Promise((res, rej) => {
        const tx = db.transaction(_RIDB.store, 'readwrite');
        tx.objectStore(_RIDB.store).put(data, _RIDB.key);
        tx.oncomplete = () => { db.close(); res(); };
        tx.onerror    = () => { db.close(); rej(tx.error); };
    }));
}
function _rIdbGet(key) {
    return _rIdbOpen().then(db => new Promise(res => {
        const g = db.transaction(_RIDB.store,'readonly').objectStore(_RIDB.store).get(key);
        g.onsuccess = () => { db.close(); res(g.result ?? null); };
        g.onerror   = () => { db.close(); res(null); };
    }));
}
function _rIdbGetAllKeys() {
    return _rIdbOpen().then(db => new Promise(res => {
        const r = db.transaction(_RIDB.store,'readonly').objectStore(_RIDB.store).getAllKeys();
        r.onsuccess = () => { db.close(); res(r.result || []); };
        r.onerror   = () => { db.close(); res([]); };
    })).catch(() => []);
}
function _rIdbPut(key, value) {
    return _rIdbOpen().then(db => new Promise((res, rej) => {
        const tx = db.transaction(_RIDB.store, 'readwrite');
        tx.objectStore(_RIDB.store).put(value, key);
        tx.oncomplete = () => { db.close(); res(); };
        tx.onerror    = () => { db.close(); rej(tx.error); };
    }));
}
function _rIdbDel(key) {
    return _rIdbOpen().then(db => new Promise(res => {
        const tx = db.transaction(_RIDB.store,'readwrite');
        tx.objectStore(_RIDB.store).delete(key);
        tx.oncomplete = () => { db.close(); res(); };
        tx.onerror    = () => { db.close(); res(); };
    }));
}

// Snapshot list modal for uygunsuzluk-analizi
const _UA_SNAPS_KEY = 'kr_snapshots'; // same key as kapsamli-rapor.html
const _UA_FILTERS_KEY = 'ua_saved_filters';

// ─── Filtre Kaydet / Yükle ─────────────────────────────────────────────────
async function saveCurrentFilter() {
    const name = prompt('Bu filtre için bir isim girin:', 'Filtre ' + new Date().toLocaleDateString('tr-TR'));
    if (!name || !name.trim()) return;
    const state = {
        tipi:             document.getElementById('fTipi').value,
        hataTipi:         document.getElementById('fHataTipi').value,
        hataKaynagi:      document.getElementById('fHataKaynagi').value,
        uygunsuzlukTuru:  document.getElementById('fUygunsuzlukTuru').value,
        makine:           document.getElementById('fMakine').value,
        stokKodu:         document.getElementById('fStokKodu').value,
        dateStart:        document.getElementById('fDateStart').value,
        dateEnd:          document.getElementById('fDateEnd').value,
        cariTip:          document.getElementById('fCariTip').value,
        selectedCari:     selectedCari,
        tespitYeri:       [...selectedTespitYeriSet]
    };
    const list = (await _rIdbGet(_UA_FILTERS_KEY)) || [];
    list.push({ id: Date.now(), name: name.trim(), savedAt: new Date().toLocaleString('tr-TR'), state });
    await _rIdbPut(_UA_FILTERS_KEY, list);
    showToast('Filtre kaydedildi: ' + name.trim(), 'success');
}

async function openSavedFiltersModal() {
    const list = (await _rIdbGet(_UA_FILTERS_KEY)) || [];
    const el = document.getElementById('uaFiltreList');
    if (!list.length) {
        el.innerHTML = '<div style="padding:20px;text-align:center;color:#94a3b8;font-size:.85rem;">Kayıtlı filtre bulunamadı.</div>';
    } else {
        el.innerHTML = list.slice().reverse().map(f => `
            <div class="filtre-save-row">
                <div class="filtre-save-info">
                    <div class="filtre-save-name">${_uaEsc(f.name)}</div>
                    <div class="filtre-save-meta">${_uaEsc(f.savedAt)}</div>
                </div>
                <div class="filtre-save-btns">
                    <button class="ua-snap-btn ua-snap-load" onclick="applySavedFilter(${f.id})">▶ Uygula</button>
                    <button class="ua-snap-btn ua-snap-del" onclick="deleteSavedFilter(${f.id})">🗑 Sil</button>
                </div>
            </div>`).join('');
    }
    document.getElementById('uaFiltreModal').classList.add('open');
}

async function applySavedFilter(id) {
    const list = (await _rIdbGet(_UA_FILTERS_KEY)) || [];
    const entry = list.find(f => f.id === id);
    if (!entry) return;
    const s = entry.state;
    document.getElementById('fTipi').value            = s.tipi            || '';
    document.getElementById('fHataTipi').value        = s.hataTipi        || '';
    document.getElementById('fHataKaynagi').value     = s.hataKaynagi     || '';
    document.getElementById('fUygunsuzlukTuru').value = s.uygunsuzlukTuru || '';
    document.getElementById('fMakine').value          = s.makine          || '';
    document.getElementById('fStokKodu').value        = s.stokKodu        || '';
    _skSelect(s.stokKodu || '');
    document.getElementById('fDateStart').value       = s.dateStart       || '';
    document.getElementById('fDateEnd').value         = s.dateEnd         || '';
    document.getElementById('fCariTip').value         = s.cariTip         || '';
    selectedTespitYeriSet = new Set(s.tespitYeri || []);
    _updateTespitYeriLabel();
    selectCari(s.selectedCari || '');
    document.getElementById('uaFiltreModal').classList.remove('open');
    applyFilters();
    showToast('Filtre yüklendi: ' + entry.name, 'success');
}

async function deleteSavedFilter(id) {
    if (!confirm('Bu kayıtlı filtreyi silmek istediğinize emin misiniz?')) return;
    let list = (await _rIdbGet(_UA_FILTERS_KEY)) || [];
    list = list.filter(f => f.id !== id);
    await _rIdbPut(_UA_FILTERS_KEY, list);
    showToast('Filtre silindi');
    openSavedFiltersModal();
}
const _UA_EDITS_KEY = 'kapsamli_rapor_edits';

function _uaEsc(s) {
    if (s == null) return '';
    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}
function _uaFmtN(n) {
    if (n == null || isNaN(n)) return '—';
    return Number(n).toLocaleString('tr-TR', { maximumFractionDigits:0 });
}

async function uaOpenSnapshotModal() {
    const body = document.getElementById('uaSnapList');
    if (!body) return;
    let list = [];
    let idbErr = null;
    let allKeys = [];
    try {
        [list, allKeys] = await Promise.all([
            _rIdbGet(_UA_SNAPS_KEY).then(r => r || []),
            _rIdbGetAllKeys()
        ]);
    } catch(e) { idbErr = e; console.error('uaOpenSnapshotModal IDB error:', e); }
    console.log('[UA Snapshots] DB:', _RIDB.name, '/ store:', _RIDB.store, '/ key:', _UA_SNAPS_KEY,
        '\n  → list:', list, '\n  → all keys in store:', allKeys, '\n  → origin:', location.origin);
    if (idbErr) {
        body.innerHTML = `<p style="color:#ef4444;text-align:center;padding:20px;">IndexedDB okuma hatası: ${idbErr.message || idbErr}<br><small>Origin: ${location.origin}</small></p>`;
    } else if (!list.length) {
        const keysHtml = allKeys.length
            ? `<br><small style="color:#94a3b8;font-size:.68rem;">IDB içindeki anahtarlar: ${allKeys.join(', ')}</small>`
            : `<br><small style="color:#94a3b8;font-size:.68rem;">IDB boş — Origin: ${location.origin}</small>`;
        body.innerHTML = `<p style="color:#94a3b8;text-align:center;padding:28px 0;">Henüz kayıtlı rapor yok.<br><small style="color:#c4cdd8;">Kapsamlı Rapor sayfasında 💾 Kaydet butonunu kullanarak rapor kaydedebilirsiniz.</small>${keysHtml}</p>`;
    } else {
        body.innerHTML = list.slice().reverse().map(m => `
            <div class="ua-snap-row">
                <div class="ua-snap-info">
                    <div class="ua-snap-name">${_uaEsc(m.name)}</div>
                    <div class="ua-snap-meta">${new Date(m.ts).toLocaleString('tr-TR')} &nbsp;·&nbsp; ${_uaFmtN(m.recordCount)} kayıt &nbsp;·&nbsp; ${_uaFmtN(m.totalHatali)} hatalı</div>
                </div>
                <div class="ua-snap-btns">
                    <button class="ua-snap-btn ua-snap-load" onclick="uaLoadSnapshot('${m.id}')">📂 Raporu Aç</button>
                    <button class="ua-snap-btn ua-snap-del"  onclick="uaDeleteSnapshot('${m.id}')">🗑️ Sil</button>
                </div>
            </div>`.trim()).join('');
    }
    document.getElementById('uaSnapModal').classList.add('open');
}

async function uaDeleteSnapshot(id) {
    if (!confirm('Bu kayıtlı rapor silinsin mi?')) return;
    const list = (await _rIdbGet(_UA_SNAPS_KEY)) || [];
    await _rIdbPut(_UA_SNAPS_KEY, list.filter(m => m.id !== id));
    await _rIdbDel('kr_' + id);
    uaOpenSnapshotModal();
}

async function uaLoadSnapshot(id) {
    const snap = await _rIdbGet('kr_' + id);
    if (!snap || !snap.payload) { showToast('Snapshot verisi bulunamadı.', 'error'); return; }
    // Restore payload + edits to IDB then open the report
    await _rIdbPut(_RIDB.key, snap.payload);
    if (snap.edits) await _rIdbPut(_UA_EDITS_KEY, snap.edits);
    else await _rIdbDel(_UA_EDITS_KEY);
    document.getElementById('uaSnapModal').classList.remove('open');
    window.open('kapsamli-rapor.html', '_blank');
}

// Kapsamlı Rapor — tüm filtrelenmiş veriyi paketleyip rapor sayfasına gönderir
async function openKapsamliRapor() {
    if (!filteredData || !filteredData.length) {
        showToast('Rapor oluşturmak için önce veri yükleyin ve filtreleyin.', 'error');
        return;
    }

    // ── Aktif filtre değerlerini oku ──
    const fTarih1      = (document.getElementById('fDateStart')   || {}).value || '';
    const fTarih2      = (document.getElementById('fDateEnd')     || {}).value || '';
    const fHataTipi    = (document.getElementById('fHataTipi')    || {}).value || '';
    const fTipi        = (document.getElementById('fTipi')        || {}).value || '';
    const fHataKaynagi = (document.getElementById('fHataKaynagi') || {}).value || '';
    const fCariTip     = (document.getElementById('fCariTip')     || {}).value || '';
    const fStokKodu    = (document.getElementById('fStokKodu')    || {}).value || '';
    const tespitList   = [...selectedTespitYeriSet];
    const pgKey        = document.getElementById('paretoGroup').value;

    // ── Başlık oluştur ──
    const cariTipLabel = fCariTip === 'musteri' ? '★ Müşteri' : fCariTip === 'tedarikci' ? 'Tedarikçi' : '';
    let titleParts = [];
    if (fTipi)                      titleParts.push(fTipi);
    if (cariTipLabel)               titleParts.push(cariTipLabel);
    if (selectedCari)               titleParts.push(selectedCari);
    if (tespitList.length === 1)    titleParts.push(tespitList[0]);
    if (fHataTipi)                  titleParts.push(fHataTipi);
    if (_paretoSelected.size > 0)   titleParts.push([..._paretoSelected].join(', '));
    const batchLabel = titleParts.join(' · ') || 'Tüm Veriler';

    // ── Veriyi filtrele: önce excludedHataTipleri, sonra Pareto seçimleri ──
    const baseData = excludedHataTipleri.size > 0
        ? filteredData.filter(r => !excludedHataTipleri.has(r.hataTipi || '(Belirtilmemiş)'))
        : filteredData;

    // Pareto bar seçimi varsa sadece o kalemlerin verisinı al
    const reportData = _paretoSelected.size > 0
        ? baseData.filter(r => _paretoSelected.has(r[pgKey] || '(Belirtilmemiş)'))
        : baseData;

    if (!reportData.length) {
        showToast('Seçilen kriterlere uygun kayıt bulunamadı.', 'warn');
        return;
    }

    const RAPOR_FIELDS = ['hataliMiktar','hataTipi','hataKaynagi','cariAdi','stokAdi',
                          'tespitYeri','tipi','uygunsuzlukTarih','uygunsuzlukTuru','partiHacmi'];

    const batchId = 'b_' + Date.now();
    const batchFilters = {
        tarihStart: fTarih1, tarihEnd: fTarih2, tipi: fTipi, cariTip: fCariTip,
        cari: selectedCari || '', tespitYeri: tespitList, hataTipi: fHataTipi,
        hataKaynagi: fHataKaynagi, stokKodu: fStokKodu,
        excludedTypes:   [...excludedHataTipleri],
        paretoSelected:  [..._paretoSelected],
        paretoGroupKey:  pgKey
    };

    // ── Satırları raporlama alanlarına daralt ve etiketle ──
    const newSlim = reportData.map(r => {
        const o = { _batchId: batchId };
        RAPOR_FIELDS.forEach(f => { if (r[f] !== undefined) o[f] = r[f]; });
        return o;
    });

    const batchMeta = {
        id: batchId, label: batchLabel, rowCount: newSlim.length,
        addedAt: new Date().toLocaleString('tr-TR'), filters: batchFilters
    };

    // ── Pareto gruplarını hesapla (yalnızca rapor verisine göre) ──
    const _pgMetric = document.getElementById('paretoMetric').value;
    const _pgTopN   = parseInt(document.getElementById('paretoTop').value);
    const _pgThresh = parseInt(document.getElementById('paretoThreshold').value);
    const _pgAgg    = {};
    newSlim.forEach(r => {
        const k = r[pgKey] || '(Belirtilmemiş)';
        if (!_pgAgg[k]) _pgAgg[k] = { count: 0, hatali: 0 };
        _pgAgg[k].count++;
        _pgAgg[k].hatali += Number(r.hataliMiktar) || 0;
    });
    let _pgEntries = Object.entries(_pgAgg).map(([k,v]) => ({
        label: k, value: _pgMetric === 'hataliMiktar' ? v.hatali : v.count, count: v.count, hatali: v.hatali
    })).sort((a,b) => b.value - a.value);
    const _pgTopSlice = _pgTopN < _pgEntries.length ? _pgEntries.slice(0, _pgTopN) : _pgEntries;
    const _pgTotal    = _pgTopSlice.reduce((s,e) => s + e.value, 0);
    let _pgCum = 0, _pgCut = _pgTopSlice.length;
    for (let _i = 0; _i < _pgTopSlice.length; _i++) {
        _pgCum += _pgTopSlice[_i].value;
        if ((_pgCum / (_pgTotal || 1)) * 100 >= _pgThresh) { _pgCut = _i + 1; break; }
    }
    const paretoGroups = _pgTopSlice.slice(0, _pgCut).map(e => {
        const gRows = newSlim.filter(r => (r[pgKey] || '(Belirtilmemiş)') === e.label);
        return { label: e.label, totalHatali: e.hatali, count: e.count,
                 pct: +(e.value / (_pgTotal||1) * 100).toFixed(1), groupRows: gRows };
    });

    const title = batchLabel + ' — Kalite Raporu';

    // ── Grafik anlık görüntüleri — tam replace; sadece şu an seçilenler ──
    const allSnaps = (_pendingSnapshots || []).map(s => ({ ...s, batchId, addedAt: new Date().toISOString() }));
    _pendingSnapshots = [];

    // ── REPLACE: her zaman yeni temiz payload kaydet ──
    const payload = {
        rows: newSlim,
        batches: [batchMeta],
        title,
        generatedAt: new Date().toISOString(),
        paretoGroups,
        paretoGroupKey:  pgKey,
        paretoThreshold: _pgThresh,
        filters: batchFilters,
        chartSnapshots: allSnaps
    };

    try {
        await _rIdbSave(payload);
        const selInfo = _paretoSelected.size > 0 ? ` | ${_paretoSelected.size} Pareto kalemi` : '';
        showToast(`✅ ${newSlim.length} kayıt — ${paretoGroups.length} Pareto grubu${selInfo}`, 'success');
        if (!window._kapsamliWin || window._kapsamliWin.closed)
            window._kapsamliWin = window.open('kapsamli-rapor.html', 'kapsamliRapor');
        else
            window._kapsamliWin.location.reload();
    } catch(e) {
        showToast('Rapor kaydedilemedi: ' + (e && e.message || e), 'error');
    }
}

async function temizleKapsamliRapor() {
    if (!confirm('Kapsamlı rapordaki tüm birikmiş veri silinsin mi?\nYeni bir rapor başlatmak için Evet\'e basın.')) return;
    await _rIdbDel(_RIDB.key);
    if (window._kapsamliWin && !window._kapsamliWin.closed) {
        window._kapsamliWin.close();
        window._kapsamliWin = null;
    }
    showToast('Rapor temizlendi — artık yeni filtrelerle başlayabilirsiniz.', 'success');
}

// ─── Chart Picker Modal ───────────────────────────────────────────────────────
const _CPM_CHARTS = [
    { id:'pareto',   label:'📊 Pareto Analizi',         canvas:'#paretoChart'  },
    { id:'radar',    label:'🕷️ Radar Analizi',          canvas:'#radarChart'   },
    { id:'bubble',   label:'🫧 Kabarcık Grafiği',        canvas:'#bubbleChart'  },
    { id:'bar',      label:'📊 Gruplu/Yığılmış Bar',    canvas:'#barChart'     },
    { id:'sankey',   label:'🌊 Sankey Diyagramı',       canvas:'#sankeyChart'  },
    { id:'boxplot',  label:'📦 Kutu Grafik (Box Plot)', canvas:'#bpChart'      },
    { id:'scatter',  label:'📀 Dağılım (Scatter)',      canvas:'#scChart'      },
    { id:'treemap',  label:'🗺️ Treemap',                canvas:'#tmChart'      },
    { id:'calendar', label:'🔥 Takvim Isı Haritası',   svg:'#calSvg'          },
    { id:'funnel',   label:'🔽 Funnel Grafiği',         svg:'#funnelSvgWrap'   },
    { id:'polar',    label:'⭐ Polar Alan',             canvas:'#polarChart'   },
    { id:'chord',    label:'🔗 Chord Diyagramı',       svg:'#chordSvgWrap'    },
    { id:'beeswarm', label:'🟣 Beeswarm / Dot Plot',   svg:'#bswSvgWrap'      },
];
let _pendingSnapshots = [];

function _cpmUpdateCount() {
    const n = document.querySelectorAll('#cpmBody .cpm-item.cpm-selected').length;
    const el = document.getElementById('cpmSelCount');
    if (el) el.textContent = `${n} grafik seçili`;
}

function _cpmSelectAll(select) {
    document.querySelectorAll('#cpmBody .cpm-item').forEach(el => {
        const cb = el.querySelector('input[type=checkbox]');
        cb.checked = select;
        el.classList.toggle('cpm-selected', select);
    });
    _cpmUpdateCount();
}

function openChartPickerModal() {
    if (!filteredData || !filteredData.length) {
        showToast('Rapor oluşturmak için önce veri yükleyin.', 'error');
        return;
    }
    // Build filter summary
    const fStart   = (document.getElementById('fDateStart')   || {}).value || '';
    const fEnd     = (document.getElementById('fDateEnd')     || {}).value || '';
    const fHT      = (document.getElementById('fHataTipi')    || {}).value || '';
    const fTipi    = (document.getElementById('fTipi')        || {}).value || '';
    const fKaynak  = (document.getElementById('fHataKaynagi') || {}).value || '';
    const fCariTip = (document.getElementById('fCariTip')     || {}).value || '';
    const tags = [
        filteredData.length + ' kayıt secildi',
        (fStart || fEnd) ? '📅 ' + (fStart||'—') + ' → ' + (fEnd||'—') : '',
        fTipi    ? '🏷️ ' + fTipi    : '',
        fCariTip ? '🏢 ' + (fCariTip === 'musteri' ? '★ Müşteri' : 'Tedarikçi') : '',
        selectedCari ? '👤 ' + selectedCari : '',
        fHT      ? '🔍 ' + fHT      : '',
        fKaynak  ? '⚙️ ' + fKaynak  : '',
        selectedTespitYeriSet?.size ? '📍 ' + [...selectedTespitYeriSet].join(', ') : '',
        excludedHataTipleri?.size   ? '🚫 ' + excludedHataTipleri.size + ' tip hariç' : '',
    ].filter(Boolean);
    const infoEl = document.getElementById('cpmFilterInfo');
    if (infoEl) infoEl.innerHTML = tags.map((t,i) => i===0
        ? `<strong style="font-size:.85rem;">✅ ${t}</strong>`
        : `<span style="margin-left:10px;background:#dbeafe;border-radius:20px;padding:2px 9px;">${t}</span>`
    ).join('');

    const body = document.getElementById('cpmBody');
    body.innerHTML = _CPM_CHARTS.map(c => `
        <label class="cpm-item cpm-selected" data-cid="${c.id}">
            <input type="checkbox" checked onchange="this.closest('.cpm-item').classList.toggle('cpm-selected',this.checked);_cpmUpdateCount()">
            <span class="cpm-lbl">${c.label}</span>
        </label>`).join('');
    _cpmUpdateCount();
    document.getElementById('chartPickerModal').classList.add('open');
}

function _svgToDataUrl(container) {
    const svg = container.tagName && container.tagName.toLowerCase() === 'svg'
        ? container : container.querySelector('svg');
    if (!svg || !svg.children.length) return null;
    try {
        if (!svg.getAttribute('xmlns')) svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        // Set explicit dimensions if missing
        const bb = svg.getBoundingClientRect();
        if (!svg.getAttribute('width')  && bb.width)  svg.setAttribute('width',  bb.width);
        if (!svg.getAttribute('height') && bb.height) svg.setAttribute('height', bb.height);
        const xml = new XMLSerializer().serializeToString(svg);
        return 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(xml)));
    } catch(e) { return null; }
}

// Convert SVG data URL → PNG via off-screen canvas (async)
function _svgToPng(svgDataUrl, w, h) {
    return new Promise(resolve => {
        try {
            const img = new Image();
            img.onload = () => {
                const c = document.createElement('canvas');
                c.width  = w || img.naturalWidth  || 900;
                c.height = h || img.naturalHeight || 520;
                const ctx = c.getContext('2d');
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, 0, c.width, c.height);
                ctx.drawImage(img, 0, 0, c.width, c.height);
                resolve(c.toDataURL('image/png'));
            };
            img.onerror = () => resolve(svgDataUrl); // fallback to SVG
            img.src = svgDataUrl;
        } catch(e) { resolve(svgDataUrl); }
    });
}

async function _cpmCaptureOne(def) {
    try {
        if (def.canvas) {
            const canvas = document.querySelector(def.canvas);
            if (!canvas || canvas.width < 10) return null;
            // Retry up to 3 times if canvas appears blank (all transparent/white)
            let dataUrl = null;
            for (let attempt = 0; attempt < 3; attempt++) {
                if (attempt > 0) await new Promise(r => setTimeout(r, 300));
                dataUrl = canvas.toDataURL('image/png');
                if (dataUrl === 'data:,' || dataUrl.length < 5000) continue; // too small → blank
                // Check a few pixels in the center to see if anything was drawn
                try {
                    const ctx2 = canvas.getContext('2d');
                    const px = ctx2.getImageData(Math.floor(canvas.width/2), Math.floor(canvas.height/2), 1, 1).data;
                    if (px[3] > 0) break; // has non-transparent pixel → not blank
                } catch(e) { break; }
            }
            if (!dataUrl || dataUrl.length < 5000) return null;
            return { id: def.id, label: def.label, dataUrl, type: 'png' };
        } else if (def.svg) {
            const container = document.querySelector(def.svg);
            if (!container) return null;
            const svgUrl = _svgToDataUrl(container);
            if (!svgUrl) return null;
            const bb = container.getBoundingClientRect();
            const pngUrl = await _svgToPng(svgUrl, bb.width || 900, bb.height || 520);
            return { id: def.id, label: def.label, dataUrl: pngUrl, type: 'png' };
        }
    } catch(e) { console.warn('Chart capture failed for', def.id, e); }
    return null;
}

async function _cpmConfirm() {
    const selected = _CPM_CHARTS.filter(c => {
        const item = document.querySelector(`#cpmBody [data-cid="${c.id}"]`);
        return item && item.classList.contains('cpm-selected');
    });
    document.getElementById('chartPickerModal').classList.remove('open');
    if (!selected.length) { await openKapsamliRapor(); return; }

    // Find current active tab to restore later
    const activePanel = document.querySelector('.tab-panel.active');
    const origTab = activePanel ? activePanel.id.replace('tab-', '') : 'pareto';

    // Disable Chart.js animations during capture so we don't catch mid-draw frames
    const origAnim = Chart.defaults.animation;
    Chart.defaults.animation = false;

    // Progress toast
    const toastMsg = (n, tot) => showToast(`⏳ Grafik yakalanıyor… ${n}/${tot}`);
    toastMsg(0, selected.length);

    // Charts that need extra time to render (heavy data / websocket / layout passes)
    const _CPM_SLOW = new Set(['sankey','bubble','bar','boxplot','scatter','chord','beeswarm','treemap']);

    const snaps = [];
    for (let i = 0; i < selected.length; i++) {
        const def = selected[i];
        toastMsg(i + 1, selected.length);
        // Switch to this tab — triggers render inside switchTab()
        switchTab(def.id);
        // Wait two animation frames so Chart.js / SVG starts painting
        await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
        // Heavier charts need more time
        await new Promise(r => setTimeout(r, _CPM_SLOW.has(def.id) ? 600 : 350));
        const snap = await _cpmCaptureOne(def);
        if (snap) snaps.push(snap);
    }

    // Restore original tab
    switchTab(origTab);
    // Re-enable Chart.js animations
    Chart.defaults.animation = origAnim;

    _pendingSnapshots = snaps;
    await openKapsamliRapor();
}

// Özellik 1: Tedarikçi bazında Fishbone — 6M yapısı
function openFishboneTedarikci() {
    if (!selectedCari) return;
    const cariRows = filteredData.filter(r => r.cariAdi === selectedCari);
    if (!cariRows.length) { showToast('Bu cari için veri bulunamadı.', 'error'); return; }
    const BONE_COLORS = ['#ef4444','#f59e0b','#3b82f6','#8b5cf6','#06b6d4','#22c55e'];
    let _nid = 1; const mkId = () => _nid++;
    const mkChildren = (items, color) => (items||[]).slice(0,6).map(item => ({
        id:mkId(),
        name: item.displayName || item.name || item,
        color, children:[], collapsed:false,
        offsetX:0, offsetY:0,
        _contrib: item.pct || null
    }));
    // hataKaynagi -> 6M anahtar kelime sınıflandırması
    const cls = classify6M(cariRows);

    const causes = [
        { name:'👤 İnsan',   desc:'Hata kaynağı → insan kaynaklı',           color:BONE_COLORS[0], side:'top',
          children: mkChildren(cls.insan, BONE_COLORS[0]) },
        { name:'⚙️ Makine',  desc:'Makine/ekipman kaynaklı',            color:BONE_COLORS[1], side:'bottom',
          children: mkChildren(cls.makine, BONE_COLORS[1]) },
        { name:'📦 Malzeme', desc:'Etkilenen stoklar + malzeme kaynaklı',  color:BONE_COLORS[2], side:'top',
          children: [
            ...mkChildren(topNFieldWithContrib(cariRows,'stokAdi',3), BONE_COLORS[2]),
            ...mkChildren(cls.malzeme, BONE_COLORS[2])
          ].slice(0,6) },
        { name:'📋 Metot',   desc:'Metot / süreç kaynaklı',               color:BONE_COLORS[3], side:'bottom',
          children: mkChildren(cls.metot, BONE_COLORS[3]) },
        { name:'📐 Ölçüm',  desc:'Hata tipi + ölçüm kaynaklı',            color:BONE_COLORS[4], side:'top',
          children: [
            ...mkChildren(topNFieldWithContrib(cariRows,'hataTipi',3), BONE_COLORS[4]),
            ...mkChildren(cls.olcum, BONE_COLORS[4])
          ].slice(0,6) },
        { name:'🌡️ Ortam',  desc:'Tespit yeri + ortam kaynaklı',         color:BONE_COLORS[5], side:'bottom',
          children: [
            ...mkChildren(topNFieldWithContrib(cariRows,'tespitYeri',3), BONE_COLORS[5]),
            ...mkChildren(cls.ortam, BONE_COLORS[5])
          ].slice(0,6) },
    ].map(b => ({ ...b, id:mkId(), collapsed:false, offsetX:0, offsetY:0, baseOffsetX:0, baseOffsetY:0 }));
    const total = cariRows.reduce((s,r)=>s+(Number(r.hataliMiktar)||0),0);
    const desc = `Tedarikçi kalite analizi.\n• Toplam hatalı miktar: ${total.toLocaleString('tr',{maximumFractionDigits:1})}\n• Toplam kayıt: ${cariRows.length}\nKaynak: Uygunsuzluk Analizi`;
    localStorage.setItem('fishbone_incoming', JSON.stringify({
        problem: `${selectedCari} ― Kalite Problemleri`,
        problemDesc: desc, source: 'uygunsuzluk-analizi',
        causes, nextId: _nid
    }));
    localStorage.setItem('fishbone_source', 'uygunsuzluk-analizi');
    window.open('balik-kilcigi.html', '_blank');
}

// ─── Table ────────────────────────────────────────────────────────────────────
function renderTable(data) {
    const filteredData = _effectiveData();
    if (data === undefined) {
        tableSearchData = [...filteredData];
    }
    const search = document.getElementById('tableSearch').value.toLowerCase();
    let display = tableSearchData.filter(r => {
        if (!search) return true;
        return TABLE_COLS.some(k => String(r[k]).toLowerCase().includes(search));
    });

    // Sort
    if (sortCol >= 0) {
        const key = TABLE_COLS[sortCol];
        display.sort((a, b) => {
            const av = a[key], bv = b[key];
            const an = parseFloat(av), bn = parseFloat(bv);
            if (!isNaN(an) && !isNaN(bn)) return sortAsc ? an - bn : bn - an;
            return sortAsc ? String(av).localeCompare(String(bv), 'tr') : String(bv).localeCompare(String(av), 'tr');
        });
    }

    const total = display.length;
    const pages = Math.max(1, Math.ceil(total / PAGE_SIZE));
    if (currentPage > pages) currentPage = pages;
    const start = (currentPage - 1) * PAGE_SIZE;
    const slice = display.slice(start, start + PAGE_SIZE);

    document.getElementById('tableInfo').textContent = `${total.toLocaleString('tr')} kayıt · Sayfa ${currentPage}/${pages}`;

    // Header
    document.getElementById('tableHead').innerHTML = `<tr>${TABLE_COLS.map((k, i) => {
        const icon = sortCol === i ? (sortAsc ? ' ▲' : ' ▼') : '';
        return `<th onclick="sortTable(${i})">${COL_LABELS[k]}${icon}</th>`;
    }).join('')}<th style="min-width:52px;text-align:center;">8D</th></tr>`;

    // Body
    document.getElementById('tableBody').innerHTML = slice.map(r => {
        const seri = String(r.uygunsuzlukSeri || '').trim();
        const esc  = seri.replace(/\\/g,'\\\\').replace(/'/g,"\\'");
        const btn  = seri ? `<button class="btn-8d-link" onclick="open8DForRow('${esc}')">📋 8D</button>` : '';
        return `<tr>${
            TABLE_COLS.map(k => {
                let v = r[k];
                if (k === 'hataliMiktar' && v > 0) return `<td><span class="badge badge-red">${Number(v).toLocaleString('tr', {maximumFractionDigits:2})}</span></td>`;
                if (k === 'kontrolMiktar' && v > 0) return `<td><span class="badge badge-blue">${Number(v).toLocaleString('tr', {maximumFractionDigits:2})}</span></td>`;
                return `<td>${v}</td>`;
            }).join('')
        }<td style="text-align:center;">${btn}</td></tr>`;
    }).join('') || `<tr><td colspan="${TABLE_COLS.length + 1}" style="text-align:center;color:#aaa;padding:30px;">Kayıt bulunamadı</td></tr>`;

    renderPagination(pages, display);
}

function open8DForRow(seri) {
    const url = '8d-rapor.html?source=' + encodeURIComponent('Uygunsuzluk') + '&konu=' + encodeURIComponent(seri);
    window.open(url, '_blank');
}

function sortTable(idx) {
    if (sortCol === idx) sortAsc = !sortAsc;
    else { sortCol = idx; sortAsc = true; }
    currentPage = 1;
    renderTable();
}

function onTableSearch() {
    currentPage = 1;
    renderTable();
}

function renderPagination(pages, display) {
    const pg = document.getElementById('pagination');
    if (pages <= 1) { pg.innerHTML = ''; return; }
    const btns = [];
    btns.push(`<button class="page-btn" onclick="goPage(1)">«</button>`);
    const from = Math.max(1, currentPage - 2);
    const to   = Math.min(pages, currentPage + 2);
    if (from > 1) btns.push('<span style="padding:6px 4px;color:#aaa">…</span>');
    for (let i = from; i <= to; i++) {
        btns.push(`<button class="page-btn${i === currentPage ? ' active' : ''}" onclick="goPage(${i})">${i}</button>`);
    }
    if (to < pages) btns.push('<span style="padding:6px 4px;color:#aaa">…</span>');
    btns.push(`<button class="page-btn" onclick="goPage(${pages})">»</button>`);
    pg.innerHTML = btns.join('');
}

function goPage(p) { currentPage = p; renderTable(); }

// ─── Export Table ─────────────────────────────────────────────────────────────
function exportTableExcel() {
    const header = TABLE_COLS.map(k => COL_LABELS[k]);
    const rows   = filteredData.map(r => TABLE_COLS.map(k => r[k]));
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet([header, ...rows]);
    XLSX.utils.book_append_sheet(wb, ws, 'Uygunsuzluk');
    XLSX.writeFile(wb, 'uygunsuzluk-analizi.xlsx');
    showToast('Excel indirildi!', 'success');
}

// ─── Tabs ─────────────────────────────────────────────────────────────────────
function switchTab(name) {
    const names = ['pareto', 'breakdown', 'table', 'radar', 'heatmap', 'bubble', 'bar', 'sankey', 'boxplot', 'scatter', 'treemap', 'calendar', 'cohort', 'funnel', 'polar', 'chord', 'beeswarm'];
    document.querySelectorAll('.tab-btn').forEach((b, i) => {
        b.classList.toggle('active', names[i] === name);
    });
    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
    document.getElementById('tab-' + name).classList.add('active');
    if (name === 'pareto' && paretoChartInst) paretoChartInst.resize();
    if (name === 'radar')   { radarBuildSelector(); }
    if (name === 'heatmap') { renderHeatmap(); }
    if (name === 'bubble')  { renderBubble(); }
    if (name === 'bar')     { renderGroupedBar(); }
    if (name === 'sankey')  { renderSankey(); }
    if (name === 'boxplot') { renderBoxPlot(); }
    if (name === 'scatter') { renderScatter(); }
    if (name === 'treemap') { renderTreemap(); }
    if (name === 'calendar') { renderCalendar(); }
    if (name === 'cohort')   { renderCohort(); }
    if (name === 'funnel')   { renderFunnel(); }
    if (name === 'polar')    { renderPolarArea(); }
    if (name === 'chord')    { renderChord(); }
    if (name === 'beeswarm') { renderBeeswarm(); }
}

// ─── RADAR ANALİZİ ───────────────────────────────────────────────────────────

const RADAR_PALETTE = [
    '#7c3aed','#db2777','#0891b2','#16a34a','#ea580c',
    '#9333ea','#0f766e','#b45309','#be123c','#1d4ed8',
];

function _radarField(row, key) {
    const map = {
        cariAdi: row.cariAdi || row['Cari Adı'] || '—',
        hataTipi: row.hataTipi || row['Hata Tipi'] || '—',
        hataKaynagi: row.hataKaynagi || row['Hata Kaynağı'] || '—',
        tespitYeri: row.tespitYeri || row['Tespit Yeri'] || '—',
        stokAdi: row.stokAdi || row['Stok Adı'] || '—',
        uygunsuzlukTuru: row.uygunsuzlukTuru || row['Uygunsuzluk Türü'] || '—',
    };
    return (map[key] || '—').toString().trim() || '—';
}

function _radarMetricVal(row, metric) {
    if (metric === 'hataliMiktar') return parseFloat(row.hataliMiktar || row['Hatalı Miktar'] || 0) || 0;
    return 1; // kayıt sayısı: her satır 1
}

// Tüm veriyi pivot'la: { [groupVal]: { [axisVal]: number } }
function _radarPivot(data, groupKey, axisKey, metric) {
    const pivot = {};
    data.forEach(row => {
        const g = _radarField(row, groupKey);
        const a = _radarField(row, axisKey);
        const v = _radarMetricVal(row, metric);
        if (!pivot[g]) pivot[g] = {};
        pivot[g][a] = (pivot[g][a] || 0) + v;
    });
    return pivot;
}

// Top N eksen (tüm datadan aggregate)
function _radarTopAxes(data, axisKey, metric, topN) {
    const totals = {};
    data.forEach(row => {
        const a = _radarField(row, axisKey);
        totals[a] = (totals[a] || 0) + _radarMetricVal(row, metric);
    });
    return Object.entries(totals)
        .sort((a, b) => b[1] - a[1])
        .slice(0, topN)
        .map(e => e[0]);
}

// Top N gruplar (tüm datadan)
function _radarTopGroups(data, groupKey, metric, topN) {
    const totals = {};
    data.forEach(row => {
        const g = _radarField(row, groupKey);
        totals[g] = (totals[g] || 0) + _radarMetricVal(row, metric);
    });
    return Object.entries(totals)
        .sort((a, b) => b[1] - a[1])
        .slice(0, topN)
        .map(e => ({ label: e[0], total: e[1] }));
}

function radarBuildSelector() {
    if (!filteredData.length) return;
    const groupKey = document.getElementById('radarGroupBy').value;
    const metric   = document.getElementById('radarMetric').value;
    const allGroups = _radarTopGroups(filteredData, groupKey, metric, 99999); // tümü

    // Tarih aralığı bilgisi
    const ds = (document.getElementById('fDateStart') || {}).value || '';
    const de = (document.getElementById('fDateEnd')   || {}).value || '';
    const dateInfoEl = document.getElementById('radarDateInfo');
    if (dateInfoEl) {
        if (ds || de) {
            dateInfoEl.style.display = '';
            dateInfoEl.textContent = `📅 ${ds || '…'} → ${de || '…'}`;
        } else {
            dateInfoEl.style.display = 'none';
        }
    }

    // Sync selected: keep existing selections that are still valid
    const validLabels = new Set(allGroups.map(g => g.label));
    _radarSelected.forEach(s => { if (!validLabels.has(s)) _radarSelected.delete(s); });

    // Auto-select top 5 if nothing selected
    if (_radarSelected.size === 0) {
        allGroups.slice(0, 5).forEach(g => _radarSelected.add(g.label));
    }

    // Store full list on the element for search filtering
    const list = document.getElementById('radarGroupList');
    list._allGroups = allGroups;
    _radarRenderList(allGroups);
    document.getElementById('radarSelHint').textContent = `Seçili: ${_radarSelected.size} / ${allGroups.length}`;
    renderRadar();
}

function _radarRenderList(groups) {
    const list   = document.getElementById('radarGroupList');
    const allGrps = list._allGroups || groups;
    const maxVal = (allGrps[0]?.total) || 1;
    // Color index based on position in FULL list (stable colors)
    const colorIdx = {};
    allGrps.forEach((g, i) => { colorIdx[g.label] = i; });

    list.innerHTML = groups.map(g => {
        const pct = Math.round((g.total / maxVal) * 100);
        const sel = _radarSelected.has(g.label);
        const ci  = colorIdx[g.label] ?? 0;
        // Encode label safely as base64 to avoid any escaping issues
        const safeLabel = g.label.replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;');
        return `<div class="radar-group-item ${sel ? 'rgi-selected' : ''}" data-lbl="${safeLabel}">
            <input type="checkbox" class="rgi-chk" ${sel ? 'checked' : ''}>
            <span class="radar-color-dot" style="background:${RADAR_PALETTE[ci % RADAR_PALETTE.length]};opacity:${sel?1:.35};"></span>
            <span class="rgi-label" title="${safeLabel}">${safeLabel}</span>
            <span class="rgi-val">${g.total.toLocaleString('tr-TR',{maximumFractionDigits:0})} (${pct}%)</span>
        </div>`;
    }).join('');
}

// One-time delegated click listener on the list container
(function _radarInitListener() {
    document.addEventListener('click', function(e) {
        const item = e.target.closest('#radarGroupList .radar-group-item');
        if (!item) return;
        // Prevent the browser from natively toggling the checkbox checked state
        // (its default action runs AFTER listeners, undoing our explicit chk.checked assignment)
        e.preventDefault();
        const label = item.getAttribute('data-lbl')
            ?.replace(/&amp;/g,'&').replace(/&quot;/g,'"').replace(/&lt;/g,'<');
        if (!label) return;
        const chk = item.querySelector('.rgi-chk');
        if (_radarSelected.has(label)) {
            _radarSelected.delete(label);
            item.classList.remove('rgi-selected');
            if (chk) chk.checked = false;
            const dot = item.querySelector('.radar-color-dot');
            if (dot) dot.style.opacity = '.35';
        } else {
            _radarSelected.add(label);
            item.classList.add('rgi-selected');
            if (chk) chk.checked = true;
            const dot = item.querySelector('.radar-color-dot');
            if (dot) dot.style.opacity = '1';
        }
        const total = (document.getElementById('radarGroupList')?._allGroups || []).length;
        const hint  = document.getElementById('radarSelHint');
        if (hint) hint.textContent = `Seçili: ${_radarSelected.size} / ${total}`;
        renderRadar();
    });
})();

function _radarFilterList() {
    const q    = (document.getElementById('radarGroupSearch')?.value || '').toLowerCase();
    const list = document.getElementById('radarGroupList');
    const all  = list._allGroups || [];
    const filtered = q ? all.filter(g => g.label.toLowerCase().includes(q)) : all;
    _radarRenderList(filtered);
}

// Keep _radarToggle for backward compat but it's no longer used via inline onclick
function _radarToggle(el, label) {
    /* superseded by delegated listener */
}

function radarSelectAll() {
    const list = document.getElementById('radarGroupList');
    const all  = list._allGroups || [];
    all.forEach(g => _radarSelected.add(g.label));
    _radarFilterList(); // re-render visible list
    const total = all.length;
    document.getElementById('radarSelHint').textContent = `Seçili: ${_radarSelected.size} / ${total}`;
    renderRadar();
}

function radarSelectTop5() {
    _radarSelected.clear();
    const list = document.getElementById('radarGroupList');
    const all  = list._allGroups || [];
    all.slice(0, 5).forEach(g => _radarSelected.add(g.label));
    _radarFilterList();
    document.getElementById('radarSelHint').textContent = `Seçili: ${_radarSelected.size} / ${all.length}`;
    renderRadar();
}

function radarClearAll() {
    _radarSelected.clear();
    const list = document.getElementById('radarGroupList');
    const all  = list._allGroups || [];
    _radarFilterList();
    document.getElementById('radarSelHint').textContent = `Seçili: 0 / ${all.length}`;
    renderRadar();
}

function renderRadar() {
    const filteredData = _effectiveData();
    const groupKey  = document.getElementById('radarGroupBy').value;
    const axisKey   = document.getElementById('radarAxesBy').value;
    const metric    = document.getElementById('radarMetric').value;
    const axesTop   = parseInt(document.getElementById('radarAxesTop').value);
    const normalize = document.getElementById('radarNorm').value === '1';

    const noDataEl  = document.getElementById('radarNoData');
    const wrapEl    = document.getElementById('radarChartWrap');
    const insightEl = document.getElementById('radarInsight');

    if (!filteredData.length || _radarSelected.size < 2) {
        noDataEl.style.display = 'block';
        wrapEl.style.display   = 'none';
        insightEl.style.display = 'none';
        return;
    }

    const selectedGroups = [..._radarSelected];
    const axes    = _radarTopAxes(filteredData, axisKey, metric, axesTop);

    if (axes.length < 2) {
        noDataEl.style.display  = 'block';
        wrapEl.style.display    = 'none';
        insightEl.style.display = 'none';
        return;
    }

    noDataEl.style.display = 'none';
    wrapEl.style.display   = 'block';

    const pivot = _radarPivot(filteredData, groupKey, axisKey, metric);

    // For each axis, find the max across all selected groups (for normalization)
    const axisMax = {};
    axes.forEach(ax => {
        axisMax[ax] = Math.max(1, ...selectedGroups.map(g => pivot[g]?.[ax] || 0));
    });

    const datasets = selectedGroups.map((g, i) => {
        const color = RADAR_PALETTE[i % RADAR_PALETTE.length];
        const rawVals = axes.map(ax => pivot[g]?.[ax] || 0);
        const vals = normalize
            ? axes.map(ax => axisMax[ax] > 0 ? Math.round((pivot[g]?.[ax] || 0) / axisMax[ax] * 100) : 0)
            : rawVals;
        return {
            label: g,
            data: vals,
            backgroundColor: color + '22',
            borderColor: color,
            borderWidth: 2.2,
            pointBackgroundColor: color,
            pointRadius: 4,
            pointHoverRadius: 6,
            _rawVals: rawVals,
        };
    });

    if (radarChartInst) { radarChartInst.destroy(); radarChartInst = null; }

    const ctx = document.getElementById('radarChart').getContext('2d');
    radarChartInst = new Chart(ctx, {
        type: 'radar',
        data: { labels: axes, datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'top', labels: { font: { size: 12 }, padding: 14 } },
                tooltip: {
                    callbacks: {
                        label(ctx) {
                            const raw = ctx.dataset._rawVals?.[ctx.dataIndex];
                            const suffix = normalize ? ` (${ctx.raw}%)` : '';
                            const fmt = typeof raw === 'number'
                                ? raw.toLocaleString('tr-TR', { maximumFractionDigits: 1 })
                                : raw;
                            return ` ${ctx.dataset.label}: ${fmt}${suffix}`;
                        }
                    }
                }
            },
            scales: {
                r: {
                    min: 0,
                    max: normalize ? 100 : undefined,
                    ticks: {
                        stepSize: normalize ? 20 : undefined,
                        font: { size: 10 },
                        backdropColor: 'transparent',
                        callback: v => normalize ? v + '%' : v.toLocaleString('tr-TR', { maximumFractionDigits: 0 }),
                    },
                    pointLabels: { font: { size: 11 }, color: '#374151' },
                    grid: { color: '#e5e7eb' },
                    angleLines: { color: '#e5e7eb' },
                }
            }
        }
    });

    // Insight: find the strongest group per axis
    const insights = [];
    axes.forEach(ax => {
        let best = null, bestVal = -1;
        selectedGroups.forEach(g => {
            const v = pivot[g]?.[ax] || 0;
            if (v > bestVal) { bestVal = v; best = g; }
        });
        if (best && bestVal > 0) {
            insights.push(`<b>${ax}</b> ekseninde en yüksek: <b>${best}</b> (${bestVal.toLocaleString('tr-TR',{maximumFractionDigits:1})})`);
        }
    });

    insightEl.style.display = insights.length ? 'block' : 'none';
    insightEl.innerHTML = '🔎 <b>Radar Öngörüleri:</b> ' + insights.join(' &nbsp;|&nbsp; ');
}

function downloadRadarPNG() {
    const canvas = document.getElementById('radarChart');
    if (!canvas) return;
    const link = document.createElement('a');
    link.download = 'radar-analiz.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
}

// ─── ISI HARİTASI ────────────────────────────────────────────────────────────

const HM_SCALES = {
    blue:   ['#dbeafe','#93c5fd','#3b82f6','#1d4ed8','#1e3a8a'],
    red:    ['#fee2e2','#fca5a5','#ef4444','#b91c1c','#7f1d1d'],
    green:  ['#dcfce7','#86efac','#22c55e','#15803d','#14532d'],
    purple: ['#f3e8ff','#d8b4fe','#a855f7','#7e22ce','#3b0764'],
    orange: ['#ffedd5','#fdba74','#f97316','#c2410c','#7c2d12'],
};

// ── Heatmap picker state ──────────────────────────────────────────────────────
let _hmRowFilter = null; // null = use top-N; Set<string> = manual selection
let _hmColFilter = null;

function _hmResetFilter(axis) {
    if (axis === 'row') _hmRowFilter = null;
    else                _hmColFilter = null;
}

function _hmBuildSortedList(axis) {
    const key    = document.getElementById(axis === 'row' ? 'hmRowBy' : 'hmColBy').value;
    const metric = document.getElementById('hmMetric').value;
    const totals = {};
    filteredData.forEach(r => {
        const v = _hmGet(r, key);
        if (v === '—' || v === '' || v === '(Belirtilmemiş)') return;
        const val = metric === 'hataliMiktar' ? (parseFloat(r.hataliMiktar) || 0) : 1;
        totals[v] = (totals[v] || 0) + val;
    });
    return Object.entries(totals).sort((a,b) => b[1]-a[1]).map(([label, total]) => ({label, total}));
}

function _hmInitAxis(axis) {
    const all = _hmBuildSortedList(axis);
    const filterRef = axis === 'row' ? _hmRowFilter : _hmColFilter;
    if (!filterRef) {
        const topN = parseInt(document.getElementById(axis === 'row' ? 'hmTopRow' : 'hmTopCol').value) || (axis === 'row' ? 15 : 12);
        const newSet = new Set(all.slice(0, topN >= 99999 ? all.length : topN).map(g => g.label));
        if (axis === 'row') _hmRowFilter = newSet; else _hmColFilter = newSet;
    }
    const panelEl = document.getElementById(axis === 'row' ? 'hmRowPanel' : 'hmColPanel');
    if (panelEl) panelEl._allItems = all;
}

function _hmRefreshPanels() {
    ['row', 'col'].forEach(axis => {
        _hmInitAxis(axis);
        const searchEl = document.getElementById(axis === 'row' ? 'hmRowSearch' : 'hmColSearch');
        const q = (searchEl?.value || '').toLowerCase();
        const panelEl = document.getElementById(axis === 'row' ? 'hmRowPanel' : 'hmColPanel');
        const all = panelEl?._allItems || [];
        const filtered = q ? all.filter(g => g.label.toLowerCase().includes(q)) : all;
        _hmRenderPickList(axis, filtered);
    });
}

function _hmRenderPickList(axis, items) {
    const listId  = axis === 'row' ? 'hmRowList' : 'hmColList';
    const hintId  = axis === 'row' ? 'hmRowPickHint' : 'hmColPickHint';
    const filterRef = axis === 'row' ? _hmRowFilter : _hmColFilter;
    const listEl  = document.getElementById(listId);
    if (!listEl) return;
    const panelEl = document.getElementById(axis === 'row' ? 'hmRowPanel' : 'hmColPanel');
    const total   = (panelEl?._allItems || items).length;
    const fmt     = v => v >= 1000 ? (v/1000).toLocaleString('tr-TR',{maximumFractionDigits:1})+'K' : v.toLocaleString('tr-TR',{maximumFractionDigits:0});
    listEl.innerHTML = items.map(g => {
        const safe = g.label.replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;');
        const sel  = filterRef && filterRef.has(g.label);
        return `<div class="hm-pick-item ${sel ? 'hpi-sel' : ''}" data-axis="${axis}" data-lbl="${safe}">
            <input type="checkbox" ${sel ? 'checked' : ''}>
            <span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${safe}">${safe}</span>
            <span class="hm-pick-val">${fmt(g.total)}</span>
        </div>`;
    }).join('');
    const hintEl = document.getElementById(hintId);
    if (hintEl) hintEl.textContent = `${filterRef ? filterRef.size : 0} / ${total} seçili`;
}

function _hmFilterPanel(axis) {
    const searchId = axis === 'row' ? 'hmRowSearch' : 'hmColSearch';
    const panelId  = axis === 'row' ? 'hmRowPanel' : 'hmColPanel';
    const q   = (document.getElementById(searchId)?.value || '').toLowerCase();
    const all = document.getElementById(panelId)?._allItems || [];
    const filtered = q ? all.filter(g => g.label.toLowerCase().includes(q)) : all;
    _hmRenderPickList(axis, filtered);
}

function _hmPickAll(axis) {
    const panelEl = document.getElementById(axis === 'row' ? 'hmRowPanel' : 'hmColPanel');
    const all = panelEl?._allItems || [];
    const newSet = new Set(all.map(g => g.label));
    if (axis === 'row') _hmRowFilter = newSet; else _hmColFilter = newSet;
    _hmFilterPanel(axis);
    renderHeatmap();
}

function _hmPickClear(axis) {
    if (axis === 'row') _hmRowFilter = new Set(); else _hmColFilter = new Set();
    _hmFilterPanel(axis);
    renderHeatmap();
}

// Delegated click for hm pick items
(function _hmPickListener() {
    document.addEventListener('click', function(e) {
        const item = e.target.closest('.hm-pick-item[data-axis]');
        if (!item) return;
        e.preventDefault();
        const axis  = item.getAttribute('data-axis');
        const label = item.getAttribute('data-lbl')
            ?.replace(/&amp;/g,'&').replace(/&quot;/g,'"').replace(/&lt;/g,'<');
        if (!label || !axis) return;
        const filterRef = axis === 'row' ? _hmRowFilter : _hmColFilter;
        if (!filterRef) return;
        if (filterRef.has(label)) filterRef.delete(label);
        else filterRef.add(label);
        // update just this item's appearance
        const chk = item.querySelector('input[type=checkbox]');
        const sel = filterRef.has(label);
        item.classList.toggle('hpi-sel', sel);
        if (chk) chk.checked = sel;
        const hintId  = axis === 'row' ? 'hmRowPickHint' : 'hmColPickHint';
        const panelId = axis === 'row' ? 'hmRowPanel' : 'hmColPanel';
        const total   = document.getElementById(panelId)?._allItems?.length || 0;
        const hintEl  = document.getElementById(hintId);
        if (hintEl) hintEl.textContent = `${filterRef.size} / ${total} seçili`;
        renderHeatmap();
    });
})();

function renderHeatmap() {
    const filteredData = _effectiveData();
    const wrap     = document.getElementById('hmTableWrap');
    const insightEl= document.getElementById('hmInsight');
    if (!wrap) return;

    if (!filteredData || !filteredData.length) {
        wrap.innerHTML = '<p style="color:#aaa;padding:20px;">Veri yok — önce filtre uygulayın.</p>';
        if (insightEl) insightEl.style.display = 'none';
        return;
    }

    const rowKey    = document.getElementById('hmRowBy').value;
    const colKey    = document.getElementById('hmColBy').value;
    const metric    = document.getElementById('hmMetric').value;
    const topRow    = parseInt(document.getElementById('hmTopRow').value)  || 15;
    const topCol    = parseInt(document.getElementById('hmTopCol').value)  || 12;
    const scaleName = document.getElementById('hmColorScale').value        || 'blue';
    const showVal   = document.getElementById('hmShowVal').value === '1';
    const scale     = HM_SCALES[scaleName] || HM_SCALES.blue;

    // Populate / refresh the always-visible picker panels
    _hmRefreshPanels();

    if (rowKey === colKey) {
        wrap.innerHTML = '<p style="color:#e11d48;padding:20px;">⚠️ Satır ve Sütun aynı alan olamaz — lütfen farklı iki alan seçin.</p>';
        if (insightEl) insightEl.style.display = 'none';
        return;
    }

    // ── Veriyi pivot'a çevir ──────────────────────────────────────────────────
    const rowTotals = {};
    const colTotals = {};
    const cell      = {};

    filteredData.forEach(r => {
        const rv = _hmGet(r, rowKey);
        const cv = _hmGet(r, colKey);
        const v  = metric === 'hataliMiktar'
            ? (parseFloat(r.hataliMiktar) || 0)
            : 1;
        rowTotals[rv] = (rowTotals[rv] || 0) + v;
        colTotals[cv] = (colTotals[cv] || 0) + v;
        if (!cell[rv]) cell[rv] = {};
        cell[rv][cv]  = (cell[rv][cv] || 0) + v;
    });

    const rows = _hmRowFilter && _hmRowFilter.size > 0
        ? Object.entries(rowTotals).filter(e => _hmRowFilter.has(e[0])).sort((a,b) => b[1]-a[1]).map(e => e[0])
        : Object.entries(rowTotals).filter(e => e[0] !== '—' && e[0] !== '').sort((a,b) => b[1]-a[1]).slice(0, topRow).map(e => e[0]);
    const cols = _hmColFilter && _hmColFilter.size > 0
        ? Object.entries(colTotals).filter(e => _hmColFilter.has(e[0])).sort((a,b) => b[1]-a[1]).map(e => e[0])
        : Object.entries(colTotals).filter(e => e[0] !== '—' && e[0] !== '').sort((a,b) => b[1]-a[1]).slice(0, topCol).map(e => e[0]);

    if (!rows.length || !cols.length) {
        wrap.innerHTML = '<p style="color:#aaa;padding:20px;">Bu kombinasyon için yeterli veri yok — farklı alanlar deneyin.</p>';
        if (insightEl) insightEl.style.display = 'none';
        return;
    }

    // ── Global maks ────────────────────────────────────────────────────────────
    let globalMax = 0;
    rows.forEach(r => cols.forEach(c => {
        const v = cell[r]?.[c] || 0;
        if (v > globalMax) globalMax = v;
    }));

    // ── Legend ─────────────────────────────────────────────────────────────────
    const barEl = document.getElementById('hmLegendBar');
    const maxEl = document.getElementById('hmLegendMax');
    if (barEl) barEl.style.background = `linear-gradient(to right,${scale[0]},${scale[scale.length-1]})`;
    if (maxEl) maxEl.textContent = `Maks: ${globalMax.toLocaleString('tr-TR',{maximumFractionDigits:1})}`;

    const fmt  = v => v === 0 ? '' : v.toLocaleString('tr-TR', {maximumFractionDigits:1});
    const tr26 = (s, n=24) => String(s).length > n ? String(s).slice(0,n-1)+'…' : String(s);
    const tr16 = (s, n=15) => String(s).length > n ? String(s).slice(0,n-1)+'…' : String(s);

    // Koyu/açık renk için luminans hesapla (CSS renkler)
    const luminance = (r, g, b) => (0.299*r + 0.587*g + 0.114*b);
    function textColor(cssColor) {
        // cssColor can be '#rrggbb' or 'rgb(r,g,b)'
        let r=255,g=255,b=255;
        if (cssColor.startsWith('#')) {
            r = parseInt(cssColor.slice(1,3),16);
            g = parseInt(cssColor.slice(3,5),16);
            b = parseInt(cssColor.slice(5,7),16);
        } else {
            const m = cssColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            if (m) { r=+m[1]; g=+m[2]; b=+m[3]; }
        }
        return luminance(r,g,b) > 145 ? '#1e293b' : '#ffffff';
    }
    function cellBg(v) {
        if (v <= 0 || globalMax === 0) return '#f8fafc';
        const t   = v / globalMax;
        const pos = t * (scale.length - 1);
        const lo  = Math.floor(pos);
        const hi  = Math.min(scale.length-1, lo+1);
        const f   = pos - lo;
        // hex interpolation
        const ph  = h => parseInt(h.slice(1,3),16);
        const rs  = [1,3,5].map(i => {
            const a = parseInt(scale[lo].slice(i,i+2),16);
            const b = parseInt(scale[hi].slice(i,i+2),16);
            return Math.round(a + (b-a)*f).toString(16).padStart(2,'0');
        });
        return '#' + rs.join('');
    }

    // ── Tablo HTML ─────────────────────────────────────────────────────────────
    const FIELD_LABELS = {
        cariAdi:'Cari Adı', hataTipi:'Hata Tipi', hataKaynagi:'Hata Kaynağı',
        tespitYeri:'Tespit Yeri', stokAdi:'Stok Adı', uygunsuzlukTuru:'Uyg. Türü',
        tipi:'Tipi', makine:'Makine', cariTipi:'Cari Tipi'
    };

    let html = `<table class="hm-table"><thead><tr>
        <th class="hm-row-hdr">${FIELD_LABELS[rowKey]||rowKey} \\ ${FIELD_LABELS[colKey]||colKey}</th>`;
    cols.forEach(c => { html += `<th title="${c}">${tr16(c)}</th>`; });
    html += '<th class="hm-total-col" style="min-width:72px;">Toplam</th></tr></thead><tbody>';

    rows.forEach(r => {
        const rowTotal = rowTotals[r] || 0;
        html += '<tr>';
        html += `<td title="${r}" style="font-weight:600;color:#334155;">${tr26(r)}</td>`;
        cols.forEach(c => {
            const v   = cell[r]?.[c] || 0;
            const bg  = cellBg(v);
            const fg  = textColor(bg);
            const tip = `${r} × ${c}: ${v ? v.toLocaleString('tr-TR',{maximumFractionDigits:1}) : '0'}`;
            html += `<td title="${tip}" style="background:${bg};color:${fg};text-align:center;">`;
            if (showVal && v > 0) html += `<span class="hm-cell-val">${fmt(v)}</span>`;
            html += '</td>';
        });
        html += `<td class="hm-total-col" style="text-align:right;">${fmt(rowTotal)||'0'}</td></tr>`;
    });

    // Toplam satırı
    html += '<tr class="hm-total-row"><td><b>Toplam</b></td>';
    cols.forEach(c => {
        html += `<td style="text-align:center;">${fmt(colTotals[c]||0)||'0'}</td>`;
    });
    const grand = Object.values(rowTotals)
        .reduce((a,b)=>a+b,0);
    html += `<td style="text-align:right;"><b>${fmt(grand)||'0'}</b></td></tr>`;
    html += '</tbody></table>';
    wrap.innerHTML = html;

    // ── Öngörüler ─────────────────────────────────────────────────────────────
    let hotR='', hotC='', hotV=0;
    rows.forEach(r => cols.forEach(c => {
        const v = cell[r]?.[c]||0;
        if (v > hotV) { hotV=v; hotR=r; hotC=c; }
    }));
    let spreadR='', spreadN=0;
    rows.forEach(r => {
        const n = cols.filter(c=>(cell[r]?.[c]||0)>0).length;
        if (n > spreadN) { spreadN=n; spreadR=r; }
    });
    const parts = [];
    if (hotV > 0) parts.push(`🔴 <b>En sıcak nokta:</b> ${hotR} × ${hotC} (${fmt(hotV)})`);
    if (spreadR)  parts.push(`📊 <b>En geniş dağılım:</b> ${spreadR} — ${spreadN} farklı kategori`);
    if (insightEl) {
        insightEl.innerHTML = parts.join(' &nbsp;|&nbsp; ');
        insightEl.style.display = parts.length ? 'block' : 'none';
    }
}

// Basit, güvenli alan okuyucu (tüm olası key formatlarını dener)
function _hmGet(row, key) {
    // Derived: cariTipi (Müşteri / Tedarikçi)
    if (key === 'cariTipi') {
        const cari = row.cariAdi || row['Cari Adı'] || row['cari_adi'] || '';
        return cari ? (musteriSet.has(cari) ? 'Müşteri' : 'Tedarikçi') : '—';
    }
    const direct = row[key];
    if (direct !== undefined && direct !== null && String(direct).trim() !== '') return String(direct).trim();
    // camelCase → fallback haritası
    const alt = {
        cariAdi:         row['Cari Adı']         || row['cari_adi']       || '',
        hataTipi:        row['Hata Tipi']         || row['hata_tipi']      || '',
        hataKaynagi:     row['Hata Kaynağı']      || row['hata_kaynagi']   || '',
        tespitYeri:      row['Tespit Yeri']       || row['tespit_yeri']    || '',
        stokAdi:         row['Stok Adı']          || row['stok_adi']       || '',
        uygunsuzlukTuru: row['Uygunsuzluk Türü']  || row['uyg_turu']       || '',
        tipi:            row['Tipi']              || row['tipi']           || '',
        makine:          row['Makine']            || row['makine']         || '',
    };
    const v = alt[key] || '';
    return String(v).trim() || '(Belirtilmemiş)';
}

// ─── KABARCIK (BUBBLE) GRAFİĞİ ───────────────────────────────────────────────
let bubbleChartInst = null;
let _bbGroupFilter  = null; // null = init from all; Set<string> = manual selection

const BB_METRIC_LABELS = {
    kayitSayisi:     'Kayıt Sayısı',
    hataliMiktar:    'Hatalı Miktar',
    ortHataliMiktar: 'Ort. Hatalı Miktar',
    hataOrani:       'Hata Oranı %',
    hataTipiSayisi:  'Farklı Hata Tipi Sayısı',
};

function _bbMetricVal(entry, key) {
    if (key === 'kayitSayisi')     return entry.count;
    if (key === 'hataliMiktar')    return entry.totalH;
    if (key === 'ortHataliMiktar') return entry.count > 0 ? entry.totalH / entry.count : 0;
    if (key === 'hataOrani')       return entry.totalK > 0 ? (entry.totalH / entry.totalK) * 100 : 0;
    if (key === 'hataTipiSayisi')  return entry.hataTipleri.size;
    return 0;
}

function renderBubble() {
    const filteredData = _effectiveData();
    const noDataEl  = document.getElementById('bubbleNoData');
    const wrapEl    = document.getElementById('bubbleChartWrap');
    const insightEl = document.getElementById('bubbleInsight');
    if (!wrapEl) return;

    if (!filteredData || !filteredData.length) {
        noDataEl.style.display = 'block';
        wrapEl.style.display   = 'none';
        if (insightEl) insightEl.style.display = 'none';
        return;
    }

    const groupKey = document.getElementById('bbGroupBy').value;
    const xKey     = document.getElementById('bbXAxis').value;
    const yKey     = document.getElementById('bbYAxis').value;
    const rKey     = document.getElementById('bbRAxis').value;
    const topN     = parseInt(document.getElementById('bbTopN').value) || 20;

    // Aggregate per group
    const agg = {};
    filteredData.forEach(r => {
        const g = _hmGet(r, groupKey);
        if (!agg[g]) agg[g] = { count: 0, totalH: 0, totalK: 0, hataTipleri: new Set() };
        agg[g].count++;
        agg[g].totalH += parseFloat(r.hataliMiktar) || 0;
        agg[g].totalK += parseFloat(r.kontrolMiktar) || 0;
        const ht = r.hataTipi || r['Hata Tipi'] || '';
        if (ht) agg[g].hataTipleri.add(ht);
    });

    const allGroups = Object.entries(agg)
        .filter(([k]) => k !== '—' && k !== '(Belirtilmemiş)' || agg[k].count > 0)
        .sort((a, b) => _bbMetricVal(b[1], rKey) - _bbMetricVal(a[1], rKey));
    _bbRefreshPicker(allGroups, rKey);
    const sorted = _bbGroupFilter
        ? allGroups.filter(([k]) => _bbGroupFilter.has(k))
        : allGroups.slice(0, topN === 99999 ? undefined : topN);

    if (!sorted.length) {
        noDataEl.style.display = 'block';
        wrapEl.style.display   = 'none';
        if (insightEl) insightEl.style.display = 'none';
        return;
    }

    const allRVals = sorted.map(([, e]) => _bbMetricVal(e, rKey));
    const maxR     = Math.max(...allRVals, 1);

    const datasets = sorted.map(([label, entry], i) => {
        const xVal = _bbMetricVal(entry, xKey);
        const yVal = _bbMetricVal(entry, yKey);
        const rRaw = _bbMetricVal(entry, rKey);
        const r    = Math.max(5, Math.round((rRaw / maxR) * 38));
        const color = RADAR_PALETTE[i % RADAR_PALETTE.length];
        return {
            label,
            data: [{ x: xVal, y: yVal, r, _rRaw: rRaw }],
            backgroundColor: color + 'aa',
            borderColor: color,
            borderWidth: 1.8,
            hoverBackgroundColor: color + 'dd',
        };
    });

    noDataEl.style.display = 'none';
    wrapEl.style.display   = 'block';

    if (bubbleChartInst) { bubbleChartInst.destroy(); bubbleChartInst = null; }
    const ctx = document.getElementById('bubbleChart').getContext('2d');
    bubbleChartInst = new Chart(ctx, {
        type: 'bubble',
        data: { datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'right',
                    labels: { font: { size: 11 }, padding: 10, boxWidth: 14,
                        generateLabels: chart => chart.data.datasets.map((ds, i) => ({
                            text: ds.label.length > 28 ? ds.label.slice(0,27) + '…' : ds.label,
                            fillStyle: ds.backgroundColor,
                            strokeStyle: ds.borderColor,
                            lineWidth: 1.5,
                            datasetIndex: i,
                        }))
                    }
                },
                tooltip: {
                    callbacks: {
                        label: ctx => {
                            const d = ctx.raw;
                            const fmtV = (key, v) => {
                                if (key === 'hataOrani') return v.toLocaleString('tr-TR',{maximumFractionDigits:2}) + '%';
                                if (key === 'hataTipiSayisi') return Math.round(v).toString();
                                return v >= 1000 ? (v/1000).toLocaleString('tr-TR',{maximumFractionDigits:1})+'K' : v.toLocaleString('tr-TR',{maximumFractionDigits:1});
                            };
                            return [
                                ctx.dataset.label,
                                `X — ${BB_METRIC_LABELS[xKey]}: ${fmtV(xKey, d.x)}`,
                                `Y — ${BB_METRIC_LABELS[yKey]}: ${fmtV(yKey, d.y)}`,
                                `Boyut — ${BB_METRIC_LABELS[rKey]}: ${fmtV(rKey, d._rRaw ?? 0)}`,
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: BB_METRIC_LABELS[xKey], font: { size: 12 } },
                    ticks: { callback: v => xKey === 'hataOrani' ? v.toLocaleString('tr-TR',{maximumFractionDigits:1})+'%' : v >= 1000 ? (v/1000).toLocaleString('tr-TR',{maximumFractionDigits:1})+'K' : v.toLocaleString('tr-TR',{maximumFractionDigits:0}) },
                    grid: { color: '#f1f5f9' },
                },
                y: {
                    title: { display: true, text: BB_METRIC_LABELS[yKey], font: { size: 12 } },
                    ticks: { callback: v => yKey === 'hataOrani' ? v.toLocaleString('tr-TR',{maximumFractionDigits:1})+'%' : v >= 1000 ? (v/1000).toLocaleString('tr-TR',{maximumFractionDigits:1})+'K' : v.toLocaleString('tr-TR',{maximumFractionDigits:0}) },
                    grid: { color: '#f1f5f9' },
                },
            }
        }
    });

    // Insight
    if (insightEl) {
        const top3 = sorted.slice(0, 3).map(([label, e]) => {
            const rv = _bbMetricVal(e, rKey);
            return `<b>${label}</b> (${BB_METRIC_LABELS[rKey]}: ${rv.toLocaleString('tr-TR',{maximumFractionDigits:1})})`;
        }).join(' &nbsp;|&nbsp; ');
        insightEl.innerHTML = `🔍 En büyük kabarcıklar (${BB_METRIC_LABELS[rKey]}): ${top3}`;
        insightEl.style.display = 'block';
    }
}

function downloadBubblePNG() {
    if (!bubbleChartInst) return;
    const a = document.createElement('a');
    a.href = bubbleChartInst.toBase64Image('image/png', 1);
    a.download = 'kabarcik-grafigi.png';
    a.click();
}

function _bbGroupByChange() {
    _bbGroupFilter = null; // reset selection when grouping axis changes
    renderBubble();
}

function _bbRefreshPicker(allGroups, rKey) {
    const panelEl = document.getElementById('bbPickerPanel');
    if (!panelEl) return;
    const items = allGroups.map(([label, entry]) => ({ label, total: _bbMetricVal(entry, rKey) }));
    panelEl._allItems = items;
    if (_bbGroupFilter === null) {
        _bbGroupFilter = new Set(items.map(g => g.label));
    }
    _bbFilterPicker();
}

function _bbRenderPickList(items) {
    const listEl = document.getElementById('bbPickList');
    const hintEl = document.getElementById('bbPickHint');
    if (!listEl) return;
    const fmtV = v => v >= 1000 ? (v/1000).toLocaleString('tr-TR',{maximumFractionDigits:1})+'K' : v.toLocaleString('tr-TR',{maximumFractionDigits:0});
    listEl.innerHTML = items.map(g => {
        const safe = g.label.replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;');
        const sel  = _bbGroupFilter && _bbGroupFilter.has(g.label);
        return `<div class="bb-pick-item ${sel ? 'bpi-sel' : ''}" data-bblbl="${safe}">
            <input type="checkbox" ${sel ? 'checked' : ''}>
            <span title="${safe}">${safe.length > 24 ? safe.slice(0,23)+'…' : safe}</span>
            <span class="bb-pick-val">${fmtV(g.total)}</span>
        </div>`;
    }).join('');
    const panelEl = document.getElementById('bbPickerPanel');
    const total   = panelEl?._allItems?.length || 0;
    if (hintEl) hintEl.textContent = `${_bbGroupFilter ? _bbGroupFilter.size : 0} / ${total} seçili`;
}

function _bbFilterPicker() {
    const q   = (document.getElementById('bbPickSearch')?.value || '').toLowerCase();
    const all = document.getElementById('bbPickerPanel')?._allItems || [];
    const filtered = q ? all.filter(g => g.label.toLowerCase().includes(q)) : all;
    _bbRenderPickList(filtered);
}

function _bbPickAll() {
    const all = document.getElementById('bbPickerPanel')?._allItems || [];
    _bbGroupFilter = new Set(all.map(g => g.label));
    _bbFilterPicker();
    renderBubble();
}

function _bbPickClear() {
    _bbGroupFilter = new Set();
    _bbFilterPicker();
    renderBubble();
}

// Delegated click for bubble group picker
(function _bbPickListener() {
    document.addEventListener('click', function(e) {
        const item = e.target.closest('.bb-pick-item[data-bblbl]');
        if (!item) return;
        e.preventDefault();
        const label = item.getAttribute('data-bblbl')
            ?.replace(/&amp;/g,'&').replace(/&quot;/g,'"').replace(/&lt;/g,'<');
        if (!label || !_bbGroupFilter) return;
        if (_bbGroupFilter.has(label)) _bbGroupFilter.delete(label);
        else _bbGroupFilter.add(label);
        const chk = item.querySelector('input[type=checkbox]');
        const sel = _bbGroupFilter.has(label);
        item.classList.toggle('bpi-sel', sel);
        if (chk) chk.checked = sel;
        const panelEl = document.getElementById('bbPickerPanel');
        const total   = panelEl?._allItems?.length || 0;
        const hintEl  = document.getElementById('bbPickHint');
        if (hintEl) hintEl.textContent = `${_bbGroupFilter.size} / ${total} seçili`;
        renderBubble();
    });
})();

// ─── GRUPLU / YIĞILMIŞ BAR GRAFİĞİ ─────────────────────────────────────────
let barChartInst = null;

const GB_PALETTE = [
    '#16a34a','#2563eb','#dc2626','#d97706','#7c3aed',
    '#0891b2','#db2777','#65a30d','#9333ea','#0f766e',
    '#c2410c','#1d4ed8','#be123c','#b45309','#047857',
];

function renderGroupedBar() {
    const filteredData = _effectiveData();
    const noDataEl  = document.getElementById('barNoData');
    const wrapEl    = document.getElementById('barChartWrap');
    const insightEl = document.getElementById('barInsight');
    if (!wrapEl) return;

    if (!filteredData || !filteredData.length) {
        noDataEl.style.display = 'block'; wrapEl.style.display = 'none';
        if (insightEl) insightEl.style.display = 'none';
        return;
    }

    const groupKey  = document.getElementById('gbGroupBy').value;
    const stackKey  = document.getElementById('gbStackBy').value;
    const metric    = document.getElementById('gbMetric').value;
    const mode      = document.getElementById('gbMode').value;       // stacked | grouped | percent
    const sortMode  = document.getElementById('gbSort').value;
    const topGroup  = parseInt(document.getElementById('gbTopGroup').value) || 15;
    const topStack  = parseInt(document.getElementById('gbTopStack').value) || 8;
    const dir       = document.getElementById('gbDir').value;        // vertical | horizontal

    // Aggregate: pivot[group][stack] = value
    const rowTotals = {}, stackTotals = {}, pivot = {};
    filteredData.forEach(r => {
        const g = _hmGet(r, groupKey);
        const s = _hmGet(r, stackKey);
        const v = metric === 'hataliMiktar' ? (parseFloat(r.hataliMiktar) || 0) : 1;
        rowTotals[g]   = (rowTotals[g]   || 0) + v;
        stackTotals[s] = (stackTotals[s] || 0) + v;
        if (!pivot[g]) pivot[g] = {};
        pivot[g][s] = (pivot[g][s] || 0) + v;
    });

    // Top groups
    let groups = Object.entries(rowTotals)
        .filter(([k]) => k !== '—' && k !== '(Belirtilmemiş)')
        .sort(sortMode === 'asc' ? (a,b) => a[1]-b[1] : sortMode === 'alpha' ? (a,b) => a[0].localeCompare(b[0],'tr') : (a,b) => b[1]-a[1])
        .slice(0, topGroup >= 99999 ? undefined : topGroup)
        .map(([k]) => k);

    // Top stacks
    const stacks = Object.entries(stackTotals)
        .filter(([k]) => k !== '—' && k !== '(Belirtilmemiş)')
        .sort((a,b) => b[1]-a[1])
        .slice(0, topStack >= 99999 ? undefined : topStack)
        .map(([k]) => k);

    if (!groups.length || !stacks.length) {
        noDataEl.style.display = 'block'; wrapEl.style.display = 'none';
        if (insightEl) insightEl.style.display = 'none';
        return;
    }

    const metricLabel = metric === 'hataliMiktar' ? 'Hatalı Miktar' : 'Kayıt Sayısı';
    const isPercent   = mode === 'percent';
    const isHoriz     = dir === 'horizontal';

    // Build datasets (one per stack)
    const datasets = stacks.map((s, i) => {
        const color = GB_PALETTE[i % GB_PALETTE.length];
        const rawData = groups.map(g => pivot[g]?.[s] || 0);
        let data = rawData;
        if (isPercent) {
            data = groups.map((g, gi) => {
                const rowSum = stacks.reduce((acc, st) => acc + (pivot[g]?.[st] || 0), 0);
                return rowSum > 0 ? Math.round((rawData[gi] / rowSum) * 1000) / 10 : 0;
            });
        }
        return {
            label: s,
            data,
            _rawData: rawData,
            backgroundColor: color + 'cc',
            borderColor: color,
            borderWidth: 1,
            borderRadius: mode === 'grouped' ? 3 : 0,
            borderSkipped: false,
        };
    });

    noDataEl.style.display = 'none';
    wrapEl.style.display   = 'block';

    // Dynamic height for horizontal mode
    if (isHoriz) {
        wrapEl.style.height = Math.max(400, groups.length * 28 + 120) + 'px';
    } else {
        wrapEl.style.height = '500px';
    }

    if (barChartInst) { barChartInst.destroy(); barChartInst = null; }
    const ctx = document.getElementById('barChart').getContext('2d');

    const fmtTick = v => isPercent ? v + '%' : v >= 1000 ? (v/1000).toLocaleString('tr-TR',{maximumFractionDigits:1})+'K' : v.toLocaleString('tr-TR',{maximumFractionDigits:0});
    const tr20 = s => String(s).length > 20 ? String(s).slice(0,19)+'…' : String(s);

    barChartInst = new Chart(ctx, {
        type: 'bar',
        data: { labels: groups.map(tr20), datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: isHoriz ? 'y' : 'x',
            plugins: {
                legend: { position: 'top', labels: { font:{ size:11 }, padding:10, boxWidth:13 } },
                tooltip: {
                    callbacks: {
                        label: ctx => {
                            const ds = ctx.dataset;
                            const raw = ds._rawData?.[ctx.dataIndex] ?? ctx.parsed[isHoriz ? 'x' : 'y'];
                            const fmtV = v => v >= 1000 ? (v/1000).toLocaleString('tr-TR',{maximumFractionDigits:1})+'K' : v.toLocaleString('tr-TR',{maximumFractionDigits:1});
                            return isPercent
                                ? `${ds.label}: ${ctx.parsed[isHoriz?'x':'y']}% (${fmtV(raw)})`
                                : `${ds.label}: ${fmtV(raw)}`;
                        }
                    }
                }
            },
            scales: {
                x: {
                    stacked: mode !== 'grouped',
                    grid: { color: '#f1f5f9' },
                    ticks: isHoriz
                        ? { callback: fmtTick }
                        : { maxRotation: 40, font:{ size:11 } },
                    title: isHoriz ? { display:true, text: isPercent ? '%' : metricLabel, font:{ size:11 } } : undefined,
                    max: isPercent && !isHoriz ? 100 : undefined,
                },
                y: {
                    stacked: mode !== 'grouped',
                    grid: { color: '#f1f5f9' },
                    ticks: isHoriz
                        ? { font:{ size:11 } }
                        : { callback: fmtTick },
                    title: !isHoriz ? { display:true, text: isPercent ? '%' : metricLabel, font:{ size:11 } } : undefined,
                    max: isPercent && isHoriz ? 100 : undefined,
                },
            }
        }
    });

    // Insight
    if (insightEl) {
        const topG = groups[0];
        const topGTotal = rowTotals[topG] || 0;
        const topS = stacks[0];
        const fmtV = v => v >= 1000 ? (v/1000).toLocaleString('tr-TR',{maximumFractionDigits:1})+'K' : v.toLocaleString('tr-TR',{maximumFractionDigits:1});
        insightEl.innerHTML = `💡 En yüksek toplam: <b>${topG}</b> (${fmtV(topGTotal)}) &nbsp;|  En dominant katman: <b>${topS}</b> (toplam ${fmtV(stackTotals[topS])}) &nbsp;|  ${groups.length} grup, ${stacks.length} katman`;
        insightEl.style.display = 'block';
    }
}

function downloadBarPNG() {
    if (!barChartInst) return;
    const a = document.createElement('a');
    a.href = barChartInst.toBase64Image('image/png', 1);
    a.download = 'gruplu-bar-grafigi.png';
    a.click();
}

// ─── SANKEYDİYAGRAMI ─────────────────────────────────────────────────────────
let sankeyChartInst = null;

const SK_PALETTE = [
    '#f59e0b','#ef4444','#3b82f6','#10b981','#8b5cf6',
    '#ec4899','#06b6d4','#84cc16','#f97316','#6366f1',
    '#14b8a6','#e11d48','#0ea5e9','#a855f7','#22c55e',
    '#fb923c','#38bdf8','#4ade80','#c084fc','#f43f5e',
];

function _skGet(row, key) { return _hmGet(row, key); }

function renderSankey() {
    const filteredData = _effectiveData();
    const noDataEl  = document.getElementById('sankeyNoData');
    const wrapEl    = document.getElementById('sankeyChartWrap');
    const insightEl = document.getElementById('sankeyInsight');
    const legendEl  = document.getElementById('sankeyLegend');
    if (!wrapEl) return;

    const hide = () => {
        noDataEl.style.display = 'block';
        wrapEl.style.display   = 'none';
        if (insightEl) insightEl.style.display = 'none';
        if (legendEl)  legendEl.style.display  = 'none';
    };

    if (!filteredData || !filteredData.length) { hide(); return; }

    const fromKey   = document.getElementById('skFrom').value;
    const toKey     = document.getElementById('skTo').value;
    const metric    = document.getElementById('skMetric').value;
    const topN      = parseInt(document.getElementById('skTopN').value) || 20;
    const minVal    = parseFloat(document.getElementById('skMinVal').value) || 0;
    const colorMode = document.getElementById('skColorMode').value;

    if (fromKey === toKey) {
        noDataEl.textContent = '⚠️ Sol ve Sağ alanlar aynı olamaz — farklı bir alan seçin.';
        hide(); return;
    }
    noDataEl.textContent = '⚠️ Veri yok — filtre uygulayın veya farklı alanlar seçin.';

    // Aggregate flows
    const flowMap = {};
    filteredData.forEach(r => {
        const f = _skGet(r, fromKey);
        const t = _skGet(r, toKey);
        if (!f || f === '—' || !t || t === '—') return;
        const v = metric === 'hataliMiktar' ? (parseFloat(r.hataliMiktar) || 0) : 1;
        const key = f + '|||' + t;
        flowMap[key] = (flowMap[key] || 0) + v;
    });

    // Filter by min value and sort by flow descending, take topN
    let flows = Object.entries(flowMap)
        .filter(([, v]) => v >= minVal)
        .sort((a, b) => b[1] - a[1])
        .slice(0, topN >= 99999 ? undefined : topN)
        .map(([k, v]) => {
            const [from, to] = k.split('|||');
            return { from, to, flow: v };
        });

    if (!flows.length) { hide(); return; }

    // Assign colors to unique node names
    const nodeNames = [...new Set([...flows.map(f => f.from), ...flows.map(f => f.to)])];
    const colorMap = {};
    nodeNames.forEach((n, i) => { colorMap[n] = SK_PALETTE[i % SK_PALETTE.length]; });

    const fmtV = v => v >= 1000 ? (v / 1000).toLocaleString('tr-TR', { maximumFractionDigits: 1 }) + 'K' : v.toLocaleString('tr-TR', { maximumFractionDigits: 0 });
    const metricLabel = metric === 'hataliMiktar' ? 'Hatalı Miktar' : 'Kayıt Sayısı';

    // Dynamic canvas height based on unique source nodes
    const fromNodes = [...new Set(flows.map(f => f.from))];
    const canH = Math.max(420, fromNodes.length * 36 + 120);

    noDataEl.style.display = 'none';
    wrapEl.style.display   = 'block';
    wrapEl.style.height    = canH + 'px';

    if (sankeyChartInst) { sankeyChartInst.destroy(); sankeyChartInst = null; }

    const canvas = document.getElementById('sankeyChart');
    canvas.style.height = canH + 'px';
    const ctx = canvas.getContext('2d');

    sankeyChartInst = new Chart(ctx, {
        type: 'sankey',
        data: {
            datasets: [{
                data: flows,
                colorFrom: c => {
                    const d = c.dataset.data[c.dataIndex];
                    return d ? (colorMap[d.from] || '#999') : '#999';
                },
                colorTo: c => {
                    const d = c.dataset.data[c.dataIndex];
                    return d ? (colorMap[d.to] || '#999') : '#999';
                },
                colorMode,
                labels: Object.fromEntries(nodeNames.map(n => [n, n])),
                size: 'max',
                borderWidth: 0,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: ctx => {
                            const d = ctx.dataset.data[ctx.dataIndex];
                            if (!d) return '';
                            return `${d.from} → ${d.to}: ${fmtV(d.flow)} ${metricLabel}`;
                        }
                    }
                }
            }
        }
    });

    // Legend
    if (legendEl) {
        legendEl.style.display = 'flex';
        legendEl.innerHTML = nodeNames.map(n =>
            `<span class="sk-legend-item"><span class="sk-legend-dot" style="background:${colorMap[n]}"></span><span title="${n}">${n.length > 22 ? n.slice(0, 21) + '…' : n}</span></span>`
        ).join('');
    }

    // Insight
    if (insightEl) {
        const totalFlow = flows.reduce((s, f) => s + f.flow, 0);
        const top = flows[0];
        const pct = totalFlow > 0 ? Math.round((top.flow / totalFlow) * 100) : 0;
        insightEl.innerHTML = `💡 En güçlü akış: <b>${top.from} → ${top.to}</b> (${fmtV(top.flow)}, toplam %${pct}) &nbsp;|&nbsp; ${flows.length} benzersiz akış &nbsp;|&nbsp; ${fromNodes.length} kaynak node &nbsp;|&nbsp; ${[...new Set(flows.map(f => f.to))].length} hedef node`;
        insightEl.style.display = 'block';
    }
}

function downloadSankeyPNG() {
    if (!sankeyChartInst) return;
    const a = document.createElement('a');
    a.href = sankeyChartInst.toBase64Image('image/png', 1);
    a.download = 'sankey-diyagrami.png';
    a.click();
}

// ─── BOX PLOT (KUTU GRAFİK) ─────────────────────────────────────────────────────
let boxPlotChartInst = null;
let _bpGroupFilter   = null; // null = Top-N mode; Set<string> = manual selection

function _bpGetVal(row, metric) {
    if (metric === 'hataliMiktar')  return parseFloat(row.hataliMiktar  || row['Hatalı Miktar']  || 0) || 0;
    if (metric === 'kontrolMiktar') return parseFloat(row.kontrolMiktar || row['Kontrol Miktar'] || 0) || 0;
    return 0;
}

function _bpStats(arr) {
    if (!arr.length) return null;
    const sorted = [...arr].sort((a, b) => a - b);
    const n    = sorted.length;
    const q1   = sorted[Math.floor(n * 0.25)];
    const med  = n % 2 === 0 ? (sorted[n/2 - 1] + sorted[n/2]) / 2 : sorted[Math.floor(n/2)];
    const q3   = sorted[Math.floor(n * 0.75)];
    const mean = arr.reduce((s, v) => s + v, 0) / n;
    return { min: sorted[0], q1, median: med, mean, q3, max: sorted[n-1], iqr: q3 - q1, n };
}

function renderBoxPlot() {
    const filteredData = _effectiveData();
    const noDataEl  = document.getElementById('bpNoData');
    const wrapEl    = document.getElementById('bpChartWrap');
    const insightEl = document.getElementById('bpInsight');
    const statsWrap = document.getElementById('bpStatsWrap');
    const statsTbody = document.getElementById('bpStatsTbody');
    if (!wrapEl) return;

    const hide = () => {
        noDataEl.style.display = 'block';
        wrapEl.style.display   = 'none';
        if (insightEl)  insightEl.style.display  = 'none';
        if (statsWrap)  statsWrap.style.display  = 'none';
    };

    if (!filteredData || !filteredData.length) { hide(); return; }

    const groupKey = document.getElementById('bpGroupBy').value;
    const metric   = document.getElementById('bpMetric').value;
    const sortMode = document.getElementById('bpSort').value;
    const topN     = parseInt(document.getElementById('bpTopN').value) || 15;
    const isHoriz  = document.getElementById('bpDir').value === 'horizontal';
    const showOut  = document.getElementById('bpOutliers').value === '1';

    // Aggregate raw arrays per group
    const groupMap = {};
    filteredData.forEach(r => {
        const g = _hmGet(r, groupKey);
        if (!g || g === '—') return;
        if (!groupMap[g]) groupMap[g] = [];
        const v = _bpGetVal(r, metric);
        if (v > 0) groupMap[g].push(v);   // skip zero unless all are zero
    });

    // If all values are 0 for a group, include zeros
    filteredData.forEach(r => {
        const g = _hmGet(r, groupKey);
        if (!g || g === '—') return;
        if (!groupMap[g]) groupMap[g] = [];
        if (groupMap[g].length === 0) groupMap[g].push(_bpGetVal(r, metric));
    });

    const statsMap = {};
    Object.entries(groupMap).forEach(([g, arr]) => {
        const s = _bpStats(arr);
        if (s) statsMap[g] = s;
    });

    if (!Object.keys(statsMap).length) { hide(); return; }

    // Sort all entries
    let entries = Object.entries(statsMap);
    if (sortMode === 'median') entries.sort((a, b) => b[1].median - a[1].median);
    else if (sortMode === 'q3')    entries.sort((a, b) => b[1].q3 - a[1].q3);
    else if (sortMode === 'mean')  entries.sort((a, b) => b[1].mean - a[1].mean);
    else if (sortMode === 'count') entries.sort((a, b) => b[1].n - a[1].n);
    else entries.sort((a, b) => a[0].localeCompare(b[0], 'tr'));

    // Refresh picker with all sorted groups
    _bpRefreshPicker(entries, statsMap);

    // Apply manual filter OR Top-N
    if (_bpGroupFilter !== null) {
        entries = entries.filter(([g]) => _bpGroupFilter.has(g));
    } else if (topN < 99999) {
        entries = entries.slice(0, topN);
    }

    const labels = entries.map(([g]) => g);
    const metricLabel = metric === 'hataliMiktar' ? 'Hatalı Miktar' : 'Kontrol Miktar';

    // Build data for chartjs-chart-boxplot (pass raw arrays grouped by label)
    const dataArrays = entries.map(([g]) => groupMap[g]);

    // Dynamic chart height
    const canH = isHoriz ? Math.max(400, entries.length * 32 + 100) : 460;
    noDataEl.style.display = 'none';
    wrapEl.style.display   = 'block';
    wrapEl.style.height    = canH + 'px';
    document.getElementById('bpChart').style.height = canH + 'px';

    if (boxPlotChartInst) { boxPlotChartInst.destroy(); boxPlotChartInst = null; }
    const ctx = document.getElementById('bpChart').getContext('2d');

    const fmtV = v => v >= 1000 ? (v/1000).toLocaleString('tr-TR',{maximumFractionDigits:1})+'K'
                                 : v.toLocaleString('tr-TR',{maximumFractionDigits:1});
    const tr22 = s => String(s).length > 22 ? String(s).slice(0,21)+'…' : String(s);

    boxPlotChartInst = new Chart(ctx, {
        type: 'boxplot',
        data: {
            labels: labels.map(tr22),
            datasets: [{
                label: metricLabel,
                data: dataArrays,
                backgroundColor: 'rgba(13,148,136,0.3)',
                borderColor:     '#0d9488',
                borderWidth:     2,
                medianColor:     '#0f766e',
                meanBackgroundColor: '#f59e0b',
                meanBorderColor:     '#d97706',
                meanRadius:      5,
                outlierBackgroundColor: showOut ? 'rgba(220,38,38,0.6)' : 'transparent',
                outlierBorderColor:     showOut ? '#dc2626' : 'transparent',
                outlierRadius:          showOut ? 4 : 0,
                itemBackgroundColor:    'rgba(0,0,0,0)',
                itemBorderColor:        'rgba(0,0,0,0)',
                itemRadius:             0,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: isHoriz ? 'y' : 'x',
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: ctx => {
                            const s = ctx.raw;
                            if (!s) return '';
                            return [
                                `N: ${s.items?.length ?? ''}`,
                                `Min: ${fmtV(s.min)} | Q1: ${fmtV(s.q1)}`,
                                `Medyan: ${fmtV(s.median)} | Ort.: ${fmtV(s.mean)}`,
                                `Q3: ${fmtV(s.q3)} | Maks: ${fmtV(s.max)}`,
                                `IQR: ${fmtV(s.q3 - s.q1)}`,
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    grid: { color: '#f1f5f9' },
                    ticks: isHoriz
                        ? { callback: v => fmtV(v) }
                        : { maxRotation: 40, font:{ size:11 } },
                    title: isHoriz ? { display:true, text: metricLabel } : undefined,
                },
                y: {
                    grid: { color: '#f1f5f9' },
                    ticks: isHoriz
                        ? { font:{ size:11 } }
                        : { callback: v => fmtV(v) },
                    title: !isHoriz ? { display:true, text: metricLabel } : undefined,
                }
            }
        }
    });

    // Stats table
    if (statsTbody && statsWrap) {
        statsWrap.style.display = 'block';
        statsTbody.innerHTML = entries.map(([g, s]) =>
            `<tr>
                <td title="${g}">${g.length > 30 ? g.slice(0,29)+'…' : g}</td>
                <td>${s.n}</td>
                <td>${fmtV(s.min)}</td>
                <td>${fmtV(s.q1)}</td>
                <td><b>${fmtV(s.median)}</b></td>
                <td>${fmtV(s.mean)}</td>
                <td>${fmtV(s.q3)}</td>
                <td>${fmtV(s.max)}</td>
                <td>${fmtV(s.iqr)}</td>
            </tr>`
        ).join('');
    }

    // Insight
    if (insightEl) {
        const topMed   = entries.reduce((a, b) => b[1].median > a[1].median ? b : a);
        const topIQR   = entries.reduce((a, b) => b[1].iqr > a[1].iqr ? b : a);
        const topN3    = entries[0];
        insightEl.innerHTML = `💡 En yüksek medyan: <b>${topMed[0]}</b> (${fmtV(topMed[1].median)}) &nbsp;|&nbsp; En geniş dağılım (IQR): <b>${topIQR[0]}</b> (${fmtV(topIQR[1].iqr)}) &nbsp;|&nbsp; ${entries.length} grup gösteriliyor`;
        insightEl.style.display = 'block';
    }
}

function downloadBoxPlotPNG() {
    if (!boxPlotChartInst) return;
    const a = document.createElement('a');
    a.href = boxPlotChartInst.toBase64Image('image/png', 1);
    a.download = 'kutu-grafik.png';
    a.click();
}

function _bpGroupByChange() {
    _bpGroupFilter = null;
    renderBoxPlot();
}

function _bpRefreshPicker(sortedEntries, statsMap) {
    const panelEl = document.getElementById('bpPickerPanel');
    if (!panelEl) return;
    const items = sortedEntries.map(([g, s]) => ({ label: g, count: s.n }));
    panelEl._allItems = items;
    // null = Top-N mode, don't convert to Set here
    _bpFilterPicker();
}

function _bpRenderPickList(items) {
    const listEl = document.getElementById('bpPickList');
    const hintEl = document.getElementById('bpPickHint');
    if (!listEl) return;
    listEl.innerHTML = items.map(item => {
        const safe = item.label.replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;');
        const sel  = _bpGroupFilter === null || _bpGroupFilter.has(item.label);
        return `<div class="bp-pick-item ${sel ? 'bppi-sel' : ''}" data-bplbl="${safe}">
            <input type="checkbox" ${sel ? 'checked' : ''}>
            <span title="${safe}">${safe.length > 26 ? safe.slice(0,25)+'…' : safe}</span>
            <span class="bp-pick-val">${item.count}</span>
        </div>`;
    }).join('');
    const total = document.getElementById('bpPickerPanel')?._allItems?.length || 0;
    const selCount = _bpGroupFilter === null ? total : _bpGroupFilter.size;
    if (hintEl) hintEl.textContent = `${selCount} / ${total} seçili`;
}

function _bpFilterPicker() {
    const q   = (document.getElementById('bpPickSearch')?.value || '').toLowerCase();
    const all = document.getElementById('bpPickerPanel')?._allItems || [];
    _bpRenderPickList(q ? all.filter(i => i.label.toLowerCase().includes(q)) : all);
}

function _bpPickAll() {
    const all = document.getElementById('bpPickerPanel')?._allItems || [];
    _bpGroupFilter = new Set(all.map(i => i.label));
    _bpFilterPicker();
    renderBoxPlot();
}

function _bpPickClear() {
    _bpGroupFilter = new Set();
    _bpFilterPicker();
    renderBoxPlot();
}

(function _bpPickListener() {
    document.addEventListener('click', function(e) {
        const item = e.target.closest('.bp-pick-item[data-bplbl]');
        if (!item) return;
        e.preventDefault();
        const label = item.getAttribute('data-bplbl')
            ?.replace(/&amp;/g,'&').replace(/&quot;/g,'"').replace(/&lt;/g,'<');
        if (!label) return;
        // Transition from Top-N mode to manual mode when user clicks an item
        if (_bpGroupFilter === null) {
            const allItems = document.getElementById('bpPickerPanel')?._allItems || [];
            _bpGroupFilter = new Set(allItems.map(i => i.label));
        }
        if (_bpGroupFilter.has(label)) _bpGroupFilter.delete(label);
        else _bpGroupFilter.add(label);
        const chk = item.querySelector('input[type=checkbox]');
        const sel = _bpGroupFilter.has(label);
        item.classList.toggle('bppi-sel', sel);
        if (chk) chk.checked = sel;
        const total = document.getElementById('bpPickerPanel')?._allItems?.length || 0;
        const hintEl = document.getElementById('bpPickHint');
        if (hintEl) hintEl.textContent = `${_bpGroupFilter.size} / ${total} seçili`;
        renderBoxPlot();
    });
})();

// ─── SCATTER PLOT (DAĞILIM) ──────────────────────────────────────────────────
let scatterChartInst = null;
let _scColorFilter   = null; // null = init from all; Set<string> = manual selection

const SC_PALETTE = [
    '#ea580c','#2563eb','#16a34a','#dc2626','#7c3aed',
    '#0891b2','#db2777','#b45309','#0f766e','#9333ea',
    '#65a30d','#be123c','#1d4ed8','#c2410c','#6d28d9','#047857',
];

function _scGetVal(row, key) {
    if (key === 'hataliMiktar')  return parseFloat(row.hataliMiktar  || row['Hatalı Miktar']  || 0) || 0;
    if (key === 'kontrolMiktar') return parseFloat(row.kontrolMiktar || row['Kontrol Miktar'] || 0) || 0;
    if (key === 'hataOrani') {
        const h = parseFloat(row.hataliMiktar  || 0) || 0;
        const k = parseFloat(row.kontrolMiktar || 0) || 0;
        return k > 0 ? Math.round((h / k) * 10000) / 100 : 0;
    }
    return 0;
}

function _scLinearRegression(pts) {
    const n = pts.length;
    if (n < 2) return null;
    const mx = pts.reduce((s, p) => s + p.x, 0) / n;
    const my = pts.reduce((s, p) => s + p.y, 0) / n;
    const num = pts.reduce((s, p) => s + (p.x - mx) * (p.y - my), 0);
    const den = pts.reduce((s, p) => s + (p.x - mx) ** 2, 0);
    if (den === 0) return null;
    const slope = num / den;
    const intercept = my - slope * mx;
    const xMin = Math.min(...pts.map(p => p.x));
    const xMax = Math.max(...pts.map(p => p.x));
    return { slope, intercept, xMin, xMax };
}

function _scPearson(pts) {
    const n = pts.length;
    if (n < 2) return null;
    const mx = pts.reduce((s, p) => s + p.x, 0) / n;
    const my = pts.reduce((s, p) => s + p.y, 0) / n;
    const num = pts.reduce((s, p) => s + (p.x - mx) * (p.y - my), 0);
    const dx  = Math.sqrt(pts.reduce((s, p) => s + (p.x - mx) ** 2, 0));
    const dy  = Math.sqrt(pts.reduce((s, p) => s + (p.y - my) ** 2, 0));
    return (dx === 0 || dy === 0) ? 0 : num / (dx * dy);
}

function renderScatter() {
    const filteredData = _effectiveData();
    const noDataEl  = document.getElementById('scNoData');
    const wrapEl    = document.getElementById('scChartWrap');
    const insightEl = document.getElementById('scInsight');
    if (!wrapEl) return;

    const hide = () => {
        noDataEl.style.display = 'block';
        wrapEl.style.display   = 'none';
        if (insightEl) insightEl.style.display = 'none';
    };

    if (!filteredData || !filteredData.length) { hide(); return; }

    const xKey      = document.getElementById('scXAxis').value;
    const yKey      = document.getElementById('scYAxis').value;
    const colorKey  = document.getElementById('scColorBy').value;
    const topColor  = parseInt(document.getElementById('scTopColor').value) || 12;
    const maxPts    = parseInt(document.getElementById('scMaxPts').value) || 500;
    const ptRadius  = parseInt(document.getElementById('scPointSize').value) || 6;
    const useLog    = document.getElementById('scLogScale').value === '1';
    const showTrend = document.getElementById('scTrendline').value === '1';

    const AXIS_LABELS = { hataliMiktar: 'Hatalı Miktar', kontrolMiktar: 'Kontrol Miktar', hataOrani: 'Hata Oranı %' };
    const xLabel = AXIS_LABELS[xKey];
    const yLabel = AXIS_LABELS[yKey];

    // Count ALL groups (no top-N limit yet) for the picker
    const groupCount = {};
    filteredData.forEach(r => {
        const g = _hmGet(r, colorKey);
        if (g && g !== '—') groupCount[g] = (groupCount[g] || 0) + 1;
    });
    const allGroups = Object.entries(groupCount)
        .sort((a, b) => b[1] - a[1])
        .map(([k]) => k);

    // Refresh picker with all groups
    _scRefreshPicker(allGroups, groupCount);

    // Apply manual filter OR Top-N
    const topGroups = _scColorFilter !== null
        ? allGroups.filter(g => _scColorFilter.has(g))
        : allGroups.slice(0, topColor >= 99999 ? undefined : topColor);
    const topSet = new Set(topGroups);

    // Bucket rows
    const groupPts = {};
    const otherPts = [];
    topGroups.forEach(g => { groupPts[g] = []; });

    // Sample rows for max points (uniform stride)
    let rows = filteredData;
    if (maxPts < 99999 && rows.length > maxPts) {
        const step = Math.ceil(rows.length / maxPts);
        rows = rows.filter((_, i) => i % step === 0);
    }

    rows.forEach(r => {
        const x = _scGetVal(r, xKey);
        const y = _scGetVal(r, yKey);
        if (x === 0 && y === 0) return;
        const g  = _hmGet(r, colorKey);
        const pt = { x, y, _group: g };
        if (topSet.has(g)) groupPts[g].push(pt);
        else otherPts.push(pt);
    });

    // Build datasets
    const datasets = topGroups
        .filter(g => groupPts[g].length > 0)
        .map((g, i) => {
            const color = SC_PALETTE[i % SC_PALETTE.length];
            return {
                label: g.length > 28 ? g.slice(0, 27) + '…' : g,
                data: groupPts[g],
                backgroundColor: color + 'bb',
                borderColor: color,
                borderWidth: 0.8,
                pointRadius: ptRadius,
                pointHoverRadius: ptRadius + 3,
            };
        });

    if (otherPts.length > 0) {
        datasets.push({
            label: 'Diğer',
            data: otherPts,
            backgroundColor: '#94a3b8aa',
            borderColor: '#94a3b8',
            borderWidth: 0.5,
            pointRadius: Math.max(2, ptRadius - 2),
            pointHoverRadius: ptRadius,
        });
    }

    // Trendline dataset
    if (showTrend) {
        const allPts = [...Object.values(groupPts).flat(), ...otherPts];
        const reg = _scLinearRegression(allPts);
        if (reg) {
            datasets.push({
                label: 'Eğim Çizgisi',
                type: 'line',
                data: [
                    { x: reg.xMin, y: reg.slope * reg.xMin + reg.intercept },
                    { x: reg.xMax, y: reg.slope * reg.xMax + reg.intercept },
                ],
                backgroundColor: 'transparent',
                borderColor: '#ef4444',
                borderWidth: 2,
                borderDash: [6, 4],
                pointRadius: 0,
                tension: 0,
            });
        }
    }

    const totalPts = datasets.reduce((s, d) => s + (d.label !== 'Eğim Çizgisi' ? d.data.length : 0), 0);
    if (totalPts === 0) { hide(); return; }

    noDataEl.style.display = 'none';
    wrapEl.style.display   = 'block';

    if (scatterChartInst) { scatterChartInst.destroy(); scatterChartInst = null; }
    const ctx = document.getElementById('scChart').getContext('2d');

    const fmtA = (k, v) => k === 'hataOrani'
        ? v.toLocaleString('tr-TR', { maximumFractionDigits: 2 }) + '%'
        : v >= 1000 ? (v / 1000).toLocaleString('tr-TR', { maximumFractionDigits: 1 }) + 'K'
                    : v.toLocaleString('tr-TR', { maximumFractionDigits: 1 });

    scatterChartInst = new Chart(ctx, {
        type: 'scatter',
        data: { datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'right',
                    labels: { font: { size: 11 }, padding: 9, boxWidth: 13 }
                },
                tooltip: {
                    callbacks: {
                        label: ctx => {
                            const d = ctx.raw;
                            return [
                                d._group || ctx.dataset.label,
                                `${xLabel}: ${fmtA(xKey, d.x)}`,
                                `${yLabel}: ${fmtA(yKey, d.y)}`,
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    type: useLog ? 'logarithmic' : 'linear',
                    title: { display: true, text: xLabel, font: { size: 12 } },
                    ticks: { callback: v => fmtA(xKey, v) },
                    grid: { color: '#f1f5f9' },
                },
                y: {
                    type: useLog ? 'logarithmic' : 'linear',
                    title: { display: true, text: yLabel, font: { size: 12 } },
                    ticks: { callback: v => fmtA(yKey, v) },
                    grid: { color: '#f1f5f9' },
                }
            }
        }
    });

    // Insight
    if (insightEl) {
        const allPts2 = Object.values(groupPts).flat();
        const r = _scPearson(allPts2);
        const rStr = r !== null ? r.toFixed(3) : '—';
        const corDesc = r === null ? '' : Math.abs(r) > 0.7 ? '(Güçlü ilişki)' : Math.abs(r) > 0.4 ? '(Orta ilişki)' : '(Zayıf ilişki)';
        insightEl.innerHTML = `💡 Gösterilen kayıt: <b>${totalPts}</b> &nbsp;|&nbsp; Pearson korelasyonu: <b>r = ${rStr}</b> ${corDesc} &nbsp;|&nbsp; ${datasets.filter(d => d.label !== 'Eğim Çizgisi').length} renk grubu`;
        insightEl.style.display = 'block';
    }
}

function downloadScatterPNG() {
    if (!scatterChartInst) return;
    const a = document.createElement('a');
    a.href = scatterChartInst.toBase64Image('image/png', 1);
    a.download = 'dagilim-grafigi.png';
    a.click();
}

function _scColorByChange() {
    _scColorFilter = null; // reset when color axis changes
    renderScatter();
}

function _scRefreshPicker(allGroups, groupCount) {
    const panelEl = document.getElementById('scPickerPanel');
    if (!panelEl) return;
    const items = allGroups.map((g, i) => ({ label: g, count: groupCount[g] || 0, colorIdx: i }));
    panelEl._allItems = items;
    if (_scColorFilter === null) {
        _scColorFilter = new Set(items.map(g => g.label));
    }
    _scFilterPicker();
}

function _scRenderPickList(items) {
    const listEl = document.getElementById('scPickList');
    const hintEl = document.getElementById('scPickHint');
    if (!listEl) return;
    listEl.innerHTML = items.map(g => {
        const safe  = g.label.replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;');
        const sel   = _scColorFilter && _scColorFilter.has(g.label);
        const color = SC_PALETTE[g.colorIdx % SC_PALETTE.length];
        return `<div class="sc-pick-item ${sel ? 'scpi-sel' : ''}" data-sclbl="${safe}">
            <input type="checkbox" ${sel ? 'checked' : ''}>
            <span class="sc-pick-dot" style="background:${sel ? '#fff' : color};"></span>
            <span title="${safe}">${safe.length > 24 ? safe.slice(0,23)+'…' : safe}</span>
            <span class="sc-pick-val">${g.count}</span>
        </div>`;
    }).join('');
    const panelEl = document.getElementById('scPickerPanel');
    const total   = panelEl?._allItems?.length || 0;
    if (hintEl) hintEl.textContent = `${_scColorFilter ? _scColorFilter.size : 0} / ${total} seçili`;
}

function _scFilterPicker() {
    const q   = (document.getElementById('scPickSearch')?.value || '').toLowerCase();
    const all = document.getElementById('scPickerPanel')?._allItems || [];
    const filtered = q ? all.filter(g => g.label.toLowerCase().includes(q)) : all;
    _scRenderPickList(filtered);
}

function _scPickAll() {
    const all = document.getElementById('scPickerPanel')?._allItems || [];
    _scColorFilter = new Set(all.map(g => g.label));
    _scFilterPicker();
    renderScatter();
}

function _scPickClear() {
    _scColorFilter = new Set();
    _scFilterPicker();
    renderScatter();
}

// Delegated click for scatter color picker
(function _scPickListener() {
    document.addEventListener('click', function(e) {
        const item = e.target.closest('.sc-pick-item[data-sclbl]');
        if (!item) return;
        e.preventDefault();
        const label = item.getAttribute('data-sclbl')
            ?.replace(/&amp;/g,'&').replace(/&quot;/g,'"').replace(/&lt;/g,'<');
        if (!label || !_scColorFilter) return;
        if (_scColorFilter.has(label)) _scColorFilter.delete(label);
        else _scColorFilter.add(label);
        const chk = item.querySelector('input[type=checkbox]');
        const sel = _scColorFilter.has(label);
        item.classList.toggle('scpi-sel', sel);
        if (chk) chk.checked = sel;
        // update dot color
        const dot = item.querySelector('.sc-pick-dot');
        if (dot) {
            const panelEl = document.getElementById('scPickerPanel');
            const allItems = panelEl?._allItems || [];
            const entry = allItems.find(g => g.label === label);
            dot.style.background = sel ? '#fff' : (entry ? SC_PALETTE[entry.colorIdx % SC_PALETTE.length] : '#ccc');
        }
        const panelEl = document.getElementById('scPickerPanel');
        const total   = panelEl?._allItems?.length || 0;
        const hintEl  = document.getElementById('scPickHint');
        if (hintEl) hintEl.textContent = `${_scColorFilter.size} / ${total} seçili`;
        renderScatter();
    });
})();

// ─── TREEMAP ───
let treemapChartInst = null;
let _tmGroupFilter   = null;

const TM_PALETTE = [
    '#0369a1','#0891b2','#0d9488','#16a34a','#7c3aed','#dc2626',
    '#ea580c','#d97706','#db2777','#2563eb','#15803d','#9333ea',
    '#0f766e','#be123c','#b45309','#1d4ed8','#65a30d','#c2410c',
];

function _tmGetVal(row, metric) {
    if (metric === 'hataliMiktar')  return Number(row.hataliMiktar)  || 0;
    if (metric === 'kontrolMiktar') return Number(row.kontrolMiktar) || 0;
    return 1; // kayitSayisi
}

function renderTreemap() {
    const filteredData = _effectiveData();
    const noDataEl  = document.getElementById('tmNoData');
    const wrapEl    = document.getElementById('tmChartWrap');
    const insightEl = document.getElementById('tmInsight');
    if (!wrapEl) return;

    const hide = () => {
        noDataEl.style.display = 'block';
        wrapEl.style.display   = 'none';
        if (insightEl) insightEl.style.display = 'none';
    };

    if (!filteredData || !filteredData.length) { hide(); return; }

    const groupKey = document.getElementById('tmGroupBy').value;
    const metric   = document.getElementById('tmMetric').value;
    const topN     = parseInt(document.getElementById('tmTopN').value) || 20;

    const agg = {};
    filteredData.forEach(r => {
        const g = _hmGet(r, groupKey);
        if (!g || g === '\u2014') return;
        if (!agg[g]) agg[g] = { count: 0, value: 0 };
        agg[g].count++;
        agg[g].value += _tmGetVal(r, metric);
    });

    if (!Object.keys(agg).length) { hide(); return; }

    let entries = Object.entries(agg).sort((a, b) => b[1].value - a[1].value);

    _tmRefreshPicker(entries, metric);

    if (_tmGroupFilter !== null) {
        entries = entries.filter(([g]) => _tmGroupFilter.has(g));
    } else if (topN < 99999) {
        entries = entries.slice(0, topN);
    }

    if (!entries.length) { hide(); return; }

    noDataEl.style.display = 'none';
    wrapEl.style.display   = 'block';

    const tree = entries.map(([g, v]) => ({ g, v: v.value, n: v.count }));
    const total = tree.reduce((s, x) => s + x.v, 0);
    const metricLabel = metric === 'hataliMiktar' ? 'Hatalı Miktar' : metric === 'kontrolMiktar' ? 'Kontrol Miktar' : 'Kayıt Sayısı';

    if (treemapChartInst) { treemapChartInst.destroy(); treemapChartInst = null; }

    const ctx = document.getElementById('tmChart').getContext('2d');
    treemapChartInst = new Chart(ctx, {
        type: 'treemap',
        data: {
            datasets: [{
                label: metricLabel,
                tree,
                key: 'v',
                groups: ['g'],
                borderColor: 'rgba(255,255,255,0.6)',
                borderWidth: 2,
                spacing: 1,
                padding: 6,
                backgroundColor(ctx) {
                    if (ctx.type !== 'data') return 'transparent';
                    const idx = entries.findIndex(([g]) => g === ctx.raw.g);
                    return TM_PALETTE[(idx < 0 ? ctx.dataIndex : idx) % TM_PALETTE.length] + 'dd';
                },
                labels: {
                    display: true,
                    overflow: 'hidden',
                    formatter(ctx) {
                        if (ctx.type !== 'data') return '';
                        const pct = total > 0 ? (ctx.raw.v / total * 100).toFixed(1) : 0;
                        const lbl = ctx.raw.g || '';
                        return [
                            lbl.length > 22 ? lbl.slice(0, 21) + '…' : lbl,
                            ctx.raw.v.toLocaleString('tr', { maximumFractionDigits: 0 }),
                            '%' + pct
                        ];
                    },
                    color: '#fff',
                    font: [{ size: 12, weight: 'bold' }, { size: 11 }, { size: 10 }],
                }
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        title(items) { return items[0]?.raw?.g || ''; },
                        label(item) {
                            const d = item.raw;
                            const pct = total > 0 ? (d.v / total * 100).toFixed(1) : 0;
                            return [
                                metricLabel + ': ' + d.v.toLocaleString('tr', { maximumFractionDigits: 1 }),
                                'Kayıt: ' + d.n,
                                'Oran: %' + pct
                            ];
                        }
                    }
                }
            }
        }
    });

    if (insightEl) {
        insightEl.style.display = 'block';
        const top = entries[0];
        insightEl.innerHTML = `📊 <strong>${entries.length}</strong> grup &middot; Toplam ${metricLabel}: <strong>${total.toLocaleString('tr', { maximumFractionDigits: 1 })}</strong> &middot; En büyük: <strong>${top[0]}</strong> (%${(top[1].value / total * 100).toFixed(1)})`;
    }
}

function downloadTreemapPNG() {
    if (!treemapChartInst) return;
    const a = document.createElement('a');
    a.href = treemapChartInst.toBase64Image('image/png', 1);
    a.download = 'treemap.png';
    a.click();
}

function _tmGroupByChange() {
    _tmGroupFilter = null;
    renderTreemap();
}

function _tmRefreshPicker(sortedEntries, metric) {
    const panelEl = document.getElementById('tmPickerPanel');
    if (!panelEl) return;
    const items = sortedEntries.map(([g, v]) => ({ label: g, count: v.count, value: v.value }));
    panelEl._allItems = items;
    if (_tmGroupFilter === null) {
        _tmGroupFilter = new Set(items.map(i => i.label));
    }
    _tmFilterPicker();
}

function _tmRenderPickList(items) {
    const listEl = document.getElementById('tmPickList');
    const hintEl = document.getElementById('tmPickHint');
    if (!listEl) return;
    const allItems = document.getElementById('tmPickerPanel')?._allItems || [];
    listEl.innerHTML = items.map(item => {
        const safe = item.label.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;');
        const sel  = _tmGroupFilter && _tmGroupFilter.has(item.label);
        const idx  = allItems.findIndex(i => i.label === item.label);
        const color = TM_PALETTE[(idx < 0 ? 0 : idx) % TM_PALETTE.length];
        return `<div class="tm-pick-item ${sel ? 'tmpi-sel' : ''}" data-tmlbl="${safe}">
            <input type="checkbox" ${sel ? 'checked' : ''}>
            <span style="width:9px;height:9px;border-radius:2px;background:${sel ? '#fff' : color};flex-shrink:0;display:inline-block;"></span>
            <span title="${safe}">${safe.length > 26 ? safe.slice(0, 25) + '…' : safe}</span>
            <span class="tm-pick-val">${item.count}</span>
        </div>`;
    }).join('');
    const total = allItems.length;
    if (hintEl) hintEl.textContent = `${_tmGroupFilter ? _tmGroupFilter.size : 0} / ${total} seçili`;
}

function _tmFilterPicker() {
    const q   = (document.getElementById('tmPickSearch')?.value || '').toLowerCase();
    const all = document.getElementById('tmPickerPanel')?._allItems || [];
    _tmRenderPickList(q ? all.filter(i => i.label.toLowerCase().includes(q)) : all);
}

function _tmPickAll() {
    const all = document.getElementById('tmPickerPanel')?._allItems || [];
    _tmGroupFilter = new Set(all.map(i => i.label));
    _tmFilterPicker();
    renderTreemap();
}

function _tmPickClear() {
    _tmGroupFilter = new Set();
    _tmFilterPicker();
    renderTreemap();
}

(function _tmPickListener() {
    document.addEventListener('click', function(e) {
        const item = e.target.closest('.tm-pick-item[data-tmlbl]');
        if (!item) return;
        e.preventDefault();
        const label = item.getAttribute('data-tmlbl')
            ?.replace(/&amp;/g, '&').replace(/&quot;/g, '"').replace(/&lt;/g, '<');
        if (!label || !_tmGroupFilter) return;
        if (_tmGroupFilter.has(label)) _tmGroupFilter.delete(label);
        else _tmGroupFilter.add(label);
        const chk = item.querySelector('input[type=checkbox]');
        const sel = _tmGroupFilter.has(label);
        item.classList.toggle('tmpi-sel', sel);
        if (chk) chk.checked = sel;
        const dot = item.querySelector('span[style*="border-radius:2px"]');
        if (dot) {
            const allItems = document.getElementById('tmPickerPanel')?._allItems || [];
            const idx = allItems.findIndex(i => i.label === label);
            dot.style.background = sel ? '#fff' : TM_PALETTE[(idx < 0 ? 0 : idx) % TM_PALETTE.length];
        }
        const total  = document.getElementById('tmPickerPanel')?._allItems?.length || 0;
        const hintEl = document.getElementById('tmPickHint');
        if (hintEl) hintEl.textContent = `${_tmGroupFilter.size} / ${total} seçili`;
        renderTreemap();
    });
})();

// ─── CALENDAR HEATMAP ──────────────────────────────────────────────
const CAL_THEMES = {
    indigo: ['#eef2ff','#c7d2fe','#818cf8','#4f46e5','#3730a3'],
    orange: ['#fff7ed','#fed7aa','#fb923c','#ea580c','#9a3412'],
    green:  ['#f0fdf4','#bbf7d0','#4ade80','#16a34a','#14532d'],
    red:    ['#fff1f2','#fecdd3','#f87171','#dc2626','#7f1d1d'],
    purple: ['#faf5ff','#e9d5ff','#c084fc','#9333ea','#581c87'],
};
const CAL_DAYS_TR  = ['İEİ','İSİ','ÇAR','İPİ','İÇİ','ÇMİ','CRT'];
const CAL_MONTHS_TR= ['Oca','Shu','Mar','Nis','May','Haz','Tem','Ağu','Eyl','Eki','Kas','Ara'];

function _calFillYearSelect() {
    const sel = document.getElementById('calYear');
    if (!sel) return;
    const years = new Set();
    _effectiveData().forEach(r => {
        const d = parseDateStr(r.uygunsuzlukTarih);
        if (d) years.add(d.slice(0, 4));
    });
    const sorted = [...years].sort().reverse();
    if (!sorted.length) return;
    const cur = sel.value;
    sel.innerHTML = sorted.map(y => `<option value="${y}"${y === cur ? ' selected' : ''}>${y}</option>`).join('');
    if (!sel.value) sel.value = sorted[0];
}

function renderCalendar() {
    const data = _effectiveData();
    const noEl  = document.getElementById('calNoData');
    const svgEl = document.getElementById('calSvg');
    const legEl = document.getElementById('calLegend');
    const insEl = document.getElementById('calInsight');
    if (!svgEl) return;

    _calFillYearSelect();

    const year   = document.getElementById('calYear')?.value;
    const metric = document.getElementById('calMetric')?.value || 'hataliMiktar';
    const theme  = document.getElementById('calTheme')?.value  || 'indigo';
    const colors = CAL_THEMES[theme] || CAL_THEMES.indigo;
    const metricLabel = metric === 'hataliMiktar' ? 'Hatalı Miktar' : 'Kayıt Sayısı';

    if (!year) { noEl.style.display='block'; svgEl.innerHTML=''; if(insEl) insEl.style.display='none'; return; }

    // Build day map
    const dayMap = {};
    data.forEach(r => {
        const d = parseDateStr(r.uygunsuzlukTarih);
        if (!d || !d.startsWith(year)) return;
        const v = metric === 'hataliMiktar' ? (Number(r.hataliMiktar) || 0) : 1;
        dayMap[d] = (dayMap[d] || 0) + v;
    });

    if (!Object.keys(dayMap).length) { noEl.style.display='block'; svgEl.innerHTML=''; if(insEl) insEl.style.display='none'; return; }
    noEl.style.display = 'none';

    // Color scale (quantile-based, 5 levels)
    const vals = Object.values(dayMap).filter(v => v > 0).sort((a,b) => a-b);
    const q = [0, 0.25, 0.5, 0.75, 1].map(p => {
        if (!vals.length) return 0;
        const i = Math.min(Math.floor(p * vals.length), vals.length - 1);
        return vals[i];
    });
    function colorOf(v) {
        if (!v || v === 0) return colors[0];
        if (v <= q[1]) return colors[1];
        if (v <= q[2]) return colors[2];
        if (v <= q[3]) return colors[3];
        return colors[4];
    }

    // Layout constants
    const CW = 14, CH = 14, GAP = 2;
    const STEP  = CW + GAP;
    const LEFT  = 36; // space for day labels
    const TOP   = 24; // space for month labels
    const BOT   = 10;

    // Jan 1 of year
    const jan1 = new Date(parseInt(year), 0, 1);
    // JS: 0=Sun..6=Sat; we want Mon=0..Sun=6
    const startDow = (jan1.getDay() + 6) % 7;
    const isLeap   = (y => (y%4===0&&y%100!==0)||y%400===0)(parseInt(year));
    const totalDays = isLeap ? 366 : 365;
    const totalWeeks = Math.ceil((startDow + totalDays) / 7);
    const svgW = LEFT + totalWeeks * STEP + GAP;
    const svgH = TOP + 7 * STEP + BOT;

    const ns = 'http://www.w3.org/2000/svg';
    function el(tag, attrs, text) {
        const e = document.createElementNS(ns, tag);
        for (const [k,v] of Object.entries(attrs)) e.setAttribute(k, v);
        if (text !== undefined) e.textContent = text;
        return e;
    }

    const svg = document.createElementNS(ns, 'svg');
    svg.setAttribute('id', 'calSvg');
    svg.setAttribute('width', svgW);
    svg.setAttribute('height', svgH);
    svg.style.display = 'block';
    svg.style.minWidth = '600px';

    // Day-of-week labels
    [1, 3, 5].forEach(d => {
        svg.appendChild(el('text', {
            x: LEFT - 4, y: TOP + d * STEP + CW - 3,
            'text-anchor': 'end', 'font-size': '10', fill: '#94a3b8'
        }, CAL_DAYS_TR[d]));
    });

    // Month labels + day cells
    let lastMonth = -1;
    for (let di = 0; di < totalDays; di++) {
        const d    = new Date(parseInt(year), 0, di + 1);
        const dow  = (d.getDay() + 6) % 7; // Mon=0
        const week = Math.floor((startDow + di) / 7);
        const cx   = LEFT + week * STEP;
        const cy   = TOP + dow * STEP;
        const iso  = d.toISOString().slice(0, 10);
        const val  = dayMap[iso] || 0;
        const fill = colorOf(val);

        // Month label at first day of month
        if (d.getDate() === 1 || di === 0) {
            const mn = d.getMonth();
            if (mn !== lastMonth) {
                svg.appendChild(el('text', {
                    x: cx, y: TOP - 6,
                    'font-size': '10', fill: '#64748b', 'font-weight': '600'
                }, CAL_MONTHS_TR[mn]));
                lastMonth = mn;
            }
        }

        // Cell
        const rect = el('rect', {
            x: cx, y: cy, width: CW, height: CH,
            rx: 3, ry: 3, fill,
            stroke: fill === colors[0] ? '#e2e8f0' : 'none',
            'stroke-width': '0.5'
        });
        // Tooltip via title
        const dStr  = d.toLocaleDateString('tr-TR', { weekday:'short', day:'numeric', month:'long' });
        const valStr = val > 0 ? val.toLocaleString('tr', { maximumFractionDigits: 1 }) : '0';
        rect.appendChild(el('title', {}, `${dStr}\n${metricLabel}: ${valStr}`));
        svg.appendChild(rect);
    }

    // Replace existing SVG
    const old = document.getElementById('calSvg');
    old.parentNode.replaceChild(svg, old);

    // Legend
    if (legEl) {
        legEl.innerHTML = `
            <span>Az</span>
            ${colors.map((c,i) => `<span class="cal-legend-box" style="background:${c};border:1px solid #e2e8f0;"></span>`).join('')}
            <span>Fazla</span>
            <span style="margin-left:12px;">— hedef alanlar: ${metricLabel}</span>`;
    }

    // Insight
    if (insEl) {
        const activeDays = Object.keys(dayMap).length;
        const total = Object.values(dayMap).reduce((s,v)=>s+v,0);
        const peak  = Object.entries(dayMap).sort((a,b)=>b[1]-a[1])[0];
        const peakDate = peak ? new Date(peak[0]).toLocaleDateString('tr-TR',{day:'numeric',month:'long'}) : '-';
        insEl.style.display = 'block';
        insEl.innerHTML = `📊 <strong>${year}</strong> yılı · Aktif gün: <strong>${activeDays}</strong> · Toplam ${metricLabel}: <strong>${total.toLocaleString('tr',{maximumFractionDigits:1})}</strong> · En yüksek gün: <strong>${peakDate}</strong> (${peak?peak[1].toLocaleString('tr',{maximumFractionDigits:1}):'-'})`;
    }
}

// ─── COHORT ANALİZİ ──────────────────────────────────────────────────────────
let _cohortScale = 'global'; // 'global' | 'row' | 'col'

function setCohortScale(mode) {
    _cohortScale = mode;
    ['global','row','col'].forEach(m => {
        document.getElementById('cohortScale' + m.charAt(0).toUpperCase() + m.slice(1))
            .classList.toggle('active', m === mode);
    });
    renderCohort();
}

function renderCohort() {
    const data      = _effectiveData();
    const groupBy   = document.getElementById('cohortGroupBy')?.value   || 'cariAdi';
    const metric    = document.getElementById('cohortMetric')?.value    || 'hataliMiktar';
    const display   = document.getElementById('cohortDisplay')?.value   || 'absolute';
    const maxOffset = parseInt(document.getElementById('cohortMaxOffset')?.value) || 11;
    const minBase   = parseFloat(document.getElementById('cohortMinBase')?.value) || 0;
    const noDataEl  = document.getElementById('cohortNoData');
    const tableEl   = document.getElementById('cohortTable');
    const insightEl = document.getElementById('cohortInsight');
    if (!tableEl) return;

    function addMonths(ym, n) {
        const [y, m] = ym.split('-').map(Number);
        const d = new Date(y, m - 1 + n, 1);
        return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0');
    }

    // ── 1. Collect per-group monthly totals & first-seen month ─────────────
    const groupFirstMonth = {};
    const groupMonthVals  = {};

    data.forEach(r => {
        const grp = (r[groupBy] || '(Belirtilmemiş)').toString().trim() || '(Belirtilmemiş)';
        const d   = parseDateStr(r.uygunsuzlukTarih);
        if (!d) return;
        const ym  = d.slice(0, 7);
        const val = metric === 'hataliMiktar' ? (Number(r.hataliMiktar) || 0) : 1;
        if (!groupFirstMonth[grp] || ym < groupFirstMonth[grp]) groupFirstMonth[grp] = ym;
        if (!groupMonthVals[grp])  groupMonthVals[grp] = {};
        groupMonthVals[grp][ym] = (groupMonthVals[grp][ym] || 0) + val;
    });

    const groups = Object.keys(groupFirstMonth);
    if (!groups.length) {
        noDataEl.style.display = 'block';
        tableEl.innerHTML = '';
        if (insightEl) insightEl.style.display = 'none';
        return;
    }
    noDataEl.style.display = 'none';

    // ── 2. Build offset matrix ─────────────────────────────────────────────
    let rows = groups.map(grp => {
        const first   = groupFirstMonth[grp];
        const vals    = groupMonthVals[grp];
        const offsets = [];
        for (let i = 0; i <= maxOffset; i++) {
            const ym = addMonths(first, i);
            offsets.push(vals[ym] !== undefined ? vals[ym] : null);
        }
        return { grp, first, base: offsets[0] || 0, offsets };
    }).filter(r => r.base >= minBase)
      .sort((a, b) => a.first.localeCompare(b.first) || b.base - a.base);

    if (!rows.length) {
        noDataEl.style.display = 'block';
        tableEl.innerHTML = '';
        if (insightEl) insightEl.style.display = 'none';
        return;
    }

    // ── 3. Display value calculator ───────────────────────────────────────
    function dispVal(row, ci) {
        const raw = row.offsets[ci];
        if (raw === null) return null;
        if (display === 'percent')    return row.base > 0 ? (raw / row.base) * 100 : 0;
        if (display === 'cumulative') {
            let cum = 0;
            for (let i = 0; i <= ci; i++) cum += row.offsets[i] || 0;
            return cum;
        }
        return raw;
    }

    // ── 4. Color scale ─────────────────────────────────────────────────────
    const allDispVals = [];
    rows.forEach(row => {
        for (let i = 0; i <= maxOffset; i++) {
            const v = dispVal(row, i);
            if (v !== null && v > 0) allDispVals.push(v);
        }
    });
    allDispVals.sort((a, b) => a - b);
    const globalMax = allDispVals.length ? allDispVals[allDispVals.length - 1] : 1;

    const colMaxArr = [];
    for (let ci = 0; ci <= maxOffset; ci++) {
        let mx = 0;
        rows.forEach(row => { const v = dispVal(row, ci); if (v !== null && v > mx) mx = v; });
        colMaxArr.push(mx || 1);
    }

    function cellClass(dv, ri, ci) {
        if (dv === null) return 'c0';
        if (dv === 0)    return 'c0';
        let mx;
        if (_cohortScale === 'global') {
            mx = globalMax;
        } else if (_cohortScale === 'row') {
            const rowVals = rows[ri].offsets.map((_, i) => dispVal(rows[ri], i)).filter(v => v !== null && v > 0);
            mx = rowVals.length ? Math.max(...rowVals) : 1;
        } else {
            mx = colMaxArr[ci];
        }
        const r = Math.min(1, dv / mx);
        if (r < 0.20) return 'c1';
        if (r < 0.45) return 'c2';
        if (r < 0.72) return 'c3';
        return 'c4';
    }

    // ── 5. Render ─────────────────────────────────────────────────────────
    const TR_MONTHS   = ['Oca','Şub','Mar','Nis','May','Haz','Tem','Ağu','Eyl','Eki','Kas','Ara'];
    const metricLbl   = metric === 'hataliMiktar' ? 'Hatalı Miktar' : 'Kayıt Sayısı';
    const groupLbl    = {cariAdi:'Tedarikçi',hataTipi:'Hata Tipi',tespitYeri:'Tespit Yeri',hataKaynagi:'Hata Kaynağı'}[groupBy] || groupBy;

    let html = '<tr>';
    html += `<th>${groupLbl}</th>`;
    html += '<th style="white-space:nowrap;">İlk Ay</th>';
    html += '<th style="white-space:nowrap;">Ay-0 Değeri</th>';
    for (let i = 1; i <= maxOffset; i++) html += `<th>+${i}</th>`;
    html += '</tr>';

    rows.forEach((row, ri) => {
        const [fy, fm] = row.first.split('-');
        const firstLbl = TR_MONTHS[parseInt(fm) - 1] + ' ' + fy;
        const shortGrp = row.grp.length > 26 ? row.grp.slice(0, 24) + '…' : row.grp;
        const baseDisp = row.base.toLocaleString('tr-TR', { maximumFractionDigits: 0 });

        html += `<tr>`;
        html += `<td title="${row.grp}">${shortGrp}</td>`;
        html += `<td style="text-align:center;white-space:nowrap;font-weight:600;color:#555;padding:6px 10px;">${firstLbl}</td>`;

        // Ay-0 cell (always shown as absolute in green)
        html += `<td class="cohort-cell c3" style="width:78px;" title="${row.grp} – ${firstLbl} (Ay 0): ${baseDisp} ${metricLbl}">${baseDisp}</td>`;

        for (let ci = 1; ci <= maxOffset; ci++) {
            const raw = row.offsets[ci];
            const dv  = dispVal(row, ci);
            const ym  = addMonths(row.first, ci);
            const [cy, cm] = ym.split('-');
            const monthStr  = TR_MONTHS[parseInt(cm) - 1] + ' ' + cy;
            const rawStr    = raw !== null ? raw.toLocaleString('tr-TR', { maximumFractionDigits: 1 }) : '–';

            if (dv === null) {
                html += `<td class="cohort-cell c0" title="${row.grp} – ${monthStr}: veri yok">–</td>`;
            } else {
                const cls     = cellClass(dv, ri, ci);
                const dispStr = display === 'percent'
                    ? dv.toFixed(1) + '%'
                    : dv.toLocaleString('tr-TR', { maximumFractionDigits: 0 });
                const extraTip = display !== 'absolute' ? ` (${dispStr})` : '';
                html += `<td class="cohort-cell ${cls}" title="${row.grp} – ${monthStr}&#10;${metricLbl}: ${rawStr}${extraTip}">${dispStr}</td>`;
            }
        }
        html += '</tr>';
    });

    // Totals row
    html += '<tr style="background:#e6f4ea;">';
    html += `<td style="font-weight:800;color:#166534;background:#c8e6c9;position:sticky;left:0;">TOPLAM</td>`;
    html += `<td style="padding:6px 10px;"></td>`;
    for (let ci = 0; ci <= maxOffset; ci++) {
        let sum = 0, cnt = 0;
        rows.forEach(row => { const v = row.offsets[ci]; if (v !== null) { sum += v; cnt++; } });
        const sumStr = sum.toLocaleString('tr-TR', { maximumFractionDigits: 0 });
        html += `<td class="cohort-cell ${ci === 0 ? 'c3' : cellClass(sum, -1, ci)}" title="Tüm gruplar – +${ci} Ay: ${sumStr} ${metricLbl}">${sumStr}</td>`;
    }
    html += '</tr>';

    tableEl.innerHTML = html;

    // ── 6. Insight panel ──────────────────────────────────────────────────
    if (insightEl) {
        const total = rows.length;
        const recur1 = rows.filter(r => r.offsets[1] !== null && r.offsets[1] > 0).length;
        const recur3 = rows.filter(r => {
            for (let i = 1; i <= Math.min(3, maxOffset); i++) {
                if (r.offsets[i] !== null && r.offsets[i] > 0) return true;
            }
            return false;
        }).length;
        const pct1   = total > 0 ? (recur1 / total * 100).toFixed(0) : 0;
        const pct3   = total > 0 ? (recur3 / total * 100).toFixed(0) : 0;
        const topRow = [...rows].sort((a, b) => b.base - a.base)[0];
        const avgBase = rows.reduce((s, r) => s + r.base, 0) / total;

        insightEl.style.display = 'block';
        insightEl.innerHTML = `
            🔍 <strong>${total}</strong> grup analiz edildi &nbsp;|&nbsp;
            <strong>${recur1}</strong> grup (${pct1}%) +1. ayda tekrar uygunsuzluk yaşadı &nbsp;|&nbsp;
            <strong>${recur3}</strong> grup (${pct3}%) ilk 3 ay içinde tekrarladı &nbsp;|&nbsp;
            Ortalama Ay-0 ${metricLbl}: <strong>${avgBase.toLocaleString('tr-TR',{maximumFractionDigits:1})}</strong> &nbsp;|&nbsp;
            En yüksek Ay-0: <strong>${topRow.grp}</strong>
            (<em>${topRow.base.toLocaleString('tr-TR',{maximumFractionDigits:1})} ${metricLbl}</em>)
        `;
    }
}

// ─── FUNNEL GRAFİĞİ ──────────────────────────────────────────────────────────
function renderFunnel() {
    const data      = _effectiveData();
    const groupBy   = document.getElementById('funnelGroupBy')?.value  || 'hataTipi';
    const metric    = document.getElementById('funnelMetric')?.value   || 'hataliMiktar';
    const topN      = Math.max(2, parseInt(document.getElementById('funnelTopN')?.value) || 8);
    const labelMode = document.getElementById('funnelLabel')?.value    || 'both';
    const noDataEl  = document.getElementById('funnelNoData');
    const svgWrap   = document.getElementById('funnelSvgWrap');
    const legendEl  = document.getElementById('funnelLegend');
    const insightEl = document.getElementById('funnelInsight');
    if (!svgWrap) return;

    // ── Aggregate ─────────────────────────────────────────────────────────
    const agg = {};
    data.forEach(r => {
        const grp = (r[groupBy] || '(Belirtilmemiş)').toString().trim() || '(Belirtilmemiş)';
        const val = metric === 'hataliMiktar' ? (Number(r.hataliMiktar) || 0) : 1;
        agg[grp] = (agg[grp] || 0) + val;
    });

    const stages = Object.entries(agg).sort((a, b) => b[1] - a[1]).slice(0, topN);

    if (!stages.length) {
        noDataEl.style.display = 'block';
        svgWrap.innerHTML = '';
        if (legendEl) legendEl.innerHTML = '';
        if (insightEl) insightEl.style.display = 'none';
        return;
    }
    noDataEl.style.display = 'none';

    const total  = stages.reduce((s, [, v]) => s + v, 0);
    const maxVal = stages[0][1];

    // Purple-gradient palette (dark → light)
    const COLORS = [
        '#3b0764','#4a0a6b','#5c1087','#6d28d9','#7c3aed',
        '#8b5cf6','#a78bfa','#c4b5fd','#ddd6fe','#ede9fe',
        '#2e1065','#4c1d95'
    ];

    // ── Layout constants ───────────────────────────────────────────────────
    // Left area: row number + category label
    // Middle area: trapezoid funnel bars (centred taper)
    // Right area: value+% label (always outside/right of bar) + drop% badge
    const LABEL_W  = 220;   // category name column
    const FUNNEL_W = 480;   // funnel drawing area width
    const RIGHT_W  = 220;   // value label + drop% badge column
    const TOTAL_W  = LABEL_W + FUNNEL_W + RIGHT_W;
    const BAR_H    = 54;
    const GAP      = 8;
    const svgH     = stages.length * (BAR_H + GAP) + GAP + 10;

    // ── Build SVG ─────────────────────────────────────────────────────────
    let defs = `<defs>`;
    stages.forEach((_, i) => {
        defs += `<linearGradient id="fg${i}" x1="0" y1="0" x2="1" y2="0">
            <stop offset="0%" stop-color="${COLORS[i % COLORS.length]}" stop-opacity="0.85"/>
            <stop offset="100%" stop-color="${COLORS[i % COLORS.length]}"/>
        </linearGradient>`;
    });
    defs += `</defs>`;

    let svgRows = '';
    stages.forEach(([name, val], i) => {
        const ratio  = maxVal > 0 ? val / maxVal : 0;
        // Real funnel: bar i tapers left+right symmetrically; first bar = full width
        const barW   = Math.max(60, ratio * FUNNEL_W);
        const barX   = LABEL_W + (FUNNEL_W - barW) / 2;   // centred in funnel area
        const y      = GAP + i * (BAR_H + GAP);
        const color  = COLORS[i % COLORS.length];

        const pct    = total > 0 ? (val / total * 100).toFixed(1) : '0.0';
        const valStr = val.toLocaleString('tr-TR', { maximumFractionDigits: 0 });

        let valLabel;
        if (labelMode === 'pct')        valLabel = `${pct}%`;
        else if (labelMode === 'value') valLabel = valStr;
        else                            valLabel = `${valStr}  (${pct}%)`;

        // Category label (right-aligned, left column)
        const maxLabelChars = 26;
        const shortName = name.length > maxLabelChars ? name.slice(0, maxLabelChars - 1) + '…' : name;
        const rankLabel = `${i + 1}.`;

        // Trapezoid connector to next row
        let connector = '';
        if (i < stages.length - 1) {
            const nRatio = maxVal > 0 ? stages[i + 1][1] / maxVal : 0;
            const nBarW  = Math.max(60, nRatio * FUNNEL_W);
            const nBarX  = LABEL_W + (FUNNEL_W - nBarW) / 2;
            const curBot = y + BAR_H;
            const nxtTop = curBot + GAP;
            // Trapezoid connecting bottom of this bar to top of next bar
            connector = `<polygon
                points="${barX.toFixed(1)},${curBot} ${(barX+barW).toFixed(1)},${curBot} ${(nBarX+nBarW).toFixed(1)},${nxtTop} ${nBarX.toFixed(1)},${nxtTop}"
                fill="${color}" opacity="0.28"/>`;
        }

        // Drop% badge (bottom-left corner, between bars)
        let dropBadge = '';
        if (i > 0) {
            const prevVal = stages[i - 1][1];
            const dropPct = prevVal > 0 ? ((1 - val / prevVal) * 100).toFixed(0) : 100;
            const retPct  = prevVal > 0 ? (val / prevVal * 100).toFixed(0) : 0;
            dropBadge = `
                <rect x="${(LABEL_W + FUNNEL_W + 10).toFixed(1)}" y="${(y + BAR_H/2 - 11).toFixed(1)}"
                      width="78" height="22" rx="11" fill="#f3e8ff" stroke="#c084fc" stroke-width="1.2"/>
                <text x="${(LABEL_W + FUNNEL_W + 49).toFixed(1)}" y="${(y + BAR_H/2 + 1).toFixed(1)}"
                      text-anchor="middle" dominant-baseline="middle"
                      font-size="11" fill="#6b21a8" font-family="Arial,sans-serif" font-weight="700">↓${dropPct}%  ↑${retPct}%</text>`;
        }

        // Value label: always rendered to the RIGHT of the bar area
        const valueLabelX = (LABEL_W + FUNNEL_W / 2).toFixed(1); // centred over funnel
        // Also render inside bar only if bar is wide enough
        const insideLabel = barW >= 120
            ? `<text x="${(barX + barW / 2).toFixed(1)}" y="${(y + BAR_H / 2 + 1).toFixed(1)}"
                  text-anchor="middle" dominant-baseline="middle"
                  font-size="13" fill="#fff" font-family="Arial,sans-serif" font-weight="800"
                  paint-order="stroke" stroke="#0003" stroke-width="3">${valLabel}</text>`
            : `<text x="${(barX + barW / 2).toFixed(1)}" y="${(y + BAR_H / 2 + 1).toFixed(1)}"
                  text-anchor="middle" dominant-baseline="middle"
                  font-size="11" fill="${color}" font-family="Arial,sans-serif" font-weight="700"
                  paint-order="stroke" stroke="#fff" stroke-width="4">${valLabel}</text>`;

        svgRows += `
            ${connector}
            <!-- Bar -->
            <rect x="${barX.toFixed(1)}" y="${y}" width="${barW.toFixed(1)}" height="${BAR_H}"
                  rx="6" fill="url(#fg${i})"/>
            <!-- Rank pill -->
            <rect x="${(LABEL_W - 36).toFixed(1)}" y="${(y + BAR_H/2 - 11).toFixed(1)}"
                  width="24" height="22" rx="11"
                  fill="${color}"/>
            <text x="${(LABEL_W - 24).toFixed(1)}" y="${(y + BAR_H/2 + 1).toFixed(1)}"
                  text-anchor="middle" dominant-baseline="middle"
                  font-size="11" fill="#fff" font-family="Arial,sans-serif" font-weight="800">${i + 1}</text>
            <!-- Category name -->
            <text x="${(LABEL_W - 44).toFixed(1)}" y="${(y + BAR_H/2 - 6).toFixed(1)}"
                  text-anchor="end" dominant-baseline="middle"
                  font-size="13" fill="#2e1065" font-family="Arial,sans-serif" font-weight="700">${shortName}</text>
            <!-- Value label inside bar -->
            ${insideLabel}
            <!-- Drop/retention badge -->
            ${dropBadge}
        `;
    });

    svgWrap.innerHTML = `
        <svg viewBox="0 0 ${TOTAL_W} ${svgH}"
             style="width:100%;max-width:${TOTAL_W}px;font-family:Arial,sans-serif;display:block;overflow:visible;">
            ${defs}
            <!-- Background track -->
            <rect x="${LABEL_W}" y="${GAP}" width="${FUNNEL_W}"
                  height="${svgH - GAP * 2}"
                  rx="10" fill="#f5f3ff" opacity="0.6"/>
            ${svgRows}
        </svg>`;

    // ── Legend ─────────────────────────────────────────────────────────────
    if (legendEl) {
        legendEl.innerHTML = stages.map(([name, val], i) => {
            const pct = total > 0 ? (val / total * 100).toFixed(1) : '0.0';
            return `<div class="funnel-legend-item">
                <div class="funnel-legend-dot" style="background:${COLORS[i % COLORS.length]}"></div>
                <span><strong>${i+1}.</strong> ${name} — ${val.toLocaleString('tr-TR', {maximumFractionDigits:0})} (%${pct})</span>
            </div>`;
        }).join('');
    }

    // ── Insight ────────────────────────────────────────────────────────────
    if (insightEl) {
        const top1    = stages[0];
        const n3      = Math.min(3, stages.length);
        const top3Sum = stages.slice(0, n3).reduce((s, [, v]) => s + v, 0);
        const top3Pct = total > 0 ? (top3Sum / total * 100).toFixed(1) : '0.0';
        const metLbl  = metric === 'hataliMiktar' ? 'hatalı miktar' : 'kayıt';
        const dropOff = stages.length > 1 && stages[stages.length - 1][1] > 0 && stages[0][1] > 0
            ? ((1 - stages[stages.length - 1][1] / stages[0][1]) * 100).toFixed(0) : '—';
        insightEl.style.display = 'block';
        insightEl.innerHTML = `🔺 <strong>${stages.length}</strong> kategori görüntüleniyor &nbsp;|&nbsp;
            En yüksek: <strong>${top1[0]}</strong>
            (${top1[1].toLocaleString('tr-TR', {maximumFractionDigits:0})} ${metLbl}, %${total > 0 ? (top1[1]/total*100).toFixed(1) : 0}) &nbsp;|&nbsp;
            İlk ${n3} kategori toplam ${metLbl}ın <strong>%${top3Pct}</strong>'ini oluşturuyor &nbsp;|&nbsp;
            1. → Son kademe düşüşü: <strong>%${dropOff}</strong>`;
    }
}

// ─── POLAR ALAN GRAFİĞİ ──────────────────────────────────────────────────────
let _polarChartInst = null;
let _polarSelected  = new Set();   // seçili kategoriler (boşsa = hepsi)
let _polarLastGroupBy = null;      // selector'ü yeniden doldurmak için

function _polarSelectAll(select) {
    const list = document.getElementById('polarSelList');
    if (!list) return;
    list.querySelectorAll('input[type=checkbox]').forEach(cb => {
        cb.checked = select;
        const lbl = cb.dataset.label;
        if (select) _polarSelected.add(lbl);
        else        _polarSelected.delete(lbl);
    });
    list.querySelectorAll('.polar-sel-item').forEach(el => el.classList.toggle('psi-active', select));
    renderPolarArea();
}

function _polarBuildSelector(allEntries, groupBy) {
    const list = document.getElementById('polarSelList');
    if (!list) return;
    const PALETTE = [
        '#4a0a6b','#6d28d9','#8b5cf6','#b94fc4','#c084fc',
        '#e879f9','#f0abfc','#a21caf','#7c3aed','#5b21b6',
        '#9333ea','#db2777','#4f46e5','#0891b2','#0d9488'
    ];
    // Sadece group değişince yeniden inşa et; seçimleri koru
    if (_polarLastGroupBy !== groupBy) {
        _polarSelected = new Set(allEntries.map(([k]) => k)); // hepsi seçili başlangıçta
        _polarLastGroupBy = groupBy;
    } else {
        // Yeni gelen ama henüz kayıtlı olmayan ögeleri ekle
        allEntries.forEach(([k]) => { if (!_polarSelected.has(k) && list.querySelector(`[data-label="${CSS.escape(k)}"]`) === null) _polarSelected.add(k); });
    }
    list.innerHTML = allEntries.map(([name], i) => {
        const checked  = _polarSelected.has(name);
        const short    = name.length > 22 ? name.slice(0, 20) + '…' : name;
        const escaped  = name.replace(/"/g, '&quot;');
        return `<div class="polar-sel-item ${checked ? 'psi-active' : ''}" onclick="_polarToggleItem(this,'${escaped}')">
            <input type="checkbox" data-label="${escaped}" ${checked ? 'checked' : ''} onclick="event.stopPropagation();_polarToggleItem(this.closest('.polar-sel-item'),'${escaped}')">
            <div class="polar-sel-dot" style="background:${PALETTE[i % PALETTE.length]}"></div>
            <span title="${escaped}">${short}</span>
        </div>`;
    }).join('');
}

function _polarToggleItem(el, label) {
    const cb = el.querySelector('input[type=checkbox]');
    const active = !el.classList.contains('psi-active');
    el.classList.toggle('psi-active', active);
    if (cb) cb.checked = active;
    if (active) _polarSelected.add(label);
    else        _polarSelected.delete(label);
    renderPolarArea();
}

function renderPolarArea() {
    const data       = _effectiveData();
    const groupBy    = document.getElementById('polarGroupBy')?.value  || 'hataTipi';
    const metric     = document.getElementById('polarMetric')?.value   || 'hataliMiktar';
    const topN       = Math.max(2, parseInt(document.getElementById('polarTopN')?.value) || 10);
    const secondary  = document.getElementById('polarSecondary')?.value || 'none';
    const noDataEl   = document.getElementById('polarNoData');
    const statsPanel = document.getElementById('polarStatsPanel');
    const insightEl  = document.getElementById('polarInsight');
    const canvas     = document.getElementById('polarChart');
    if (!canvas) return;

    // ── Aggregate (tam liste — selector için) ────────────────────────────
    const aggAll = {};
    data.forEach(r => {
        const grp = (r[groupBy] || '(Belirtilmemiş)').toString().trim() || '(Belirtilmemiş)';
        const val = metric === 'hataliMiktar' ? (Number(r.hataliMiktar) || 0) : 1;
        aggAll[grp] = (aggAll[grp] || 0) + val;
    });
    const allEntries = Object.entries(aggAll).sort((a, b) => b[1] - a[1]).slice(0, topN);

    // Selector listesini güncelle
    _polarBuildSelector(allEntries, groupBy);

    // ── Seçili kategorilere göre filtrele ─────────────────────────────────
    const agg = {};
    data.forEach(r => {
        const grp = (r[groupBy] || '(Belirtilmemiş)').toString().trim() || '(Belirtilmemiş)';
        if (_polarSelected.size && !_polarSelected.has(grp)) return;
        const val = metric === 'hataliMiktar' ? (Number(r.hataliMiktar) || 0) : 1;
        agg[grp] = (agg[grp] || 0) + val;
    });

    const entries = Object.entries(agg).sort((a, b) => b[1] - a[1]).slice(0, topN);

    if (!entries.length) {
        noDataEl.style.display = 'block';
        if (statsPanel) statsPanel.innerHTML = '';
        if (insightEl) insightEl.style.display = 'none';
        if (_polarChartInst) { _polarChartInst.destroy(); _polarChartInst = null; }
        return;
    }
    noDataEl.style.display = 'none';

    const labels = entries.map(([k]) => k);
    const values = entries.map(([, v]) => v);
    const total  = values.reduce((s, v) => s + v, 0);

    // ── Palette: vivid purple spectrum ─────────────────────────────────────
    const PALETTE = [
        '#4a0a6b','#6d28d9','#8b5cf6','#b94fc4','#c084fc',
        '#e879f9','#f0abfc','#a21caf','#7c3aed','#5b21b6',
        '#9333ea','#db2777','#4f46e5','#0891b2','#0d9488'
    ];
    const bgColors     = labels.map((_, i) => PALETTE[i % PALETTE.length] + 'cc'); // 80% opacity
    const borderColors = labels.map((_, i) => PALETTE[i % PALETTE.length]);

    // ── Secondary dataset (optional inner ring) ───────────────────────────
    const datasets = [];

    if (secondary !== 'none' && secondary !== groupBy) {
        const aggSec = {};
        data.forEach(r => {
            const grp = (r[secondary] || '(Belirtilmemiş)').toString().trim() || '(Belirtilmemiş)';
            const val = metric === 'hataliMiktar' ? (Number(r.hataliMiktar) || 0) : 1;
            aggSec[grp] = (aggSec[grp] || 0) + val;
        });
        const secEntries = Object.entries(aggSec).sort((a, b) => b[1] - a[1]).slice(0, topN);
        const secVals    = secEntries.map(([, v]) => v);
        const secTot     = secVals.reduce((s, v) => s + v, 0);
        // Normalise secondary to same total scale so rings are comparable
        const scale = total > 0 && secTot > 0 ? total / secTot : 1;
        datasets.push({
            label: ({'hataTipi':'Hata Tipi','tespitYeri':'Tespit Yeri','hataKaynagi':'Hata Kaynağı','cariAdi':'Tedarikçi'}[secondary] || secondary) + ' (iç halka)',
            data: secVals.map(v => v * scale),
            backgroundColor: secEntries.map((_, i) => PALETTE[(i + 5) % PALETTE.length] + '88'),
            borderColor:     secEntries.map((_, i) => PALETTE[(i + 5) % PALETTE.length]),
            borderWidth: 1.5,
        });
    }

    datasets.unshift({
        label: ({'hataTipi':'Hata Tipi','tespitYeri':'Tespit Yeri','hataKaynagi':'Hata Kaynağı','cariAdi':'Tedarikçi',hataliMiktar:'Hatalı Miktar',count:'Kayıt Sayısı'}[groupBy] || groupBy),
        data: values,
        backgroundColor: bgColors,
        borderColor: borderColors,
        borderWidth: 2,
        hoverBorderWidth: 3,
    });

    // ── Destroy & rebuild chart ───────────────────────────────────────────
    if (_polarChartInst) { _polarChartInst.destroy(); _polarChartInst = null; }

    _polarChartInst = new Chart(canvas, {
        type: 'polarArea',
        data: { labels, datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 500 },
            scales: {
                r: {
                    ticks: {
                        display: true,
                        backdropColor: 'rgba(255,255,255,0.75)',
                        font: { size: 10 },
                        color: '#6b21a8',
                        maxTicksLimit: 5,
                        callback: v => v >= 1000 ? (v/1000).toFixed(1)+'K' : v
                    },
                    grid: { color: '#e9d5ff' },
                    angleLines: { color: '#e9d5ff' },
                    pointLabels: { display: false }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'bottom',
                    labels: {
                        font: { size: 11, weight: '600' },
                        color: '#3b0764',
                        padding: 12,
                        generateLabels(chart) {
                            return chart.data.labels.map((lbl, i) => ({
                                text: lbl.length > 22 ? lbl.slice(0, 20) + '…' : lbl,
                                fillStyle: chart.data.datasets[0].backgroundColor[i],
                                strokeStyle: chart.data.datasets[0].borderColor[i],
                                lineWidth: 1.5,
                                hidden: false,
                                index: i
                            }));
                        }
                    }
                },
                tooltip: {
                    callbacks: {
                        label(ctx) {
                            const v   = ctx.raw;
                            const pct = total > 0 ? (v / total * 100).toFixed(1) : '0.0';
                            const lbl = metric === 'hataliMiktar' ? 'Hatalı Miktar' : 'Kayıt';
                            return ` ${v.toLocaleString('tr-TR', {maximumFractionDigits:0})} ${lbl}  (%${pct})`;
                        }
                    }
                }
            }
        }
    });

    // ── Stats side panel ──────────────────────────────────────────────────
    if (statsPanel) {
        const metLbl = metric === 'hataliMiktar' ? 'hatalı miktar' : 'kayıt';
        statsPanel.innerHTML = entries.map(([name, val], i) => {
            const pct   = total > 0 ? (val / total * 100).toFixed(1) : '0.0';
            const short = name.length > 30 ? name.slice(0, 28) + '…' : name;
            const vStr  = val.toLocaleString('tr-TR', {maximumFractionDigits:0});
            return `<div class="polar-stat-card">
                <div class="polar-stat-dot" style="background:${PALETTE[i % PALETTE.length]}"></div>
                <div class="polar-stat-info">
                    <span class="polar-stat-name" title="${name}">${i+1}. ${short}</span>
                    <span class="polar-stat-val">${vStr} <span class="polar-stat-pct">%${pct}</span></span>
                </div>
            </div>`;
        }).join('');
    }

    // ── Insight ────────────────────────────────────────────────────────────
    if (insightEl) {
        const top1     = entries[0];
        const top1Pct  = total > 0 ? (top1[1] / total * 100).toFixed(1) : '0.0';
        const n3       = Math.min(3, entries.length);
        const top3Pct  = total > 0 ? (entries.slice(0,n3).reduce((s,[,v])=>s+v,0) / total * 100).toFixed(1) : '0.0';
        const metLbl   = metric === 'hataliMiktar' ? 'hatalı miktar' : 'kayıt sayısı';
        const grpLbl   = {'hataTipi':'Hata Tipi','tespitYeri':'Tespit Yeri','hataKaynagi':'Hata Kaynağı','cariAdi':'Tedarikçi'}[groupBy] || groupBy;
        insightEl.style.display = 'block';
        insightEl.innerHTML = `🌐 <strong>${entries.length}</strong> ${grpLbl} kategorisi görüntüleniyor &nbsp;|&nbsp;
            En baskın: <strong>${top1[0]}</strong> (%${top1Pct}) &nbsp;|&nbsp;
            İlk ${n3} kategori toplam ${metLbl}ın <strong>%${top3Pct}</strong>'ini oluşturuyor &nbsp;|&nbsp;
            Toplam: <strong>${total.toLocaleString('tr-TR',{maximumFractionDigits:0})}</strong>`;
    }
}

// ─── CHORD DİYAGRAMI ─────────────────────────────────────────────────────────
function renderChord() {
    const data      = _effectiveData();
    const dim1      = document.getElementById('chordDim1')?.value   || 'hataTipi';
    const dim2      = document.getElementById('chordDim2')?.value   || 'tespitYeri';
    const metric    = document.getElementById('chordMetric')?.value || 'hataliMiktar';
    const topN      = Math.max(2, parseInt(document.getElementById('chordTopN')?.value) || 8);
    const noDataEl  = document.getElementById('chordNoData');
    const svgWrap   = document.getElementById('chordSvgWrap');
    const legendEl  = document.getElementById('chordLegend');
    const insightEl = document.getElementById('chordInsight');
    const tooltip   = document.getElementById('chordTooltip');
    if (!svgWrap) return;

    // ── 1. Aggregate flows dim1 → dim2 ────────────────────────────────────
    const flowMap = {};  // flowMap[a][b] = value
    const tot1 = {}, tot2 = {};
    data.forEach(r => {
        const a = (r[dim1] || '(Belirtilmemiş)').toString().trim() || '(Belirtilmemiş)';
        const b = (r[dim2] || '(Belirtilmemiş)').toString().trim() || '(Belirtilmemiş)';
        const v = metric === 'hataliMiktar' ? (Number(r.hataliMiktar) || 0) : 1;
        if (!flowMap[a]) flowMap[a] = {};
        flowMap[a][b] = (flowMap[a][b] || 0) + v;
        tot1[a] = (tot1[a] || 0) + v;
        tot2[b] = (tot2[b] || 0) + v;
    });

    const top1 = Object.entries(tot1).sort((x,y) => y[1]-x[1]).slice(0, topN).map(([k])=>k);
    const top2 = Object.keys(
        top1.reduce((acc, a) => { Object.keys(flowMap[a]||{}).forEach(b => { acc[b] = (acc[b]||0) + (flowMap[a][b]||0); }); return acc; }, {})
    ).sort((x,y) => (tot2[y]||0)-(tot2[x]||0)).slice(0, topN);

    if (!top1.length || !top2.length) {
        noDataEl.style.display = 'block'; svgWrap.innerHTML = ''; legendEl.innerHTML = '';
        if (insightEl) insightEl.style.display = 'none'; return;
    }
    noDataEl.style.display = 'none';

    // ── 2. Build unified node list: dim1 nodes then dim2 nodes ────────────
    // Nodes arranged clockwise around a circle
    const DIM1_PALETTE = ['#4a0a6b','#6d28d9','#8b5cf6','#b94fc4','#c084fc','#e879f9','#f0abfc','#a21caf','#7c3aed','#5b21b6','#9333ea','#db2777','#4f46e5','#0891b2','#0d9488','#047857'];
    const DIM2_PALETTE = ['#065f46','#0d9488','#0284c7','#1d4ed8','#4338ca','#7c3aed','#a21caf','#be123c','#b45309','#4d7c0f','#0e7490','#1e40af','#5b21b6','#831843','#78350f','#166534'];

    const nodes = [
        ...top1.map((k, i) => ({ id: k, dim: 1, color: DIM1_PALETTE[i % DIM1_PALETTE.length] })),
        ...top2.map((k, i) => ({ id: k, dim: 2, color: DIM2_PALETTE[i % DIM2_PALETTE.length] })),
    ];
    const nodeIdx = {};
    nodes.forEach((n, i) => { nodeIdx[n.id + '|' + n.dim] = i; });

    // Total value per node (for arc sizing)
    nodes.forEach(n => {
        if (n.dim === 1) {
            n.total = top2.reduce((s, b) => s + (flowMap[n.id]?.[b] || 0), 0);
        } else {
            n.total = top1.reduce((s, a) => s + (flowMap[a]?.[n.id] || 0), 0);
        }
    });
    const grandTotal = nodes.reduce((s, n) => s + n.total, 0);
    if (grandTotal === 0) {
        noDataEl.style.display = 'block'; svgWrap.innerHTML = ''; legendEl.innerHTML = '';
        if (insightEl) insightEl.style.display = 'none'; return;
    }

    // ── 3. Layout ──────────────────────────────────────────────────────────
    const SIZE = 580;
    const CX = SIZE / 2, CY = SIZE / 2;
    const R_OUT = 250, R_IN = 218;  // outer/inner radius of arcs
    const GAP_ANGLE = 0.018;         // radians gap between arcs
    const totalGap = GAP_ANGLE * nodes.length;
    const totalArc = 2 * Math.PI - totalGap;

    // Assign start/end angles
    let cursor = -Math.PI / 2;  // start at top
    nodes.forEach(n => {
        n.startAngle = cursor;
        n.spanAngle  = (n.total / grandTotal) * totalArc;
        n.endAngle   = cursor + n.spanAngle;
        n.midAngle   = (n.startAngle + n.endAngle) / 2;
        cursor = n.endAngle + GAP_ANGLE;
    });

    // ── 4. SVG helpers ─────────────────────────────────────────────────────
    function pt(r, a) { return [CX + r * Math.cos(a), CY + r * Math.sin(a)]; }
    function arcPath(r, a1, a2) {
        const [x1, y1] = pt(r, a1), [x2, y2] = pt(r, a2);
        const large = (a2 - a1) > Math.PI ? 1 : 0;
        return `M ${x1.toFixed(2)} ${y1.toFixed(2)} A ${r} ${r} 0 ${large} 1 ${x2.toFixed(2)} ${y2.toFixed(2)}`;
    }
    function chordPath(a1s, a1e, a2s, a2e) {
        // cubic bezier chord connecting two arcs through centre
        const [sx1, sy1] = pt(R_IN, a1s), [sx2, sy2] = pt(R_IN, a1e);
        const [tx1, ty1] = pt(R_IN, a2s), [tx2, ty2] = pt(R_IN, a2e);
        return `M ${sx1.toFixed(2)} ${sy1.toFixed(2)}
                A ${R_IN} ${R_IN} 0 0 1 ${sx2.toFixed(2)} ${sy2.toFixed(2)}
                C ${(CX*0.3+sx2*0.7).toFixed(2)} ${(CY*0.3+sy2*0.7).toFixed(2)},
                  ${(CX*0.3+tx1*0.7).toFixed(2)} ${(CY*0.3+ty1*0.7).toFixed(2)},
                  ${tx1.toFixed(2)} ${ty1.toFixed(2)}
                A ${R_IN} ${R_IN} 0 0 1 ${tx2.toFixed(2)} ${ty2.toFixed(2)}
                C ${(CX*0.3+tx2*0.7).toFixed(2)} ${(CY*0.3+ty2*0.7).toFixed(2)},
                  ${(CX*0.3+sx1*0.7).toFixed(2)} ${(CY*0.3+sy1*0.7).toFixed(2)},
                  ${sx1.toFixed(2)} ${sy1.toFixed(2)} Z`;
    }

    // ── 5. Build chord segments ────────────────────────────────────────────
    // Per-node cursor tracking for sub-arcs (where chords attach)
    const nodeSubCursor = {};
    nodes.forEach(n => { nodeSubCursor[n.id + '|' + n.dim] = n.startAngle; });

    const chords = [];
    top1.forEach(a => {
        const nA = nodes.find(n => n.id === a && n.dim === 1);
        if (!nA || nA.total === 0) return;
        top2.forEach(b => {
            const v = flowMap[a]?.[b] || 0;
            if (v === 0) return;
            const nB = nodes.find(n => n.id === b && n.dim === 2);
            if (!nB || nB.total === 0) return;
            const keyA = a + '|1', keyB = b + '|2';
            const spanA = (v / grandTotal) * totalArc;
            const spanB = (v / grandTotal) * totalArc;
            const a1s = nodeSubCursor[keyA], a1e = a1s + spanA;
            const a2s = nodeSubCursor[keyB], a2e = a2s + spanB;
            nodeSubCursor[keyA] = a1e;
            nodeSubCursor[keyB] = a2e;
            chords.push({ a, b, v, a1s, a1e, a2s, a2e, color: nA.color });
        });
    });

    // ── 6. Render SVG ─────────────────────────────────────────────────────
    const metLbl = metric === 'hataliMiktar' ? 'Hatalı Miktar' : 'Kayıt Sayısı';
    const DIM_LABELS = { hataTipi:'Hata Tipi', tespitYeri:'Tespit Yeri', hataKaynagi:'Hata Kaynağı', cariAdi:'Tedarikçi' };

    let chordsSvg = chords.map((c, ci) => {
        const path = chordPath(c.a1s, c.a1e, c.a2s, c.a2e);
        const vStr = c.v.toLocaleString('tr-TR', { maximumFractionDigits: 0 });
        const tip  = `${c.a} → ${c.b}: ${vStr} ${metLbl}`;
        return `<path class="chord-ribbon" d="${path}" fill="${c.color}" fill-opacity="0.42" stroke="${c.color}" stroke-width="0.5"
            onmouseenter="(function(e){var t=document.getElementById('chordTooltip');t.style.display='block';t.innerHTML='${tip.replace(/'/g,"&#39;")}';t.style.left=(e.clientX+14)+'px';t.style.top=(e.clientY-10)+'px';})(event)"
            onmousemove="(function(e){var t=document.getElementById('chordTooltip');t.style.left=(e.clientX+14)+'px';t.style.top=(e.clientY-10)+'px';})(event)"
            onmouseleave="document.getElementById('chordTooltip').style.display='none'"
            style="cursor:pointer;transition:fill-opacity .15s"/>`;
    }).join('\n');

    let arcsSvg = nodes.map(n => {
        if (n.spanAngle < 0.001) return '';
        const arc   = arcPath(R_OUT, n.startAngle, n.endAngle);
        const arcI  = arcPath(R_IN,  n.startAngle, n.endAngle);
        const [px, py] = pt(R_OUT + 18, n.midAngle);
        const anchor = Math.abs(n.midAngle) < 0.1 || Math.abs(n.midAngle - Math.PI) < 0.1 ? 'middle'
                     : (Math.cos(n.midAngle) > 0 ? 'start' : 'end');
        const label = n.id.length > 18 ? n.id.slice(0, 16) + '…' : n.id;
        const vStr  = n.total.toLocaleString('tr-TR', { maximumFractionDigits: 0 });
        const tip   = `${n.id} (${DIM_LABELS[n.dim===1?dim1:dim2]}): ${vStr} ${metLbl}`.replace(/'/g,'&#39;');
        return `
        <path d="${arc} L ${pt(R_IN, n.endAngle).map(v=>v.toFixed(2)).join(' ')}
                  ${arcI.replace('M','').split('A')[0]} A ${R_IN} ${R_IN} 0 ${n.spanAngle>Math.PI?1:0} 0 ${pt(R_IN,n.startAngle).map(v=>v.toFixed(2)).join(' ')} Z"
              fill="${n.color}" stroke="#fff" stroke-width="1"
              fill-opacity="0.9"
              onmouseenter="(function(e){var t=document.getElementById('chordTooltip');t.style.display='block';t.innerHTML='${tip}';t.style.left=(e.clientX+14)+'px';t.style.top=(e.clientY-10)+'px';})(event)"
              onmousemove="(function(e){var t=document.getElementById('chordTooltip');t.style.left=(e.clientX+14)+'px';t.style.top=(e.clientY-10)+'px';})(event)"
              onmouseleave="document.getElementById('chordTooltip').style.display='none'"
              style="cursor:pointer"/>
        <text x="${px.toFixed(2)}" y="${py.toFixed(2)}" text-anchor="${anchor}" dominant-baseline="middle"
              font-size="11" fill="#2e1065" font-family="Arial,sans-serif" font-weight="700"
              paint-order="stroke" stroke="#fff" stroke-width="3">${label}</text>`;
    }).join('\n');

    svgWrap.innerHTML = `
        <svg viewBox="0 0 ${SIZE} ${SIZE}" style="width:100%;max-width:${SIZE}px;display:block;overflow:visible;">
            <circle cx="${CX}" cy="${CY}" r="${R_IN}" fill="#f9f5ff" opacity="0.6"/>
            ${chordsSvg}
            ${arcsSvg}
            <text x="${CX}" y="${CY - 10}" text-anchor="middle" font-size="11" fill="#6b21a8" font-family="Arial,sans-serif" font-weight="700">${DIM_LABELS[dim1]}</text>
            <text x="${CX}" y="${CY + 10}" text-anchor="middle" font-size="11" fill="#065f46" font-family="Arial,sans-serif" font-weight="700">↕</text>
            <text x="${CX}" y="${CY + 26}" text-anchor="middle" font-size="11" fill="#065f46" font-family="Arial,sans-serif" font-weight="700">${DIM_LABELS[dim2]}</text>
        </svg>`;

    // ── 7. Legend ──────────────────────────────────────────────────────────
    if (legendEl) {
        const dim1items = top1.map((k, i) => ({name: k, color: DIM1_PALETTE[i % DIM1_PALETTE.length], total: tot1[k]||0, dim: DIM_LABELS[dim1]}));
        const dim2items = top2.map((k, i) => ({name: k, color: DIM2_PALETTE[i % DIM2_PALETTE.length], total: tot2[k]||0, dim: DIM_LABELS[dim2]}));
        legendEl.innerHTML =
            `<div style="font-size:.75rem;font-weight:800;color:#4a0a6b;padding:2px 0 4px;">${DIM_LABELS[dim1]}</div>` +
            dim1items.map(it => `<div class="chord-leg-item"><div class="chord-leg-dot" style="background:${it.color}"></div><span title="${it.name}">${it.name.length>22?it.name.slice(0,20)+'…':it.name} <em style="color:#a855f7">(${it.total.toLocaleString('tr-TR',{maximumFractionDigits:0})})</em></span></div>`).join('') +
            `<div style="font-size:.75rem;font-weight:800;color:#065f46;padding:8px 0 4px;">${DIM_LABELS[dim2]}</div>` +
            dim2items.map(it => `<div class="chord-leg-item"><div class="chord-leg-dot" style="background:${it.color};border-radius:50%"></div><span title="${it.name}">${it.name.length>22?it.name.slice(0,20)+'…':it.name} <em style="color:#0d9488">(${it.total.toLocaleString('tr-TR',{maximumFractionDigits:0})})</em></span></div>`).join('');
    }

    // ── 8. Insight ─────────────────────────────────────────────────────────
    if (insightEl) {
        const topFlow = [...chords].sort((a,b)=>b.v-a.v)[0];
        insightEl.style.display = 'block';
        insightEl.innerHTML = `🕸️ <strong>${top1.length}</strong> ${DIM_LABELS[dim1]} × <strong>${top2.length}</strong> ${DIM_LABELS[dim2]} çifti gösteriliyor &nbsp;|&nbsp;
            Toplam: <strong>${grandTotal.toLocaleString('tr-TR',{maximumFractionDigits:0})}</strong> ${metLbl} &nbsp;|&nbsp;
            ${topFlow ? `En yüksek akış: <strong>${topFlow.a} → ${topFlow.b}</strong> (${topFlow.v.toLocaleString('tr-TR',{maximumFractionDigits:0})} ${metLbl})` : ''}
            &nbsp;| Chord üzerinden hover yaparak detay görebilirsiniz.`;
    }
}

// ─── BEESWARM / DOT PLOT ─────────────────────────────────────────────────────
let _bswSelected    = new Set();
let _bswLastGroupBy = null;

function _bswSelectAll(select) {
    const items = document.querySelectorAll('#bswSelList .bsw-sel-item');
    _bswSelected.clear();
    items.forEach(el => {
        const cb  = el.querySelector('input[type=checkbox]');
        const lbl = el.dataset.label;
        if (select) { cb.checked = true;  _bswSelected.add(lbl); }
        else        { cb.checked = false; }
        el.classList.toggle('bsi-active', select);
    });
    renderBeeswarm();
}

function _bswBuildSelector(allTopGroups, groupBy, grpColorMap) {
    const list = document.getElementById('bswSelList');
    if (!list) return;
    const resetSel = groupBy !== _bswLastGroupBy;
    _bswLastGroupBy = groupBy;
    if (resetSel) {
        _bswSelected.clear();
        allTopGroups.forEach(([k]) => _bswSelected.add(k));
    }
    list.innerHTML = '';
    allTopGroups.forEach(([k]) => {
        const isActive = _bswSelected.size === 0 || _bswSelected.has(k);
        const item = document.createElement('div');
        item.className = 'bsw-sel-item' + (isActive ? ' bsi-active' : '');
        item.dataset.label = k;
        const safeK = k.replace(/\\/g,'\\\\').replace(/'/g,"\\'");
        item.innerHTML = `
          <input type="checkbox" ${isActive ? 'checked' : ''} onclick="event.stopPropagation();_bswToggleItem(this.closest('.bsw-sel-item'),'${safeK}')"/>
          <span class="bsw-sel-dot" style="background:${grpColorMap[k] || '#a855f7'}"></span>
          <span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="${k}">${k}</span>`;
        item.addEventListener('click', e => { if (e.target.tagName !== 'INPUT') _bswToggleItem(item, k); });
        list.appendChild(item);
    });
}

function _bswToggleItem(el, label) {
    const cb = el.querySelector('input[type=checkbox]');
    if (_bswSelected.has(label)) {
        _bswSelected.delete(label); cb.checked = false; el.classList.remove('bsi-active');
    } else {
        _bswSelected.add(label);   cb.checked = true;  el.classList.add('bsi-active');
    }
    renderBeeswarm();
}

function renderBeeswarm() {
    const data     = _effectiveData();
    const groupBy  = document.getElementById('bswGroupBy')?.value  || 'hataTipi';
    const metric   = document.getElementById('bswMetric')?.value   || 'hataliMiktar';
    const colorBy  = document.getElementById('bswColor')?.value    || 'group';
    const topN     = Math.max(1, parseInt(document.getElementById('bswTopN')?.value) || 8);
    const yScale   = document.getElementById('bswYScale')?.value   || 'linear';
    const R        = Math.max(2, parseInt(document.getElementById('bswRadius')?.value) || 5);
    const noDataEl = document.getElementById('bswNoData');
    const svgWrap  = document.getElementById('bswSvgWrap');
    const insightEl= document.getElementById('bswInsight');
    const tooltip  = document.getElementById('bswTooltip');
    if (!svgWrap) return;

    // ── 1. Collect rows with valid metric value ────────────────────────────
    const rows = data.map(r => {
        const grp = (r[groupBy] || '(Belirtilmemiş)').toString().trim() || '(Belirtilmemiş)';
        const val = metric === 'partiHacmi' ? Number(r.partiHacmi) : Number(r.hataliMiktar);
        const col = colorBy === 'group' ? grp : ((r[colorBy] || '(Belirtilmemiş)').toString().trim() || '(Belirtilmemiş)');
        return { grp, val, col, raw: r };
    }).filter(r => isFinite(r.val) && r.val > 0);

    if (!rows.length) {
        noDataEl.style.display = 'block'; svgWrap.innerHTML = '';
        if (insightEl) insightEl.style.display = 'none'; return;
    }
    noDataEl.style.display = 'none';

    // ── 2. Top N groups by total ───────────────────────────────────────────
    const grpTotals = {};
    rows.forEach(r => { grpTotals[r.grp] = (grpTotals[r.grp] || 0) + r.val; });
    const allTopGroups = Object.entries(grpTotals).sort((a,b) => b[1]-a[1]).slice(0, topN);
    const PAL_PRE = ['#4a0a6b','#6d28d9','#8b5cf6','#b94fc4','#c084fc','#e879f9',
        '#a21caf','#7c3aed','#db2777','#4f46e5','#0891b2','#0d9488',
        '#065f46','#b45309','#be123c','#1d4ed8','#047857','#9333ea'];
    const grpColorPre = {};
    allTopGroups.forEach(([k], i) => { grpColorPre[k] = PAL_PRE[i % PAL_PRE.length]; });
    _bswBuildSelector(allTopGroups, groupBy, grpColorPre);
    const topGroups = allTopGroups.map(([k]) => k).filter(k => _bswSelected.size === 0 || _bswSelected.has(k));
    const visRows   = rows.filter(r => topGroups.includes(r.grp));
    if (!visRows.length) { svgWrap.innerHTML = '<p style="padding:24px;color:#aaa;text-align:center">Hiç grup seçilmedi.</p>'; if (insightEl) insightEl.style.display='none'; return; }

    // ── 3. Colour palette ──────────────────────────────────────────────────
    const PALETTE = [
        '#4a0a6b','#6d28d9','#8b5cf6','#b94fc4','#c084fc','#e879f9',
        '#a21caf','#7c3aed','#db2777','#4f46e5','#0891b2','#0d9488',
        '#065f46','#b45309','#be123c','#1d4ed8','#047857','#9333ea'
    ];
    const colorKeys = [...new Set(visRows.map(r => r.col))].sort();
    const colorMap  = {};
    colorKeys.forEach((k, i) => { colorMap[k] = PALETTE[i % PALETTE.length]; });

    // ── 4. Layout constants ────────────────────────────────────────────────
    const MARGIN = { top: 20, right: 24, bottom: 90, left: 72 };
    const COL_W  = Math.max(120, Math.min(240, Math.floor(800 / topGroups.length)));
    const W      = topGroups.length * COL_W + MARGIN.left + MARGIN.right;
    const H      = 520;
    const PLOT_W = W - MARGIN.left - MARGIN.right;
    const PLOT_H = H - MARGIN.top  - MARGIN.bottom;

    // ── 5. Y scale ─────────────────────────────────────────────────────────
    const allVals = visRows.map(r => r.val);
    const yMin    = yScale === 'log' ? Math.max(1, Math.min(...allVals)) : 0;
    const yMax    = Math.max(...allVals);

    function yPos(v) {
        const vClamped = Math.max(v, yMin);
        if (yScale === 'log') {
            const logMin = Math.log10(yMin || 1), logMax = Math.log10(yMax || 1);
            return PLOT_H - ((Math.log10(vClamped) - logMin) / (Math.max(logMax - logMin, 1e-9))) * PLOT_H;
        }
        return PLOT_H - ((vClamped - yMin) / (Math.max(yMax - yMin, 1e-9))) * PLOT_H;
    }

    // ── 6. Beeswarm collision dodge (simple 1D per-column) ────────────────
    // For each group column, sort by value and spread dots horizontally
    // using a greedy packing that avoids overlap
    function beeswarmDodge(points, radius) {
        // points: [{val, y}] sorted by y (asc)
        const placed = [];
        for (const p of points) {
            let best = 0, step = 1, placed_ = false;
            for (let side = 0; side <= COL_W / 2; side += radius * 0.7) {
                for (const sign of [0, 1, -1]) {
                    const cx = sign * side;
                    const ok = placed.every(q => {
                        const dy = p.y - q.y, dx = cx - q.x;
                        return Math.sqrt(dx*dx + dy*dy) >= radius * 2 - 0.5;
                    });
                    if (ok) { p.x = cx; placed.push(p); placed_ = true; break; }
                }
                if (placed_) break;
            }
            if (!placed_) { p.x = (Math.random() - 0.5) * COL_W * 0.35; placed.push(p); }
        }
        return placed;
    }

    // Group rows by column
    const colPoints = {};
    topGroups.forEach((g, gi) => {
        const pts = visRows.filter(r => r.grp === g).map(r => ({
            val: r.val, col: r.col, raw: r,
            y: yPos(r.val) + MARGIN.top,
            x: 0
        })).sort((a, b) => a.y - b.y);
        beeswarmDodge(pts, R);
        colPoints[g] = { gi, pts };
    });

    // ── 7. Y-axis ticks ───────────────────────────────────────────────────
    const TICK_COUNT = 6;
    let ticks = [];
    if (yScale === 'log') {
        const logMin = Math.floor(Math.log10(yMin || 1));
        const logMax = Math.ceil(Math.log10(yMax || 1));
        for (let e = logMin; e <= logMax; e++) ticks.push(Math.pow(10, e));
    } else {
        const step = (yMax - yMin) / (TICK_COUNT - 1);
        for (let i = 0; i < TICK_COUNT; i++) ticks.push(yMin + step * i);
    }

    function fmtVal(v) {
        if (v >= 1e6) return (v/1e6).toFixed(1) + 'M';
        if (v >= 1e3) return (v/1e3).toFixed(1) + 'K';
        return Math.round(v).toLocaleString('tr-TR');
    }

    const metLbl  = metric === 'partiHacmi' ? 'Parti Hacmi' : 'Hatalı Miktar';
    const grpLbls = { hataTipi:'Hata Tipi', tespitYeri:'Tespit Yeri', hataKaynagi:'Hata Kaynağı', cariAdi:'Tedarikçi' };

    // ── 8. Build SVG ──────────────────────────────────────────────────────
    // Grid lines
    const gridLines = ticks.map(v => {
        const y = MARGIN.top + yPos(v);
        const vStr = fmtVal(v);
        return `<line x1="${MARGIN.left}" y1="${y.toFixed(1)}" x2="${MARGIN.left + PLOT_W}" y2="${y.toFixed(1)}"
                      stroke="#e9d5ff" stroke-width="1" stroke-dasharray="4,3"/>
                <text x="${(MARGIN.left - 6).toFixed(1)}" y="${y.toFixed(1)}"
                      text-anchor="end" dominant-baseline="middle"
                      font-size="10" fill="#6b21a8" font-family="Arial,sans-serif">${vStr}</text>`;
    }).join('\n');

    // X axis group labels + median line
    const xAxisLabels = topGroups.map((g, gi) => {
        const cx = MARGIN.left + gi * COL_W + COL_W / 2;
        const shortG = g.length > 18 ? g.slice(0, 16) + '…' : g;
        // Median line
        const pts = colPoints[g].pts;
        const sorted = [...pts].sort((a,b)=>a.val-b.val);
        const med = sorted.length ? sorted[Math.floor(sorted.length/2)].val : 0;
        const myY = MARGIN.top + yPos(med);
        const stripe = `<line x1="${(cx - COL_W*0.3).toFixed(1)}" y1="${myY.toFixed(1)}"
                             x2="${(cx + COL_W*0.3).toFixed(1)}" y2="${myY.toFixed(1)}"
                             stroke="#4a0a6b" stroke-width="2.5" stroke-linecap="round" opacity="0.7"/>`;
        const lbl = `<text x="${cx.toFixed(1)}" y="${(H - MARGIN.bottom + 14).toFixed(1)}"
                           text-anchor="middle" font-size="11" fill="#2e1065"
                           font-family="Arial,sans-serif" font-weight="700"
                           paint-order="stroke" stroke="#fff" stroke-width="3">${shortG}</text>`;
        return stripe + lbl;
    }).join('\n');

    // Dots
    const dots = topGroups.map((g, gi) => {
        const cx = MARGIN.left + gi * COL_W + COL_W / 2;
        return colPoints[g].pts.map(p => {
            const dotX = (cx + p.x).toFixed(1);
            const dotY = p.y.toFixed(1);
            const dotColor = colorMap[p.col] || '#8b5cf6';
            const vStr = p.val.toLocaleString('tr-TR', { maximumFractionDigits: 1 });
            const td = p.raw.uygunsuzlukTarih ? String(p.raw.uygunsuzlukTarih).slice(0,10) : '';
            const tip = `${g}&#10;${metLbl}: ${vStr}&#10;${p.raw.hataTipi||''}${td?' — '+td:''}${p.col!==g?' ['+p.col+']':''}`.replace(/'/g,'&#39;');
            return `<circle cx="${dotX}" cy="${dotY}" r="${R}" fill="${dotColor}" fill-opacity="0.75"
                        stroke="${dotColor}" stroke-width="0.8"
                        onmouseenter="(function(e){var t=document.getElementById('bswTooltip');t.style.display='block';t.innerHTML='${tip}';t.style.left=(e.clientX+14)+'px';t.style.top=(e.clientY-10)+'px';})(event)"
                        onmousemove="(function(e){var t=document.getElementById('bswTooltip');t.style.left=(e.clientX+14)+'px';t.style.top=(e.clientY-10)+'px';})(event)"
                        onmouseleave="document.getElementById('bswTooltip').style.display='none'"
                        style="cursor:pointer;transition:r .1s,fill-opacity .1s"
                        onmouseenter2="" />`;
        }).join('\n');
    }).join('\n');

    // Colour legend (for colorBy != group)
    let legendSvg = '';
    if (colorBy !== 'group') {
        let lx = MARGIN.left, ly = H - MARGIN.bottom + 34;
        legendSvg = colorKeys.map((k, i) => {
            const short = k.length > 18 ? k.slice(0,16)+'…' : k;
            const item = `<circle cx="${lx + 6}" cy="${(ly + 5).toFixed(1)}" r="5" fill="${colorMap[k]}" fill-opacity=".8"/>
                <text x="${lx + 16}" y="${(ly + 9).toFixed(1)}" font-size="10" fill="#333" font-family="Arial,sans-serif">${short}</text>`;
            lx += Math.min(short.length * 6.5 + 28, 180);
            if (lx > W - MARGIN.right - 60) { lx = MARGIN.left; ly += 18; }
            return item;
        }).join('\n');
    }

    svgWrap.innerHTML = `
        <svg viewBox="0 0 ${W} ${H + (colorBy!=='group' ? Math.ceil(colorKeys.length/6)*18 : 0)}"
             style="width:100%;min-width:${Math.min(W,960)}px;display:block;overflow:visible;font-family:Arial,sans-serif;">
            <!-- Y axis label -->
            <text x="${(MARGIN.left - 52).toFixed(1)}" y="${(MARGIN.top + PLOT_H/2).toFixed(1)}"
                  transform="rotate(-90 ${(MARGIN.left-52).toFixed(1)} ${(MARGIN.top+PLOT_H/2).toFixed(1)})"
                  text-anchor="middle" font-size="11" fill="#6b21a8" font-weight="700">${metLbl}</text>
            <!-- Grid -->
            ${gridLines}
            <!-- Axes -->
            <line x1="${MARGIN.left}" y1="${MARGIN.top}" x2="${MARGIN.left}" y2="${MARGIN.top+PLOT_H}"
                  stroke="#c4b5fd" stroke-width="1.5"/>
            <line x1="${MARGIN.left}" y1="${MARGIN.top+PLOT_H}" x2="${MARGIN.left+PLOT_W}" y2="${MARGIN.top+PLOT_H}"
                  stroke="#c4b5fd" stroke-width="1.5"/>
            <!-- Median lines + X labels -->
            ${xAxisLabels}
            <!-- Dots -->
            ${dots}
            <!-- Colour legend -->
            ${legendSvg}
            <!-- Legend: median -->
            <line x1="${MARGIN.left}" y1="${(H - MARGIN.bottom + 50).toFixed(1)}"
                  x2="${(MARGIN.left + 24).toFixed(1)}" y2="${(H - MARGIN.bottom + 50).toFixed(1)}"
                  stroke="#4a0a6b" stroke-width="2.5"/>
            <text x="${(MARGIN.left + 28).toFixed(1)}" y="${(H - MARGIN.bottom + 54).toFixed(1)}"
                  font-size="10" fill="#4a0a6b" font-family="Arial,sans-serif">Medyan çizgisi</text>
        </svg>`;

    // ── 9. Insight ─────────────────────────────────────────────────────────
    if (insightEl) {
        const totalDots = visRows.length;
        const allSorted = [...visRows].sort((a,b)=>a.val-b.val);
        const median    = allSorted[Math.floor(allSorted.length/2)]?.val || 0;
        const maxRow    = allSorted[allSorted.length-1];
        insightEl.style.display = 'block';
        insightEl.innerHTML = `🟣 <strong>${totalDots}</strong> kayıt nokta olarak çizildi &nbsp;|&nbsp;
            Genel Medyan: <strong>${fmtVal(median)}</strong> ${metLbl} &nbsp;|&nbsp;
            Maks: <strong>${fmtVal(maxRow.val)}</strong> — ${maxRow.grp}
            ${maxRow.raw.hataTipi ? ' / ' + maxRow.raw.hataTipi : ''}
            &nbsp;| Noktaların üzerine gelin detay görün.`;
    }
}

// ─── IndexedDB Persistence (localStorage'dan çok daha büyük limit) ─────────────
const DB_NAME    = 'UygunsuzlukDB';
const DB_VERSION = 1;
const STORE_NAME = 'cache';
let _db = null;

function openDB() {
    return new Promise((resolve, reject) => {
        if (_db) { resolve(_db); return; }
        const req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onupgradeneeded = e => {
            e.target.result.createObjectStore(STORE_NAME);
        };
        req.onsuccess = e => { _db = e.target.result; resolve(_db); };
        req.onerror   = e => reject(e.target.error);
    });
}

function dbSet(key, value) {
    return openDB().then(db => new Promise((resolve, reject) => {
        const tx  = db.transaction(STORE_NAME, 'readwrite');
        const req = tx.objectStore(STORE_NAME).put(value, key);
        req.onsuccess = () => resolve();
        req.onerror   = e => reject(e.target.error);
    }));
}

function dbGet(key) {
    return openDB().then(db => new Promise((resolve, reject) => {
        const tx  = db.transaction(STORE_NAME, 'readonly');
        const req = tx.objectStore(STORE_NAME).get(key);
        req.onsuccess = e => resolve(e.target.result);
        req.onerror   = e => reject(e.target.error);
    }));
}

function dbDelete(key) {
    return openDB().then(db => new Promise((resolve, reject) => {
        const tx  = db.transaction(STORE_NAME, 'readwrite');
        const req = tx.objectStore(STORE_NAME).delete(key);
        req.onsuccess = () => resolve();
        req.onerror   = e => reject(e.target.error);
    }));
}

function saveToStorage(fileName, sheetName) {
    showLoading(true);
    Promise.all([
        dbSet('data', allData),
        dbSet('meta', { fileName, sheetName, savedAt: new Date().toISOString() })
    ]).then(() => {
        showLoading(false);
    }).catch(err => {
        showLoading(false);
        showToast('Veri hafızaya kaydedilemedi: ' + err.message, 'error');
    });
}

function loadFromStorage() {
    // Önce localStorage'dan musteriSet yükle (hızlı)
    try {
        const ls = localStorage.getItem('uyg_musteriSet');
        if (ls) musteriSet = new Set(JSON.parse(ls));
    } catch(e) {}

    Promise.all([dbGet('meta'), dbGet('data'), dbGet('musteriSet')]).then(([meta, data, mSet]) => {
        // IndexedDB'de varsa ve localStorage'dan daha büyükse onu kullan
        if (mSet && Array.isArray(mSet) && mSet.length > musteriSet.size) {
            musteriSet = new Set(mSet);
            try { localStorage.setItem('uyg_musteriSet', JSON.stringify(mSet)); } catch(e) {}
        }
        if (!meta || !data || !data.length) return;
        allData       = data;
        filteredData  = [...allData];
        const savedAt = new Date(meta.savedAt).toLocaleString('tr-TR');
        showFileInfo(meta.fileName, meta.sheetName, allData.length, savedAt);
        initUI();
        showToast(`Hafızadan yüklendi: ${allData.length} kayıt`, 'success');
    }).catch(() => { /* hiç kayıt yok */ });
}

function clearStorage() {
    Promise.all([dbDelete('data'), dbDelete('meta')]).then(() => {
        allData = []; filteredData = []; tableSearchData = [];
        document.getElementById('fileInfo').style.display = 'none';
        document.getElementById('statsRow').style.display = 'none';
        document.getElementById('filterCard').style.display = 'none';
        document.getElementById('mainContent').style.display = 'none';
        document.getElementById('emptyState').style.display = 'block';
        if (paretoChartInst) { paretoChartInst.destroy(); paretoChartInst = null; }
        showToast('Hafıza temizlendi. Yeni dosya yükleyebilirsiniz.');
    });
}

function showFileInfo(fileName, sheetName, count, fromCache) {
    const el = document.getElementById('fileInfo');
    el.style.display = 'block';
    const cacheNote = fromCache
        ? ` &nbsp;<span style="color:#7b2d8b;font-size:0.85em">(💾 ${fromCache} tarihinde kaydedildi)</span>`
        : '';
    el.innerHTML = `✅ <strong>${fileName}</strong> — <strong>${count}</strong> kayıt, sayfa: <strong>${sheetName}</strong>${cacheNote}
        &nbsp;&nbsp;<button onclick="clearStorage()" style="background:#fff0f8;border:1.2px solid #b94fc4;color:#7b2d8b;padding:3px 10px;border-radius:6px;cursor:pointer;font-size:0.82em;font-weight:600;" title="Hafızayı temizle ve yeni dosya yükle">🗑 Temizle</button>`;
}

document.addEventListener('DOMContentLoaded', loadFromStorage);
document.addEventListener('click', e => {
    if (e.target.id === 'uaSnapModal')  document.getElementById('uaSnapModal').classList.remove('open');
    if (e.target.id === 'uaFiltreModal') document.getElementById('uaFiltreModal').classList.remove('open');
});

// ─── Helpers ──────────────────────────────────────────────────────────────────
function showLoading(show) {
    document.getElementById('loadingOverlay').classList.toggle('show', show);
}

function showToast(msg, type) {
    const el = document.getElementById('toast');
    el.textContent = msg;
    el.className = 'toast show' + (type ? ' ' + type : '');
    clearTimeout(el._t);
    el._t = setTimeout(() => el.classList.remove('show'), 3200);
}

// ─── Çoklu Analiz ───────────────────────────────────────────────────────────
function toggleMultiAnalyze() {
    multiAnalyzeMode = !multiAnalyzeMode;
    selectedForMulti.clear();
    const btn = document.getElementById('multiAnalyzeToggleBtn');
    const bar = document.getElementById('multiAnalyzeBar');
    if (multiAnalyzeMode) {
        btn.style.background = '#1a6b5a'; btn.style.color = 'white';
        btn.textContent = '✖ Kapat';
        if (bar) bar.style.display = 'flex';
    } else {
        btn.style.background = '#e8f5f1'; btn.style.color = '#1a6b5a';
        btn.textContent = '📊 Çoklu Analiz';
        if (bar) bar.style.display = 'none';
    }
    renderBreakdown();
}

function toggleMultiSelect(hataTipi) {
    if (!multiAnalyzeMode) return;
    if (selectedForMulti.has(hataTipi)) selectedForMulti.delete(hataTipi);
    else selectedForMulti.add(hataTipi);
    const safeId = 'bdi-' + btoa(encodeURIComponent(hataTipi)).replace(/=/g,'');
    const card = document.getElementById(safeId);
    if (card) card.classList.toggle('selected-for-multi', selectedForMulti.has(hataTipi));
    const cnt = document.getElementById('multiAnalyzeCount');
    if (cnt) cnt.textContent = selectedForMulti.size;
}

function openFishboneMulti() {
    if (!selectedForMulti.size) { showToast('En az 1 hata tipi seçin', 'error'); return; }
    const selected = [...selectedForMulti];
    const relRows = filteredData.filter(r => selected.includes(r.hataTipi));
    const BONE_COLORS = ['#ef4444','#f59e0b','#3b82f6','#8b5cf6','#06b6d4','#22c55e'];
    let _nid = 1; const mkId = () => _nid++;
    const mkChildren = (vals, color) => vals.map(v => ({id:mkId(),name:v,color,children:[],collapsed:false,offsetX:0,offsetY:0}));
    // 6M ana kemikler — seçili hata tiplerinin toplu verisi
    const bonesConfig = [
        {name:'👤 İnsan',    desc:'Hata kaynağı analizi',        color:BONE_COLORS[0], side:'top',    field:'hataKaynagi'},
        {name:'⚙️ Makine',   desc:'Makine / ekipman',             color:BONE_COLORS[1], side:'bottom', field:'makine'},
        {name:'📦 Malzeme',  desc:`Hata tipleri: ${selected.join(', ')}`, color:BONE_COLORS[2], side:'top', field:'hataTipi'},
        {name:'📋 Metot',    desc:'Uygunsuzluk türü',            color:BONE_COLORS[3], side:'bottom', field:'uygunsuzlukTuru'},
        {name:'📐 Ölçüm',   desc:'Uygunsuzluk tipi',            color:BONE_COLORS[4], side:'top',    field:'tipi'},
        {name:'🌡️ Ortam',   desc:'(Manuel doldurun)',           color:BONE_COLORS[5], side:'bottom', field:null},
    ];
    const causes = bonesConfig.map(b => ({
        id:mkId(), name:b.name, description:b.desc,
        color:b.color, side:b.side, collapsed:false,
        children: b.field ? mkChildren(topNField(relRows, b.field, 5), b.color) : [],
        offsetX:0, offsetY:0, baseOffsetX:0, baseOffsetY:0
    }));
    const total = relRows.reduce((s,r)=>s+(Number(r.hataliMiktar)||0),0);
    localStorage.setItem('fishbone_incoming', JSON.stringify({
        problem: `Çoklu Hata Analizi (${selected.length} tip)`,
        problemDesc: `Seçili hata tipleri: ${selected.join(', ')}\n• Toplam hatalı: ${total.toLocaleString('tr',{maximumFractionDigits:1})}\nKaynak: Uygunsuzluk Analizi`,
        source:'uygunsuzluk-analizi', causes, nextId:_nid
    }));
    localStorage.setItem('fishbone_source', 'uygunsuzluk-analizi');
    window.open('balik-kilcigi.html','_blank');
}
</script>

<div id="uaSnapModal">
    <div id="uaSnapBox">
        <div style="display:flex;align-items:center;gap:10px;margin-bottom:18px;">
            <h3>📁 Kayıtlı Kapsamlı Raporlar</h3>
            <button onclick="document.getElementById('uaSnapModal').classList.remove('open')" style="margin-left:auto;background:#f1f5f9;border:none;border-radius:6px;padding:6px 14px;cursor:pointer;font-size:.82rem;font-weight:600;">✕ Kapat</button>
        </div>
        <div id="uaSnapList"></div>
    </div>
</div>

<div id="uaFiltreModal">
    <div id="uaFiltreBox">
        <div style="display:flex;align-items:center;gap:10px;margin-bottom:18px;">
            <h3>📂 Kayıtlı Filtreler</h3>
            <button onclick="document.getElementById('uaFiltreModal').classList.remove('open')" style="margin-left:auto;background:#f1f5f9;border:none;border-radius:6px;padding:6px 14px;cursor:pointer;font-size:.82rem;font-weight:600;">✕ Kapat</button>
        </div>
        <div id="uaFiltreList"></div>
    </div>
</div>

<!-- Çoklu Analiz Alt Barı -->
<div id="multiAnalyzeBar" class="multi-analyze-bar" style="display:none;">
    <div><span id="multiAnalyzeCount">0</span> hata tipi seçildi &mdash; kartlara tıklayarak seçin</div>
    <div style="display:flex;gap:10px;">
        <button onclick="openFishboneMulti()">🐟 Fishbone'a Gönder</button>
        <button class="multi-cancel-btn" onclick="toggleMultiAnalyze()">İptal</button>
    </div>
</div>

<!-- CHART PICKER MODAL -->
<div id="chartPickerModal" onclick="if(event.target===this)this.classList.remove('open')">
    <div class="cpm-box">
        <div class="cpm-head">
            <h3>📑 Kapsamlı Rapora Ekle</h3>
            <button class="cpm-close" onclick="document.getElementById('chartPickerModal').classList.remove('open')">✕</button>
        </div>
        <div id="cpmFilterInfo" style="padding:10px 20px;background:#f0f7ff;border-bottom:1px solid #e2e8f0;font-size:.8rem;color:#1e3a8a;"></div>
        <div style="padding:8px 20px 0;font-size:.78rem;color:#64748b;font-weight:600;letter-spacing:.3px;">RAPORA EKİLENECEK GRAFİKLER</div>
        <div class="cpm-all-row">
            <button class="cpm-all-btn" onclick="_cpmSelectAll(true)">Tümünü Seç</button>
            <button class="cpm-all-btn" onclick="_cpmSelectAll(false)">İşareti Kaldır</button>
        </div>
        <div class="cpm-body" id="cpmBody"></div>
        <div class="cpm-foot">
            <span class="cpm-sel-count" id="cpmSelCount"></span>
            <div class="cpm-btns">
                <button class="cpm-btn cpm-btn-cancel" onclick="document.getElementById('chartPickerModal').classList.remove('open')">İptal</button>
                <button class="cpm-btn cpm-btn-ok" id="cpmConfirmBtn" onclick="_cpmConfirm()">✅ Rapora Ekle</button>
            </div>
        </div>
    </div>
</div>
</body>
</html>
